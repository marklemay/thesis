#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xcolor}
\usepackage{tikz-cd}
\tikzcdset{%
    triple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure' 
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    quadruple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure'
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    Rrightarrow/.code={\tikzcdset{triple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}},
    RRightarrow/.code={\tikzcdset{quadruple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}}
}    
\newcommand*{\tarrow}[2][]{\arrow[Rrightarrow, #1]{#2}\arrow[dash, shorten >= 0.5pt, #1]{#2}}
\newcommand*{\qarrow}[2][]{\arrow[RRightarrow, #1]{#2}\arrow[equal, double distance = 0.25pt, shorten >= 1.28pt, #1]{#2}}
\end_preamble
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Chapter 6 (draft): Notes, Future work, Conclusion
\end_layout

\begin_layout Author
Mark Lemay
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Seperate into notes and future work AAND then conclusion
\end_layout

\end_inset


\end_layout

\begin_layout Part
Symbolic Execution
\end_layout

\begin_layout Standard
In the introduction a more pragmatic approach to types was explored, however
 we can go further.
 We can automatically test test the type assertions of the of the project
 until errors are uncovered.
 Further this can be done passively so that the programmar is always allowed
 to see warnings and to experement to possible exerccise their own errors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

            edit program
\end_layout

\begin_layout Plain Layout

             |      
\end_layout

\begin_layout Plain Layout

             |      
\end_layout

\begin_layout Plain Layout

             v
\end_layout

\begin_layout Plain Layout

 testing  <- Elaboration                    ^
\end_layout

\begin_layout Plain Layout

    | ^      |              |               | runtime error
\end_layout

\begin_layout Plain Layout

     -       | no warnings  | type warnings |
\end_layout

\begin_layout Plain Layout

             v              v               |
\end_layout

\begin_layout Plain Layout

                run program   ---------------
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
better graphics
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Ideal Workflow
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:intro-thesis-workflow"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A one hole context
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

 can be defined for the cast languages presented in this thesis 
\begin_inset Formula $C[-]$
\end_inset

 and we can say that an error is observable if 
\begin_inset Formula $\vdash a:A$
\end_inset

 and 
\begin_inset Formula $\vdash C[a]:B$
\end_inset

 and 
\begin_inset Formula $C[a]\rightsquigarrow_{*}b$
\end_inset

 and Blame 
\begin_inset Formula $b$
\end_inset

 l o 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
correct
\end_layout

\end_inset

 for some l in a but not in C.
\end_layout

\begin_layout Standard
While formalizing a complete and efficient testing procedure allong these
 lines is still future work.
 There are likely insights to be gianed from the large body of reasurch
 on symbolic execution, especiually work that deals with typed higher oreder
 functions.
 A fully formal account would deal with a formal semantics of the cast lanfguage.
 Game semantics seems a promising formalism even if the game semantics of
 depenent types in general seems fairly complicated by iteslef
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Prevous implementations had experemented with descovering these obseravle
 errors by allowing a symbolic context that could assume obsereve behaour
 and that was consistent up to types and observation.
 For intance we might explore a term 
\begin_inset Formula $\backslash x\ f=>f\left(x+f0\right):nat->(Nat->nat)->nat$
\end_inset

 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
...
 TODO better exazmple with bools
\end_layout

\end_inset

.
 While this seems to be an origional way to explore higher order typed functions
, and it is more effiecinet then other procedures in the literature (a fully
 typed term does not need to be synthesized), the procedure is an over aproximat
ion of the intened semantics.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
all the way this misses the semantics
\end_layout

\end_inset


\end_layout

\begin_layout Part
Runtime Poof Search
\end_layout

\begin_layout Standard
Just as 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equalities are missing from the definitional relation, 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 proofs and programs are not always conveniently available to the programmer.
 For instance, in Agda it is possible to write a sorting function quickly
 using simple types.
 With effort is it possible to prove that sorting procedure correct by rewriting
 it with the necessarily dependently typed invariants.
 However, very little is offered in between.
 The problem is magnified if module boundaries hide the implementation details
 of a function, since those details are exactly what is needed to make a
 proof! This is especially important for larger scale software where a library
 may require proof terms that while 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 are not constructable from the exports of other libraries.
\end_layout

\begin_layout Standard
The solution proposed here is additional syntax that will search for a term
 of the type when resolved at runtime.
 Given the sorting function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{sort}:\mathtt{List}\,\mathbb{N}\rightarrow\mathtt{List}\,\mathbb{N}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

and given the first order predicate that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{IsSorted}:\mathtt{List}\,\mathbb{N}\rightarrow*
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

then it is possible to assert that 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 behaves as expected with
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\lambda x.?:\left(x:\mathtt{List}\,\mathbb{N}\right)\rightarrow\mathtt{IsSorted}\left(\mathtt{sort}x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

This term will act like any other function at runtime, given a 
\begin_inset Formula $\mathtt{List}$
\end_inset

 input the function will verify that the 
\begin_inset Formula $\mathtt{sort}$
\end_inset

 correctly handled that input, or the term will give an error, or non-terminate.
\end_layout

\begin_layout Standard
Additionally, this would allow simple prototyping form first order specification.
 For instance,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
data\ \mathtt{Mult} & :\mathbb{N}\rightarrow\mathbb{N}\rightarrow\mathbb{N}\rightarrow*\ where\\
\mathtt{base} & :\left(x:\mathbb{N}\right)\rightarrow\mathtt{Mult}\ 0\ x\ 0\\
\mathtt{suc} & :\left(x\,y\,z:\mathbb{N}\right)\rightarrow\mathtt{Mult}\,x\,y\,z\rightarrow\mathtt{Mult}\,\left(1+x\right)\,y\,(y+z)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

can be used to prototype
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathtt{div}=\lambda z.\lambda x.\mathtt{fst}\left(?:\sum y:\mathbb{N}.\mathtt{Mult}x\,y\,z\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

The term search can be surprisingly subtle.
 For instance,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{spacing}{0.9}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
?:\sum f:\mathbb{N}\rightarrow\mathbb{N}.\mathtt{Id}\left(f,\lambda x.x+1\right)\&\mathtt{Id}\left(f,\lambda x.1+x\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\end_inset

depends on the definitional properties of functions.
 To avoid this subtly I plan to only support term search over first order
 data.
\end_layout

\begin_layout Section
Prior Work
\end_layout

\begin_layout Standard
Proof search is often used for static term generation in dependently typed
 languages (for instance Coq tactics).
 A first order theorem prover is attached to Agda in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset

.
 However it is rare to make those features available at runtime.
 
\end_layout

\begin_layout Standard
Logic programing languages such as Prolog
\begin_inset Foot
status open

\begin_layout Plain Layout
https://www.swi-prolog.org/
\end_layout

\end_inset

, Datalog
\begin_inset Foot
status open

\begin_layout Plain Layout
https://docs.racket-lang.org/datalog/
\end_layout

\end_inset

, and miniKanren
\begin_inset Foot
status open

\begin_layout Plain Layout
http://minikanren.org/
\end_layout

\end_inset

 use 
\begin_inset Quotes eld
\end_inset

proof search
\begin_inset Quotes erd
\end_inset

 as their primary method of computation.
 However, I am not aware of any system that combines logical programming
 with full-spectrum dependent types.
 The Twelf project
\begin_inset Foot
status open

\begin_layout Plain Layout
http://twelf.org/wiki/Main_Page
\end_layout

\end_inset

 makes use of runtime proof search and has some support for dependent types,
 but the underling theory cannot be considered full-spectrum.
 
\end_layout

\begin_layout Part
Convenience 
\end_layout

\begin_layout Standard
Several addtional feature have be negleted in the implementation and the
 the theory of this thesis.
 For instance inplicit function arguments.
\end_layout

\begin_layout Part
Future work
\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
A better semantic characterization of typed observational equivlence would
 be helpful to direct further work in this area.
 Untyped observational equivlence was explored in 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 however as Wvillelm recounst in 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
...
\end_layout

\end_inset

 untyped operational equivelence is not particularly helpful.
 In this thesis we have presentated an operational senatics but this does
 not help 
\end_layout

\begin_layout Section
Effects
\end_layout

\begin_layout Standard
nontermination
\end_layout

\begin_layout Standard
handling errors
\end_layout

\begin_layout Section
Logic programming
\end_layout

\begin_layout Part
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/thesis/bibliography/dtest"
options "alpha"

\end_inset


\end_layout

\begin_layout Part
TODO
\end_layout

\begin_layout List of TODOs

\end_layout

\begin_layout Section
notes
\end_layout

\begin_layout Section
unused
\end_layout

\begin_layout Standard
More subtle is that the procedure described here will allow f to observe
 parallel or, even though parallel or cannot be constructed within the language.
 This hints that the approach presented here could be revised in terms of
 games semantics (perhaps along lines like 
\begin_inset CommandInset citation
LatexCommand cite
key "lin_et_al:LIPIcs:2020:12349"
literal "false"

\end_inset

).
 Though game semantics for dependent types is a complicated subject in and
 of itself 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 
\end_layout

\end_body
\end_document
