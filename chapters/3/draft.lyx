#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Chapter 3
\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Standard
We can now motivate the most fundemental problems with dependent type systems.
 Definitional equalityis prervasive and unintuitive.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%TODO Some overlap with the introduction
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% example of dependent types
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

For instance, dependent types can prevent an out-of-bounds error when indexing
 into a length indexed list.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%TODO make the rest concrete, or explicitly assume
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathtt{Vec} & :1_{c}\rightarrow\mathbb{N}_{c}\rightarrow*,\\
\mathtt{rep} & :\left(X:*\right)\rightarrow X\rightarrow\left(y:\mathbb{N}_{c}\right)\rightarrow\mathtt{Vec\,}X\,y,\\
\mathtt{head} & :\left(X:*\right)\rightarrow\left(y:\mathbb{N}_{c}\right)\rightarrow\mathtt{Vec}\,X\,\left(1_{c}+_{c}y\right)\rightarrow X
\end{align*}

\end_inset


\begin_inset Formula 
\[
\vdash\lambda x\Rightarrow\mathtt{head}\,\mathbb{B}_{c}\,x\,\left(\mathtt{rep}\,\mathbb{B}_{c}\,true_{c}\,\left(1_{c}+_{c}x\right)\right)\,:\,\mathbb{N}_{c}\rightarrow\mathbb{B}_{c}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{head}$
\end_inset

 is a function that expects a list of length 
\begin_inset Formula $1_{c}+_{c}y$
\end_inset

, making it impossible for 
\begin_inset Formula $\mathtt{head}$
\end_inset

 to inspect an empty list.
 Luckily the 
\begin_inset Formula $\mathtt{rep}$
\end_inset

 function will return a list of length 
\begin_inset Formula $1_{c}+_{c}y$
\end_inset

, exactly the type that is required.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% example of problem
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Unfortunately, the following will not type check in the surface language,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\cancel{\vdash}\lambda x\Rightarrow\mathtt{head}\,\mathbb{B}_{c}\,x\,\left(\mathtt{rep}\,\mathbb{B}_{c}\,true_{c}\,\left(x+_{c}1_{c}\right)\right)\,:\,\mathbb{N}_{c}\rightarrow\mathbb{B}_{c}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% explanation of example
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sloppy
\end_layout

\end_inset

 While 
\begin_inset Quotes eld
\end_inset

obviously
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $1+x=x+1$
\end_inset

, in the surface language, 
\begin_inset Formula $1_{c}+_{c}x\cancel{\equiv}x+_{c}1_{c}$
\end_inset

.
 Recall that 
\series bold
definitional equality
\series default
 is the name for the conservative approximation of equality used internally
 by dependent type systems.
 This prevents the use of a term of type 
\begin_inset Formula $\mathtt{Vec}\left(1_{c}+_{c}x\right)$
\end_inset

 where a term of type 
\begin_inset Formula $\mathtt{Vec}\left(x+_{c}1_{c}\right)$
\end_inset

 is expected.
 Usually when dependent type systems encounter situations like this, they
 will give a type error and block further evaluation.
 Especially fustraitng from the programmers perspective, if the programmer
 made a mistake in the definition of addition, such that for some 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $1_{c}+_{c}x\,\cancel{=}\,x+_{c}1_{c}$
\end_inset

, the system will not provide hints on which 
\begin_inset Formula $x$
\end_inset

 break this equality.
 The lack of clear error messages and the requirement to prove obvious equalitie
s is a problem in all dependent type systems not just the surface language.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% solution
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Why not sidestep definitional equality? Why not assume the equalities hold
 until a concrete witness of inequality is discovered? A good dependently
 typed programming language should
\end_layout

\begin_layout Itemize
Provisionally allow obvious like 
\begin_inset Formula $1_{c}+_{c}x\,=\,x+_{c}1_{c}$
\end_inset

 so programming is not blocked.
\end_layout

\begin_layout Itemize
Give static warnings about potential type inequalities; users can decide
 if they are worth verifying.
 
\end_layout

\begin_layout Itemize
Give runtime errors, with a concrete witness of inequality, if one of the
 provisional equalities is shown not to hold in practice.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% example of solution
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

For instance, if the 
\begin_inset Formula $+_{c}$
\end_inset

 incorrectly computes 
\begin_inset Formula $8_{c}+_{c}1_{c}=0_{c}$
\end_inset

 the above function will 
\begin_inset Quotes eld
\end_inset

get stuck
\begin_inset Quotes erd
\end_inset

 on the input 
\begin_inset Formula $8_{c}$
\end_inset

.
 If that application is encountered at runtime we can give an error stating
 
\begin_inset Formula $9_{c}\,\neq\,0_{c}=8_{c}+_{c}1_{c}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% more about equality
\end_layout

\end_inset

Difficulties in dependently typed equality have motivated many research
 projects 
\begin_inset CommandInset citation
LatexCommand cite
key "HoTTbook,sjoberg2015programming,cockx2021taming"
literal "false"

\end_inset

.
 However, these impressive efforts are still only usable by experts.
 Further, since program equivalence is undecidable in general, no system
 will be able to statically verify every 
\begin_inset Quotes eld
\end_inset

obvious
\begin_inset Quotes erd
\end_inset

 equality for arbitrary user defined data types and functions.
 The conventional work is important, but it is not yet usable, in te meatime
 systems should trust the programmer when they use an unverified equality.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% why is the solution good, for users
\end_layout

\end_inset

Wherever possible, errors should be turned into warnings.
 If a meaningful problem occurs at runtime a clear error message that pinpoints
 the exact source of errors should be provided.
 This way runtime errors and static warnings both inform the programmer.
 Since the user can gradually correct their program as errors surface, we
 call this workflow 
\series bold
gradual correctness
\series default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% why is the solution non-trivial
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Though gradual correctness is an apparently simple idea, there are several
 subtle issues that must be dealt with.
 
\end_layout

\begin_layout Itemize
While it is easy to test when natural numbers are equal at runtime, testing
 that 2 functions are equal is impossible in general.
 
\end_layout

\begin_layout Itemize
Erasing too much type information will make good runtime error messages
 impossible.
 
\end_layout

\begin_layout Itemize
If equality checks are embedded into syntax, they may propagate into the
 type level.
 
\end_layout

\begin_layout Standard
We are unaware of research that directly handles all of these concerns.
 
\end_layout

\begin_layout Standard
If we want the above, we cannot work in the surface language directly.
 Our system needs
\end_layout

\begin_layout Itemize
The cast language, a dependently typed language with embedded runtime checks,
 that will be evaluated.
 
\end_layout

\begin_layout Itemize
An elaboration procedure that transforms untyped surface syntax into checked
 cast language terms.
 
\end_layout

\begin_layout Standard
We show that a novel form of type soundness holds.
 Instead of 
\begin_inset Quotes eld
\end_inset

well typed terms don't get stuck
\begin_inset Quotes erd
\end_inset

, we prove 
\begin_inset Quotes eld
\end_inset

well cast terms don't get stuck without blame
\begin_inset Quotes erd
\end_inset

.
 We call this 
\series bold
cast soundness
\series default
.
\end_layout

\begin_layout Standard
Additionally, by construction, blame (in the sense of gradual typing) is
 reasonably handled.
 Several graduality properties hold for the system overall.
\end_layout

\begin_layout Part
Cast Language
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
The cast language records all the potential type conflicts, and uses runtime
 annotations to monitor these disdrepencies.
 If the types do not conflict at runtime, evaluation will continue, otherwise
 the system will correctly blame the source location of the conflict.
 Terms that type according to the cast language type system as well-casts.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% TODO why?
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="none" valignment="top" usebox="none" special="l">
\begin_inset Text

\begin_layout Plain Layout
location information,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ensuremath{\ell}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $.$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no source label
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable contexts,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lozenge$
\end_inset

 | 
\begin_inset Formula $H,x:A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="none" valignment="top" usebox="none" special="l">
\begin_inset Text

\begin_layout Plain Layout
expressions,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a,b$
\end_inset

,
\begin_inset Formula $A,B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::_{A,\ensuremath{\ell},o}B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:A\right)\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow b$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b\,a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="none" valignment="top" usebox="none" special="l">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.arg$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function type-arg
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.bod[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function type-body
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% time permitting factor the location to where .
 is
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Syntax
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-pre-syntax"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% pre-syntax
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The syntax for the cast language can be seen in figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-pre-syntax"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Every time there is a type mismatch between the type of the term and the
 type expected from the usage, a cast is elaborated with 
\end_layout

\begin_layout Itemize
a source location 
\begin_inset Formula $\ell$
\end_inset

 where it was asserted, 
\end_layout

\begin_layout Itemize
a concrete observation 
\begin_inset Formula $o$
\end_inset

 that would witness inequality, 
\end_layout

\begin_layout Itemize
the type of the underlieing term, 
\end_layout

\begin_layout Itemize
and the expected type of the term.
 
\end_layout

\begin_layout Section
Examples
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO: May need evaluation rules
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pretending 
\begin_inset Formula $\star=_{\star}\perp$
\end_inset


\end_layout

\begin_layout Standard
spoofing an equality
\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\lambda pr:\left(\star=_{\star}\perp\right).pr\,\left(\lambda x.x\right)\,\perp\qquad:\lnot\star=_{\star}\perp\right)refl_{\star:\star}$
\end_inset


\end_layout

\begin_layout Standard
elaborates to
\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\lambda pr:\left(\star=_{\star}\perp\right).pr\,\left(\lambda x.x\right)\,\perp\qquad:\lnot\star=_{\star}\perp\right)\left(refl_{\star:\star}::\left(\star=_{\star}\star\right)=_{l}\left(\star=_{\star}\perp\right)\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $refl_{\star:\star}::\left(\star=_{\star}\star\right)=_{l}\left(\star=_{\star}\perp\right)\,\left(\lambda x.x\right)\,\perp\qquad:\perp$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\lambda C:\left(\star\rightarrow\star\right).\lambda x:C\,\star.x::\left(\varPi C:\left(\star\rightarrow\star\right).C\,\star\rightarrow C\,\star\right)=_{l}\left(\varPi C:\left(\star\rightarrow\star\right).C\,\star\rightarrow C\,\perp\right)\right)\,\left(\lambda x.x\right)\,\perp\qquad:\perp$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\lambda x:\star.x::\left(\star\rightarrow\star\right)=_{l,bod}\left(\star\rightarrow\perp\right)\right)\,\perp\qquad:\perp$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\perp::\star=_{l,bod.bod}\perp\right)\qquad:\perp$
\end_inset


\end_layout

\begin_layout Standard
note that the program has not yet 
\begin_inset Quotes eld
\end_inset

gotten stuck
\begin_inset Quotes erd
\end_inset

.
 to exercise this error, 
\begin_inset Formula $\perp$
\end_inset

 must be eliminated, this can be done by tying to summon another type by
 applying it to 
\begin_inset Formula $\perp$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\left(\perp::\star=_{l,bod.bod}\perp\right)\qquad:\perp\right)\,\star$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\left(\varPi x:\star.x\right)::\star=_{l,bod.bod}\left(\varPi x:\star.x\right)\right)\,\star$
\end_inset


\end_layout

\begin_layout Standard
the computation is stuck, and the original application can be blamed on
 account that the 
\begin_inset Quotes eld
\end_inset

proof
\begin_inset Quotes erd
\end_inset

 has a discoverable type error at the point of application 
\begin_inset Formula $l$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\varPi C:\left(\star\rightarrow\star\right).C\,\star\rightarrow\underline{C\,\star}\neq\varPi C:\left(\star\rightarrow\star\right).C\,\star\rightarrow\underline{C\,\perp}$
\end_inset


\end_layout

\begin_layout Standard
when 
\end_layout

\begin_layout Standard
\begin_inset Formula $C\coloneqq\lambda x.x$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C\,\perp=\perp\neq\star=C\,\star$
\end_inset


\end_layout

\begin_layout Subsection
Pretending 
\begin_inset Formula $true_{c}=_{\mathbb{B}_{c}}false_{c}$
\end_inset


\end_layout

\begin_layout Standard
spoofing an equality, evaluating 
\begin_inset Formula $\lnot true_{c}=_{\mathbb{B}_{c}}false_{c}$
\end_inset

 with an incorrect proof.
\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\lambda pr:\left(\varPi C:\left(\mathbb{B}_{c}\rightarrow\star\right).C\,true_{c}\rightarrow C\,false_{c}\right).pr\,\left(\lambda b:\mathbb{B}_{c}.b\,\star\,\star\,\perp\right)\,\perp\qquad:\lnot true_{c}=_{\mathbb{B}_{c}}false_{c}\right)refl_{true_{c}:\mathbb{B}_{c}}$
\end_inset


\end_layout

\begin_layout Standard
is elaborated to
\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\lambda pr:\left(\varPi C:\left(\mathbb{B}_{c}\rightarrow\star\right).C\,true_{c}\rightarrow C\,false_{c}\right).pr\,\left(\lambda b:\mathbb{B}_{c}.b\,\star\,\star\,\perp\right)\,\perp\qquad:\lnot true_{c}=_{\mathbb{B}_{c}}false_{c}\right)\left(refl_{true_{c}:\mathbb{B}_{c}}::true_{c}=_{\mathbb{B}_{c}}true_{c}=_{l}true_{c}=_{\mathbb{B}_{c}}false_{c}\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(refl_{true_{c}:\mathbb{B}_{c}}::true_{c}=_{\mathbb{B}_{c}}true_{c}=_{l}true_{c}=_{\mathbb{B}_{c}}false_{c}\right)\,\left(\lambda b:\mathbb{B}_{c}.b\,\star\,\star\,\perp\right)\,\perp$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\left(\lambda C:\left(\mathbb{B}_{c}\rightarrow\star\right).\lambda x:C\,true_{c}.x\right)::\varPi C:\left(\mathbb{B}_{c}\rightarrow\star\right).C\,true_{c}\rightarrow C\,true_{c}=_{l}\varPi C:\left(\mathbb{B}_{c}\rightarrow\star\right).C\,true_{c}\rightarrow C\,false_{c}\right)\,\left(\lambda b:\mathbb{B}_{c}.b\,\star\,\star\,\perp\right)\,\perp$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\left(.\lambda x:\star.x\right)::\star\rightarrow\star=_{l,bod}\star\rightarrow\perp\right)\,\perp$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left(\perp::\star=_{l,bod.bod}\perp\right)$
\end_inset


\end_layout

\begin_layout Standard
As in the above the example has not yet 
\begin_inset Quotes eld
\end_inset

gotten stuck
\begin_inset Quotes erd
\end_inset

.
 As above, applying 
\begin_inset Formula $\star$
\end_inset

 will discover the error, which would result in an error like 
\end_layout

\begin_layout Standard
\begin_inset Formula $\varPi C:\left(\mathbb{B}_{c}\rightarrow\star\right).C\,true_{c}\rightarrow\underline{C\,true_{c}}\neq\varPi C:\left(\mathbb{B}_{c}\rightarrow\star\right).C\,true_{c}\rightarrow\underline{C\,false_{c}}$
\end_inset


\end_layout

\begin_layout Standard
when 
\end_layout

\begin_layout Standard
\begin_inset Formula $C\coloneqq\lambda b:\mathbb{B}_{c}.b\,\star\,\star\,\perp$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C\,true_{c}=\perp\neq\star=C\,false_{c}$
\end_inset


\end_layout

\begin_layout Section
Cast Soundness
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{x:A\in H}{H\vdash x\,:\,A}\operatorname{cast-var}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash A:\star\quad H\vdash B:\star}{H\vdash a::_{A,\ensuremath{\ell},o}B\::\:B}\operatorname{cast-::}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash}{H\vdash\star:\,\star}\operatorname{cast-\star}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash A:\star\quad H,x:A\vdash B:\star}{H\vdash\left(x:A\right)\rightarrow B\,:\,\star}\operatorname{cast-fun-ty}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H,f:\left(x:A\right)\rightarrow B,x:A\vdash b:B}{H\vdash\mathsf{fun}\,f\,x\Rightarrow b\,:\,\left(x:A\right)\rightarrow B}\operatorname{cast-fun}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash b:\left(x:A\right)\rightarrow B\quad H\vdash a:A}{H\vdash b\,a\,:\,B\left[x\coloneqq a\right]}\operatorname{cast-fun-app}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash A\equiv A':\star}{H\vdash a:A'}\operatorname{cast-conv}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

TODO: remove regularity stuff
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Type Assignment Rules
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-tas-rules"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% pre-syntax
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The cast language supports its own type assignment system (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-tas-rules"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This system ensures that computations will not get stuck without enough
 information for good runtime error messages.
 Specifically computations will not get stuck without a source location
 and a witness of inequality.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\star\,\textbf{Val}}\operatorname{\star-Val}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\,}{\left(x:A\right)\rightarrow B\,\textbf{Val}}\operatorname{\Pi-Val}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\,}{\mathsf{fun}\,f\,x\Rightarrow b\:\textbf{Val}}\operatorname{\Pi-\mathsf{fun}-Val}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\begin{array}{c}
a\:\textbf{Val}\quad A\:\textbf{Val}\quad B\:\textbf{Val}\\
a\cancel{=}\star\\
a\cancel{=}\left(x:C\right)\rightarrow C'
\end{array}}{a::_{A,\ensuremath{\ell}o}B\:\textbf{Val}}\operatorname{::-Val}
\]

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Values
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-val"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike that surface language it is not longer practical to characterize
 values syntactically.
 Values are specified by judgments in (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-val"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 They are standard except for the 
\begin_inset Formula $\operatorname{::-Val}$
\end_inset

, which states that a type under a cast is not a value.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{a\,\textbf{Val}}{\left(\mathsf{fun}\,f\,x\Rightarrow b\right)a\rightsquigarrow b\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow b,x\coloneqq a\right]}
\]

\end_inset


\begin_inset Formula 
\[
\frac{b\,\textbf{Val}\quad a\,\textbf{Val}}{\begin{array}{c}
\left(b::_{\left(x:A_{1}\right)\rightarrow B_{1},\ensuremath{\ell},o}\left(x:A_{2}\right)\rightarrow B_{2}\right)a\rightsquigarrow\\
\left(b\,a::_{A_{2},\ell,o.arg}A_{1}\right)::_{B_{1}\left[x\coloneqq a::_{A_{2},\ell,o.arg}A_{1}\right],\ensuremath{\ell},o.bod[a]}B_{2}\left[x\coloneqq a\right]
\end{array}}
\]

\end_inset


\begin_inset Formula 
\[
\frac{a\,\textbf{Val}}{a::_{\star,\ensuremath{\ell},o}\star\rightsquigarrow a}
\]

\end_inset


\begin_inset Formula 
\[
\frac{a\rightsquigarrow a'}{a::_{A,\ensuremath{\ell},o}B\rightsquigarrow a'::_{A,\ensuremath{\ell},o}B}
\]

\end_inset


\begin_inset Formula 
\[
\frac{a\,\textbf{Val}\quad A\rightsquigarrow A'}{a::_{A,\ensuremath{\ell},o}B\rightsquigarrow a::_{A',\ensuremath{\ell},o}B}
\]

\end_inset


\begin_inset Formula 
\[
\frac{a\,\textbf{Val}\quad A\,\textbf{Val}\quad B\rightsquigarrow B'}{a::_{A,\ensuremath{\ell},o}B\rightsquigarrow a::_{A,\ensuremath{\ell},o}B'}
\]

\end_inset


\begin_inset Formula 
\[
\frac{b\rightsquigarrow b'}{b\,a\rightsquigarrow b'\,a}
\]

\end_inset


\begin_inset Formula 
\[
\frac{b\,\textbf{Val}\quad a\rightsquigarrow a'}{b\,a\rightsquigarrow b\,a'}
\]

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Small Step
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-step"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Small steps are listed in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-step"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 They are standard for call-by-value except that casts can distribute over
 application, and casts can reduce when both types are 
\begin_inset Formula $\star$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO: Move to exampes < ...
 change && to and, or change the example to +
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% walkthrough
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

We deal with higher order functions by distributing function casts around
 applications.
 If an application happens to a cast of function type, the argument and
 body cast is separated and the argument cast is swapped.
 For instance in 
\begin_inset Formula 
\begin{align*}
\, & \left(\left(\lambda x\Rightarrow x\&\&x\right)::_{Bool\rightarrow Bool,\ell,.}Nat\rightarrow Nat\right)7\\
\rightsquigarrow & \left(\left(\lambda x\Rightarrow x\&\&x\right)\left(7::_{Nat,\ell,.arg}Bool\right)\right)::_{Bool,\ell,.bod[7]}Nat\\
\rightsquigarrow & \left(\left(7::_{Nat,\ell,.arg}Bool\right)\&\&\left(7::_{Nat,\ell,.arg}Bool\right)\right)\\
 & ::_{Bool,\ell,.bod[7]}Nat
\end{align*}

\end_inset

if evaluation gets stuck on && and we can blame the argument of the cast
 for equating 
\begin_inset Formula $Nat$
\end_inset

 and 
\begin_inset Formula $Bool$
\end_inset

.
 This is similar to how blame parity is swapped in higher order contract
 systems 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/581478.581484"
literal "false"

\end_inset

 and gradual type systems 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-00590-9_1"
literal "false"

\end_inset

.
 The body observation records the argument the function is called with.
 For instance in the 
\begin_inset Formula $.bod[7]$
\end_inset

 observation.
 In a dependently typed function the exact argument of use may be important
 to give a good error.
 Because casts can be embedded inside of casts, types themselves need to
 normalize and casts need to simplify.
 Since our system has one universe of types, type casts only need to simplify
 themselves when a term of type 
\begin_inset Formula $\star$
\end_inset

 is cast to 
\begin_inset Formula $\star$
\end_inset

.
 For instance, 
\begin_inset Formula 
\begin{align*}
\, & \left(\left(\lambda x\Rightarrow x\right)::_{\left(Bool\rightarrow Bool\right)::_{\star,\ell,.arg}\star,\ell,.}Nat\rightarrow Nat\right)7\\
\rightsquigarrow & \left(\left(\lambda x\Rightarrow x\right)::_{Bool\rightarrow Bool}Nat\rightarrow Nat\right)7\\
\rightsquigarrow & \left(\left(\lambda x\Rightarrow x\right)\left(7::_{Nat,\ell,.arg}Bool\right)\right)::_{Bool,\ell,.bod[7]}Nat\\
\rightsquigarrow & \left(\left(7::_{Nat,\ell,.arg}Bool\right)\right)::_{Bool,\ell,.bod[7]}Nat
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO: > Move to exampes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left(a::_{\left(x:A\right)\rightarrow B,\ensuremath{\ell},o}\star\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\,}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left(a::_{\star,\ensuremath{\ell},o}\left(x:A\right)\rightarrow B\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\textbf{Blame}\:\ensuremath{\ell}\,o\,a}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left(a::_{A,\ensuremath{\ell'},o'}B\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\textbf{Blame}\:\ensuremath{\ell}\,o\,A}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left(a::_{A,\ensuremath{\ell'},o'}B\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\textbf{Blame}\:\ensuremath{\ell}\,o\,B}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left(a::_{A,\ensuremath{\ell'},o'}B\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\textbf{Blame}\:\ensuremath{\ell}\,o\,b}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left(b\,a\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\textbf{Blame}\:\ensuremath{\ell}\,o\,a}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left(b\,a\right)}
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% give these rules names
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Blame
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-blame"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% walk through blame
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

In addition to small step and values we also specify blame judgments in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-blame"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Blame tracks the information needed to create a good error message and
 is inspired by the many systems of blame tracking 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/581478.581484,10.1007/978-3-642-00590-9_1,wadler:LIPIcs:2015:5033"
literal "false"

\end_inset

.
 With only dependent functions and universes, only 
\begin_inset Formula $*\,\cancel{=}\,\rightarrow$
\end_inset

 inequalities that can be witnessed.
 The first 2 rules of the blame judgment witness these concrete type inequalitie
s, The rest of the blame rules will recursively extract concrete witnesses
 from larger terms.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% "self evidently correct" like step and val?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% cast soundness
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The cast language supports a weaker form of type soundness.
 
\end_layout

\begin_layout Standard
For any 
\begin_inset Formula $\lozenge\vdash c:C$
\end_inset

, 
\begin_inset Formula $c'$
\end_inset

, 
\begin_inset Formula $c\rightsquigarrow^{*}c'$
\end_inset

, if 
\begin_inset Formula $\textbf{Stuck}\,c'$
\end_inset

 then 
\begin_inset Formula $\textbf{Blame}\:\ensuremath{\ell}\,o\:c'$
\end_inset

, where 
\begin_inset Formula $\textbf{Stuck}\,c'$
\end_inset

 means 
\begin_inset Formula $c'$
\end_inset

 is not a value and 
\begin_inset Formula $c'$
\end_inset

 does not step.
 A well cast term (in an empty context) will never get stuck without a location
 to blame and an observation that witnesses it.
 We will refer to this property as 
\begin_inset Quotes eld
\end_inset

cast soundness
\begin_inset Quotes erd
\end_inset

, and it can be shown with a 
\begin_inset Quotes eld
\end_inset

progress and preservation
\begin_inset Quotes erd
\end_inset

-like proof.
\end_layout

\begin_layout Standard
Because of the conversion rule and non-termination, type-checking is undecidable.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO example
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prevous arguents apply.
\end_layout

\begin_layout Standard
As in the surface languages, the cast language is logically unsound.
\end_layout

\begin_layout Standard
Just as there are many different flavors of defineitional equality, there
 are also many possible choices to enforce runtime equality.
 We have outlined the minimal possible checking to support cast soundness.
 However, we suspect that more aggressive checking may be preferable in
 practice, especially in the presence of data types.
 That is why in our implementation we check equalities up to call-by-value.
\end_layout

\begin_layout Standard
Unlike static type-checking, these runtime checks have runtime costs.
 Since the language allows nontermination, checks can take forever to resolve.
 We don't expect this to be an issue in practice, since we could limit the
 number of steps allowed.
 Additionally, our implementation avoids casts when it knows that the types
 are equal.
 
\end_layout

\begin_layout Part
Elaboration
\end_layout

\begin_layout Section
Elaboration
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% overview
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Even though cast language saves us from reasoning about obvious equality,
 manually noting down every cast would be cumbersome.
 The elaboration procedure translates (untyped) terms from the surface language
 into the cast language.
 If the term is well typed in the serface langugage elaboration will produce
 a term without blameable errors.
 Terms with unproven equality in types are mapped to a cast with enough
 information to point out the original source when an inequality is witnessed.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO more examples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, 
\end_layout

\begin_layout Standard
\begin_inset Formula $\vdash(\lambda x\Rightarrow7)::_{\ell}\mathbb{B}\rightarrow\mathbb{B}$
\end_inset

 elaborates to 
\begin_inset Formula $\vdash(\lambda x\Rightarrow7::_{\mathbb{N}.\ell,.bod[x]}\mathbb{B})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f:\mathbb{B}\rightarrow\mathbb{B}\vdash f_{\ell}7\ :\mathbb{B}$
\end_inset

 elaborates to 
\begin_inset Formula $f:\mathbb{B}\rightarrow\mathbb{B}\vdash f\left(7::_{\mathbb{N}.\ell,.arg}\mathbb{B}\right)\ :\mathbb{B}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f:\mathbb{N}\rightarrow\mathbb{B}\rightarrow\mathbb{B}\vdash f_{\ell}7_{\ell'}3\ :\mathbb{B}$
\end_inset

 elaborates to 
\begin_inset Formula $f:\mathbb{N}\rightarrow\mathbb{B}\rightarrow\mathbb{B}\vdash f\left(7::_{\mathbb{N}.\ell,.arg}\mathbb{N}\right)\left(3::_{\mathbb{N}.\ell',.arg}\mathbb{B}\right)\ :\mathbb{B}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{x:A\in H}{H\vdash\textbf{Elab}\,x\,x\overrightarrow{\,:\,}A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash}{H\vdash\textbf{Elab}\,\star\,\star\overrightarrow{\,:\,}\star}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash\textbf{Elab}\ M\,A\overleftarrow{\,:_{\ell,.}\,}\star\quad H,x:A\vdash\textbf{Elab}\ N\,B\overleftarrow{\,:_{\ell',.}\,}\star}{H\vdash\textbf{Elab}\,\left(\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}\right)\ \left(\left(x:A\right)\rightarrow B\right)\overrightarrow{\,:\,}\star}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash\textbf{Elab}\ m\,b\overrightarrow{\,:\,}C\quad C\equiv\left(x:A\right)\rightarrow B\quad H\vdash\textbf{Elab}\ n\,a\overleftarrow{\,:_{\ell,.arg}\,}A}{H\vdash\textbf{Elab}\,\left(m_{\ell}\,n\right)\ \left(b\,a\right)\overrightarrow{\,:\,}B\left[x\coloneqq a\right]}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash\textbf{Elab}\ M\,A\overleftarrow{\,:_{\ell.}\,}\star\quad H\vdash\textbf{Elab}\ m\,a\overleftarrow{\,:_{\ell,.}\,}A}{H\vdash\textbf{Elab}\,\left(m::_{\ell}M\right)\ a\overrightarrow{\,:\,}A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H\vdash\textbf{Elab}\ m\,a\overrightarrow{\,:\,}A}{H\vdash\textbf{Elab}\,m\ \left(a::_{A,\ensuremath{\ell},o}A'\right)\overleftarrow{\,:_{\ell,o}\,}A'}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{H,f:\left(x:A\right)\rightarrow B,x:A\vdash\textbf{Elab}\ m\,b\overleftarrow{\,:_{\ell,o.bod[x]}\,}B}{H\vdash\textbf{Elab}\,\left(\mathsf{fun}\,f\,x\Rightarrow m\right)\ \left(\mathsf{fun}\,f\,x\Rightarrow b\right)\overleftarrow{\,:_{\ell,o}\,}\left(x:A\right)\rightarrow B}
\]

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Elaboration
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:elaboration"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% rules
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The rules for elaboration are presented in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:elaboration"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Elaboration rules are written in a style of bidirectional type checking.
 However, unlike bidirectional type checking, when inferring a check we
 add a cast assertion that the 2 types are equal.
 
\end_layout

\begin_layout Standard
There are several desirable properties of elaboration, 
\end_layout

\begin_layout Enumerate
Every term elaborated into the cast language is well-cast.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
for any 
\begin_inset Formula $\textbf{Elab}\,\Gamma\,H$
\end_inset

, then 
\begin_inset Formula $H\vdash$
\end_inset

 
\end_layout

\begin_layout Enumerate
for any 
\begin_inset Formula $H\vdash\textbf{Elab}\,a\,m\overrightarrow{\,:\,}A$
\end_inset

, then 
\begin_inset Formula $H\vdash a:A$
\end_inset

 
\end_layout

\begin_layout Enumerate
for any 
\begin_inset Formula $H\vdash\textbf{Elab}\,a\,m\overleftarrow{\,:_{\ell o}\,}A$
\end_inset

, then 
\begin_inset Formula $H\vdash a:A$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
Every term well typed in the surface language elaborates 
\end_layout

\begin_deeper
\begin_layout Enumerate
if 
\begin_inset Formula $\Gamma\vdash$
\end_inset

, then there exists H such that 
\begin_inset Formula $\textbf{Elab}\,H\,\Gamma$
\end_inset

 
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $\Gamma\vdash m\overrightarrow{\,:\,}M$
\end_inset

 then there exists 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

 such that 
\begin_inset Formula $\vdash\textbf{Elab}\ m\,a\overrightarrow{\,:\,}A$
\end_inset

 
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $\Gamma\vdash m\overleftarrow{\,:\,}M$
\end_inset

 and given 
\begin_inset Formula $\ell$
\end_inset

 then there exists 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $A$
\end_inset

, and 
\begin_inset Formula $o$
\end_inset

 such that 
\begin_inset Formula $H\vdash\textbf{Elab}\,a\,m\overleftarrow{\,:_{\ell o}\,}A$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
Blame never points to something that checked in the bidirectional system
 
\end_layout

\begin_deeper
\begin_layout Enumerate
if 
\begin_inset Formula $\vdash m\overrightarrow{\,:\,}M$
\end_inset

, and 
\begin_inset Formula $\vdash\textbf{Elab}\ m\,a\overrightarrow{\,:\,}A$
\end_inset

 , then for no 
\begin_inset Formula $a\rightsquigarrow^{*}a'$
\end_inset

 will 
\begin_inset Formula $\textbf{Blame}\:\ensuremath{\ell}\,o\:a'$
\end_inset

 occur 
\end_layout

\end_deeper
\begin_layout Enumerate
Whenever an elaborated cast term evaluates, the corresponding surface term
 evaluates consistently 
\end_layout

\begin_deeper
\begin_layout Enumerate
if 
\begin_inset Formula $H\vdash\textbf{Elab}\ m\,a\overrightarrow{\,:\,}A$
\end_inset

, and 
\begin_inset Formula $a\rightsquigarrow^{*}\star$
\end_inset

 then 
\begin_inset Formula $m\rightsquigarrow^{*}\star$
\end_inset

 
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $H\vdash\textbf{Elab}\ m\,a\overrightarrow{\,:\,}A$
\end_inset

, and 
\begin_inset Formula $a\rightsquigarrow^{*}(x:A)\rightarrow B$
\end_inset

 then there exists N and M such that 
\begin_inset Formula $m\rightsquigarrow^{*}(x:N)\rightarrow M$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|x|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\star|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m::_{\ell}M|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:|M|\right)\rightarrow|N|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m_{\ensuremath{\ell}}\,n|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|m|\,|n|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\mathsf{fun}\,f\,x\Rightarrow m|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow|m|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\lozenge|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lozenge$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\Gamma,x:A|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\Gamma|,x:|A|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|a::_{A,\ensuremath{\ell},o}B|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|a|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\left(x:A\right)\rightarrow B|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:|A|\right)\rightarrow|B|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|\mathsf{fun}\,f\,x\Rightarrow b|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow|b|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|b\,a|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|b|\,|a|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|H,x:M|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|H|,x:|M|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Erasure
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:erasure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last three guarantees are similar to the gradual guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031"
literal "false"

\end_inset

 for gradual typing.
 
\end_layout

\begin_layout Itemize
The first property follows from mutual induction on elaboration judgments.
 
\end_layout

\begin_layout Itemize
The 2nd property follows by mutual induction on the bidirectional typing
 judgments.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% TODO: review why the notes said roughly
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Property 3 follows from elaborations preserving erasure (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:erasure"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the type soundness of the surface language.
 
\end_layout

\begin_layout Itemize
Property 4 follows from elaborations preserving erasure.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% uhoh
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The elaboration relation is mostly well behaved, but as presented here,
 it is undecidable for some pathological terms.
 Because the application rule follows the bidirectional style, we may need
 to determine if a type level computation results in a function type.
 If that computation 
\begin_inset Quotes eld
\end_inset

runs forever
\begin_inset Quotes erd
\end_inset

, elaboration will 
\begin_inset Quotes eld
\end_inset

run forever
\begin_inset Quotes erd
\end_inset

.
 If we did not allow general recursion (and the non-termination allowable
 by type-in-type), we suspect elaboration would always terminate.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% tODO example
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike in gradual typing, we cannot elaborate arbitrary untyped syntax.
 The underlying type of a cast needs to be known so that a function type
 can swap its argument type at application.
 For instance, 
\begin_inset Formula $\lambda x\Rightarrow x$
\end_inset

 will not elaborate since the intended type is not known.
 Fortunately, our experimental testing suggests that a majority of randomly
 generated terms can be elaborated, while only a small minority of terms
 would type-check in the surface language.
 The programmer can make any term elaborate if they annotate the intended
 type.
 For instance, 
\begin_inset Formula $\left(\lambda x\Rightarrow x\right)::*\rightarrow*$
\end_inset

 will elaborate.
\end_layout

\begin_layout Part
Related Work
\end_layout

\begin_layout Subsection
Contract Systems, Gradual Types, and Blame
\end_layout

\begin_layout Standard
This paper has been influenced by the large amount of work done on higher
 order contracts 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/581478.581484"
literal "false"

\end_inset

, gradual types 
\begin_inset CommandInset citation
LatexCommand cite
key "siek_et_al:LIPIcs:2015:5031,10.1145/2837614.2837670"
literal "false"

\end_inset

, and especially blame 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-00590-9_1,wadler:LIPIcs:2015:5033,10.1145/3110283"
literal "false"

\end_inset

.
 Most work in those areas focuses on simply typed languages that are not
 necessarily pure.
\end_layout

\begin_layout Standard
The implementation also takes inspiration from 
\begin_inset Quotes eld
\end_inset

Abstracting gradual typing
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2837614.2837670"
literal "false"

\end_inset

, where static evidence annotations become runtime checks.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Unlike some impressive attempts to gradualize the polymorphic lambda calculus
 
\backslash
cite{10.1145/3110283}, our system does not attempt to enforce any parametric
 properties of the base language.
 %example?
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% It is unclear if such a restriction would be desirable for a dependently
 typed language in practice.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 A system for gradual dependent types has been presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3341692"
literal "false"

\end_inset

.
 That paper is largely concerned with establishing decidable type checking
 via an approximate term normalization.
 However, that system retains the definitional style of equality, so that
 it is possible, in principle, to get 
\begin_inset Formula $vec\,(1+x)\neq vec\,(x+1)$
\end_inset

 as a runtime error.
\end_layout

\begin_layout Standard
While the gradual typing goals of mixing static certainty with runtime checks
 are similar to our work here, the approach and details are different.
 Instead of trying to strengthen untyped languages by adding types, we take
 a dependent type system and allow more permissive equalities.
 This leads to different trade-offs in the design space.
 For instance, we cannot support completely unannotated code, but we do
 not need to complicate the type language with wildcards for uncertainty.
 Further we assume someone using a dependent type system feels positively
 about types in general and will not want fragments of completely typed
 code.
\end_layout

\begin_layout Subsection
Refinement Style Approaches
\end_layout

\begin_layout Standard
In this paper we have described a full-spectrum dependently typed language.
 This means computation can appear uniformly in both term and type position.
 An alternative approach to dependent types is found in refinement type
 systems.
 Refinement type systems restrict type dependency, possibly to specific
 base types such as int or bool.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% TODO code format
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 It is straightforward to check these decidable equalities at runtime in
 the 
\begin_inset Quotes eld
\end_inset

Hybrid Type Checking
\begin_inset Quotes erd
\end_inset

 methodology 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/1111037.1111059"
literal "false"

\end_inset

.
 A notable example is 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/1-4020-8141-3_34"
literal "false"

\end_inset

 which describes a refinement system that limits predicates to base types.
 A refinement type system with higher order features is gradualized in 
\begin_inset CommandInset citation
LatexCommand cite
key "c4be73a0daf74c9aa4d13483a2c4dd0e"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/thesis/bibliography/dtest"
options "alpha"

\end_inset


\end_layout

\begin_layout Part
TODO
\end_layout

\begin_layout Itemize
Salvage dictation notes?
\end_layout

\begin_layout Itemize
where shoud I talk about error msgs?
\end_layout

\begin_layout Standard
In every popular type system users are allowed to asume unsafe equalities.
 Thus 
\end_layout

\begin_layout Part
scratch
\end_layout

\begin_layout Section
error
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%% problem
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

If programmers found dependent type systems easier to learn and use, software
 could become more reliable.
 Unfortunately, dependent type systems have yet to see widespread use in
 industry.
 One source of difficulty is the conservative equality checking required
 by most dependent type systems.
 This conservative equality is a source of some of the confusing error messages
 dependent type systems are known for 
\begin_inset CommandInset citation
LatexCommand cite
key "eremondi2019framework"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
This error will help the programmer fix the bug in 
\begin_inset Formula $\mathtt{add}$
\end_inset

.
 There is evidence that specific examples like this can help clarify the
 type error messages in OCaml 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/2951913.2951915"
literal "false"

\end_inset

 and there has been an effort to make refinement type error messages more
 concrete in other systems like Liquid Haskell 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
...
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="none" valignment="top" usebox="none" special="l">
\begin_inset Text

\begin_layout Plain Layout
source labels,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ensuremath{\ell}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $.$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no source label
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="none" valignment="top" usebox="none" special="l">
\begin_inset Text

\begin_layout Plain Layout
type contexts,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lozenge$
\end_inset

 | 
\begin_inset Formula $\Gamma,x:M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="none" valignment="top" usebox="none" special="l">
\begin_inset Text

\begin_layout Plain Layout
expressions,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m,n,M,N$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m::_{\ensuremath{\ell}}M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
annotation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type universe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow m$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m_{\ensuremath{\ell}}\,n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Syntax
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-pre-syntax"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
CAST LANGUAGE
\end_layout

\begin_layout Standard
CAST LANGUGAE EXMAPLES
\end_layout

\begin_layout Standard
CAST SOUNDNESS
\end_layout

\begin_layout Standard
ELABORATION
\end_layout

\begin_layout Standard
GRADUAL CORECTNESS
\end_layout

\begin_layout Standard
EXTEND THE SURFACE SYNTAX WITH LOCATIONS
\end_layout

\begin_layout Standard
ELABORATION SYSTEM
\end_layout

\begin_layout Standard
S
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:M\right)\rightarrow N$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $M\rightarrow N$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x\notin fv\left(N\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow m$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda x\Rightarrow m$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $f\notin fv\left(m\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $...\,x\Rightarrow\lambda y\Rightarrow m$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $...\,x\,y\Rightarrow m$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $-$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x\notin fv\left(m\right)$
\end_inset

 when 
\begin_inset Formula $x$
\end_inset

 binds 
\begin_inset Formula $m$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m::_{\ensuremath{\ell}}M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m::M$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ensuremath{\ell}$
\end_inset

 is irrelevant
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:M_{\ensuremath{\ell}}\right)\rightarrow N_{\ensuremath{\ell'}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:M\right)\rightarrow N$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ensuremath{\ell}$
\end_inset

, 
\begin_inset Formula $\ensuremath{\ell}'$
\end_inset

 are irrelevant
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m_{\ensuremath{\ell}}\,n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m_{\ensuremath{}}\,n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ensuremath{\ell}$
\end_inset

 is irrelevant
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
where 
\begin_inset Formula $fv$
\end_inset

 is a function that returns the set of free variables in an expression
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Abbreviations
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-pre-syntax-abrev"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
A similar 
\begin_inset Quotes eld
\end_inset

partial correctness
\begin_inset Quotes erd
\end_inset

 criterion for dependent languages with non-termination run with Call-by-Value
 is presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "jia2010dependent"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO:  revise above
\end_layout

\end_inset


\end_layout

\end_body
\end_document
