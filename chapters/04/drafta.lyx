#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xcolor}
\usepackage{tikz-cd}
\tikzcdset{%
    triple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure' 
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    quadruple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure'
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    Rrightarrow/.code={\tikzcdset{triple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}},
    RRightarrow/.code={\tikzcdset{quadruple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}}
}    
\newcommand*{\tarrow}[2][]{\arrow[Rrightarrow, #1]{#2}\arrow[dash, shorten >= 0.5pt, #1]{#2}}
\newcommand*{\qarrow}[2][]{\arrow[RRightarrow, #1]{#2}\arrow[equal, double distance = 0.25pt, shorten >= 1.28pt, #1]{#2}}
\end_preamble
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Chapter 4 (draft): Data and Pattern Matching in the Surface Language
\end_layout

\begin_layout Author
Mark Lemay
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

not handle data types in a rigorous way.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Standard
User defined data is an important part of a realistic programming language.
 Programmers need to be able to define concrete types that are meaningful
 for the the problems they are trying to solve.
\end_layout

\begin_layout Standard
Dependent data types allow these user defined types, while also unifying
 over many types that are handled as special cases in most mainstream languages.
 For instance, 
\begin_inset Quotes eld
\end_inset

primitive
\begin_inset Quotes erd
\end_inset

 data types like 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

 and 
\begin_inset Formula $\mathtt{Bool}$
\end_inset

 are a degenerate forms of dependent data.
 Dependent data can represent mathematical predicates like equality or the
 evenness of a number.
 Dependent data can also be used to preserve invariants, like the length
 of a list in 
\begin_inset Formula $\mathtt{Vec}$
\end_inset

, or the 
\begin_inset Quotes eld
\end_inset

color
\begin_inset Quotes erd
\end_inset

 of a node in a red-black-tree.
\end_layout

\begin_layout Standard
The encoding scheme for data presented in Chapter 2 could handle all of
 these cases.
 However, such an encoding is inconvenient in practice.
 Since 
\begin_inset Quotes eld
\end_inset

ease of use
\begin_inset Quotes erd
\end_inset

 is the overriding concern for the system developed in this thesis, encoding
 are an unrealistic way to use data.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% However, the combination of user defined data and dependent types can
 be subtle.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this chapter we will show 2 different, closely related ways to add data
 to the surface language.
 The first which we call the direct eliminator encoding, is metatheoretically
 well behaved but cumbersome.
 The second is based on pattern matching, and is extremely useful for programmer
s, though it's meta theory is much more difficult.
 The specific form of pattern matching in this chapter is designed to allow
 syntactic sugar of function definition by cases.
 
\end_layout

\begin_layout Part
Data 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%What data defs/ constructors
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% The langugae defined in this thesus uses data definitions like those found
 in systems like Agda and Coq.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A dependent data type is defined by a type constructor indexed by arguments,
 and a set of data constructors that tag data and characterize their arguments.
 Several familiar data types are defined in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-defs"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For example, the data type 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

 is is defined with the type constructor 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

 (which has no type arguments), the data constructors 
\begin_inset Formula $\mathtt{Z}$
\end_inset

 which takes no further information and the data constructor 
\begin_inset Formula $\mathtt{S}$
\end_inset

 which is formed with the prior number.
 The data type 
\begin_inset Formula $\mathtt{Vec}$
\end_inset

 has two type arguments corresponding to the the type contained in the vector
 and its length, it has two data constructors that allow building an empty
 vector, or to add an element to the front of an existing vector.
\end_layout

\begin_layout Standard
Data defined in this style is simple to build and reason about, since data
 can only be created from its constructors.
 Unfortunately the details of data elimination are a little more involved.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

data Unit : * {
\end_layout

\begin_layout Plain Layout

| tt : Unit
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data Bool : * {
\end_layout

\begin_layout Plain Layout

| True : Bool
\end_layout

\begin_layout Plain Layout

| False : Bool
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

data Nat : * {
\end_layout

\begin_layout Plain Layout

| Z : Nat
\end_layout

\begin_layout Plain Layout

| S : Nat -> Nat
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

three : Nat;
\end_layout

\begin_layout Plain Layout

three = S (S (S Z)));
\end_layout

\begin_layout Plain Layout

-- Syntactic sugar allows 3 = S (S (S Z)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data Vec : (A : *) -> Nat -> * {
\end_layout

\begin_layout Plain Layout

| Nil  : (A : *) -> Vec A Z
\end_layout

\begin_layout Plain Layout

| Cons : (A : *) -> A -> (x : Nat)
\end_layout

\begin_layout Plain Layout

        -> Vec A x -> Vec A (S x)
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

someBools : Vec Bool 2;
\end_layout

\begin_layout Plain Layout

someBools = Cons Bool True 1 (Cons Bool False 0 (Nil Bool));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data Id : (A : *) -> A -> A -> * {
\end_layout

\begin_layout Plain Layout

| refl  : (A : *) -> (a : A) -> Id A a a
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

threeEqThree : Id Nat three three;
\end_layout

\begin_layout Plain Layout

threeEqThree = refl Nat three;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% include if notation is used
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% -- Syntactic sugar expands list notation,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% -- for example
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% -- [True, False]<Bool> =
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% -- Cons Bool True 1 (Cons Bool False 1 (Nil Bool))
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Definitions of Common Data Types
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:data-defs"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Direct Elimination
\end_layout

\begin_layout Standard
How should a program observe data? Since the term of a given data type can
 only be created with one of the constructors from its definition, we can
 completely handle a data expression if each possible constructor is accounted
 for.
 For instance, 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

 has the two constructors 
\begin_inset Formula $\mathtt{Z}$
\end_inset

 and 
\begin_inset Formula $\mathtt{S}$
\end_inset

 (which holds the preceding number), so the expression 
\begin_inset Formula $\mathsf{case}\,n\,\left\{ |\,Z\Rightarrow Z\,|\,S\,x\Rightarrow x\right\} $
\end_inset

 will extract the proceeding number from 
\begin_inset Formula $n$
\end_inset

(or 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $n=0$
\end_inset

).
 In this light, boolean case elimination corresponds to the if-then-else
 expression found in many mainstream languages.
 
\end_layout

\begin_layout Standard
We will need to extend the syntax of 
\begin_inset Formula $\mathsf{case}$
\end_inset

s to support dependent type checking.
 Specifically, we will need to add a 
\series bold
motive
\series default
 annotation that allows the type checker to compute the output type of the
 branches if they vary in terms of the input.
 For instance, recursively generating a vector of a given length
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
give explicit example, note the motive
\end_layout

\end_inset

.
 We may also want to use some values of the type level argument to calculate
 the motive, and type the branches.
 This will be allowed with additional bindings in the motive and in each
 branch
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
give explicit of data eliminations that uses these annotations
\end_layout

\end_inset

.
 In general, motive annotations will be treated like the typing annotations
 in Chapter 2, in that the TAS will only allow correct motives in a well
 typed term, and that the motive will be definitionally irrelevant.
\end_layout

\begin_layout Standard
This version of data can be given by extending the surface language syntax
 in Chapter 2, as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-defs"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This direct eliminator scheme, is roughly similar to how Coq handles data
 in it's core language.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="21" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
list of 
\begin_inset Formula $O$
\end_inset

, separated with 
\begin_inset Formula $s$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{sO}$
\end_inset

,
\begin_inset Formula $\overline{Os}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $.$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
empty list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $sO\overline{sO}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extend list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Delta,\varTheta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\overline{\left(x:M\right)\rightarrow}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
telescope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data type identifier,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data constructor identifier,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
contexts,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma,\mathsf{data}\,D\,:\,\Delta\rightarrow\star\,\left\{ \overline{|\,d\,:\,\varTheta\rightarrow D\overline{m}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data def extension
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma,\mathsf{data}\,D\,:\,\Delta\rightarrow\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
abstract data extension
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m,n,M,N$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{N,}n\,\left\{ \overline{|\overline{x\Rightarrow}(d\,\overline{y})\Rightarrow m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 without motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{N,}n\,\left\langle \overline{x\Rightarrow}\,y:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\overline{x\Rightarrow}(d\,\overline{y})\Rightarrow m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 with motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D\,\overline{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d\,\overline{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language (Direct Eliminator) Data
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-min"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
syntax
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
for example
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
is written
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
leading separator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $sO\overline{sO}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\overline{sO}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
clear from context
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $,1,2,3$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1,2,3$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
trailing separator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{sO}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{sO}s$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
clarifies intent
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x\rightarrow y\rightarrow z\right)Id\,x\,y\,z$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x\rightarrow y\rightarrow z\rightarrow Id\,x\,y\,z$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
non dependent telescope binder
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:M\right)\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $M\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

is not intended to bind 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:Nat\right)\rightarrow\left(y:IsEven\,x\right)\rightarrow Nat$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:Nat\right)\rightarrow IsEven\,x\rightarrow Nat$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
repeated application
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m\,n_{0}\,n_{1}\,...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m\,\overline{n}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\overline{n}=n_{0}\,n_{1}\,...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
review if there are more abbreviations around?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Abbreviations
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-pre-syntax-abrev"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
motive should not need to insist on the type info of the binder? grey out?Grey
 out things that are surface syntax but not needed for theory?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The case eliminator first takes the explicit type arguments, followed by
 a 
\series bold
scrutinee
\begin_inset Foot
status open

\begin_layout Plain Layout
also called a 
\series bold
discriminee
\end_layout

\end_inset


\series default
 of correct type.
 Then optionally a motive that characterizes the output type of each branch
 with all the type arguments and scrutinee abstracted and in scope.
 For instance, this case expression checks if a vector 
\begin_inset Formula $x$
\end_inset

 is empty,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x:Vec\,\mathbb{B}\,1\vdash\mathsf{case}\,\mathbb{B},1,x\,\left\langle y\Rightarrow z\Rightarrow s:Vec\,y\,z\Rightarrow\mathbb{B}\right\rangle \left\{ |y\Rightarrow z\Rightarrow Nil\,-\Rightarrow True\,|\,y\Rightarrow z\Rightarrow Cons\,----\Rightarrow False\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
We include a little more syntax then is strictly necessary, since the 
\begin_inset Formula $\mathbb{B},1,$
\end_inset

 list could be inferred and the 
\begin_inset Formula $y\Rightarrow z\Rightarrow$
\end_inset

 binders are not needed in the branch.
 This slightly verbose case eliminator syntax is designed to be forward
 compatible with the pattern matching system defined in the rest of this
 chapter.
 
\end_layout

\begin_layout Standard
Additionally we define telescopes, which generalize zero or more typed bindings
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
Cite De Bruijn for telescopes
\end_layout

\end_inset

.
 This allows a much cleaner definition of data then is otherwise possible.
 Also we define syntactic lists that allow zero or more pieces of syntax.
 Expressions in a list can be used to generalize dependent pairs, and can
 be type checked against a telescope.
 For instance, the list 
\begin_inset Formula $\mathtt{Nat},2,2,refl\,\mathtt{Nat}\,2$
\end_inset

 type checks against 
\begin_inset Formula $\left(x:\star\right)\rightarrow\left(y:\mathtt{Nat}\right)\rightarrow\left(z:\mathtt{Nat}\right)\rightarrow\left(-:Id\ x\,y\,z\right)$
\end_inset

.
 This becomes helpful in several situations, but especially when we need
 work with the listed arguments of the data type constructor.
 We will allow several syntactic puns, such as treating telescopes as prefixes
 for function types.
 For instance, if 
\begin_inset Formula $\Delta=\left(x:\star\right)\rightarrow\left(y:\mathtt{Nat}\right)\rightarrow\left(z:\mathtt{Nat}\right)\rightarrow\left(-:Id\ x\,y\,z\right)$
\end_inset

 then writing 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $f:\Delta\rightarrow\mathtt{Nat}$
\end_inset

 will be short hand for 
\begin_inset Formula $f:\left(x:\star\right)\rightarrow\left(y:\mathtt{Nat}\right)\rightarrow\left(z:\mathtt{Nat}\right)\rightarrow Id\ x\,y\,z\rightarrow\mathtt{Nat}$
\end_inset

.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
move this down to the typing section?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the presence of general recursion case elimination is powerful.
 Well-founded recursion can be used to make structurally inductive computations
 that can be interpreted as proofs.
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
say with rep example
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Adding data allows for two additional sources of bad behavior.
 Incomplete matches, and nontermination from non-strictly positive data.
 
\end_layout

\begin_layout Section
Incomplete Eliminations
\end_layout

\begin_layout Standard
Consider the match 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x:\mathbb{N}\vdash\mathsf{case}\,x\,\left\langle s:\mathbb{N}\Rightarrow\mathbb{B}\right\rangle \left\{ |S-\Rightarrow True\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
This match will 
\begin_inset Quotes eld
\end_inset

get stuck
\begin_inset Quotes erd
\end_inset

 if 
\begin_inset Formula $0$
\end_inset

 is substituted for 
\begin_inset Formula $x$
\end_inset

.
 Recall that the key theorem of the surface language is type soundness,
 
\begin_inset Quotes eld
\end_inset

well typed terms don't get stuck
\begin_inset Quotes erd
\end_inset

.
 Since verifying every constructor has a branch is relatively easy, the
 surface language TAS will require every constructor to be matched in order
 to type check type check with direct elimination.
 This is in contrast to most programming languages, which do allow incomplete
 patterns, though usually a warning is given, and a runtime error is raised
 if the scrutinee cannot be matched.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Since this is a 
\begin_inset Quotes eld
\end_inset

well behaved
\begin_inset Quotes erd
\end_inset

 failure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This thesis already has a system for handling warnings and runtime errors
 through the cast language.
 When we get to the cast language, we will allow non-exhaustive data to
 be reported as a warning and that will allow 
\begin_inset Quotes eld
\end_inset

unmatched
\begin_inset Quotes erd
\end_inset

 errors to be observed at runtime.
\end_layout

\begin_layout Standard
For similar reasons we will insist that each constructor is matched at most
 once, so there is no ambiguity for how an case eliminated when using direct
 eliminations.
\end_layout

\begin_layout Section
(non) Strict Positivity
\end_layout

\begin_layout Standard
A more subtle concern is posed by data definitions that are not strictly
 positive.
 Consider the following definition,
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

data Bad : * {
\end_layout

\begin_layout Plain Layout

| C : (Bad -> Bad) -> Bad
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

selfApply : Bad -> Bad;
\end_layout

\begin_layout Plain Layout

selfApply = 
\backslash
 b =>
\end_layout

\begin_layout Plain Layout

  case b {
\end_layout

\begin_layout Plain Layout

    | C f => f b
\end_layout

\begin_layout Plain Layout

  };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

loop : Bad;
\end_layout

\begin_layout Plain Layout

loop = selfApply (C selfApply)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\mathtt{C}$
\end_inset

 constructor in the definitions of 
\begin_inset Formula $\mathtt{Bad}$
\end_inset

 has a self reference in a negative position, 
\begin_inset Formula $(\mathtt{Bad}\rightarrow\underline{\mathtt{Bad}})\rightarrow\mathtt{Bad}$
\end_inset

.
 
\end_layout

\begin_layout Standard
non strictly positive data data definitions can cause non-termination, independe
nt of the two other sources of non-termination already considered (general
 recursion and type-in-type).
 Dependent type systems usually require a strictness check on data definitions
 to avoid this possibility.
 However, this would disallow some useful constructions like higher order
 abstract syntax.
 Since non-termination is already allowed in the surface TAS, we will not
 restrict the surface language to strictly positive date.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
who cam up with this first? Martin Lof?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% co-inductive uses of data
\end_layout

\end_inset


\end_layout

\begin_layout Section
Typing
\end_layout

\begin_layout Standard
Before the typing rules for data can be considered, first some meta rules
 must be presented that will allow the simultaneous type-checking of lists
 and telescopes.
 These rules are listed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-meta-ty"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and are standard.
 Telescopes are 
\begin_inset Formula $\mathbf{ok}$
\end_inset

 when they extend the context in an 
\begin_inset Formula $\mathbf{ok}$
\end_inset

 way.
 Lists of expressions can be said to have the type of the telescope if every
 expression in the list types successively.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}}{\Gamma\vdash.\,\mathbf{ok}}\operatorname{\mathbf{ok}-Tel-empty}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\vdash M:\star\quad\Gamma,x:M\vdash\Delta\,\mathbf{ok}}{\Gamma\vdash\left(x:M\right)\rightarrow\Delta\,\mathbf{ok}}\operatorname{\mathbf{ok}-Tel-ext}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}}{\Gamma\vdash,:.}\operatorname{ty-ls-empty}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma,x:M\vdash\Delta\quad\Gamma\vdash m:M\quad\Gamma\vdash\overline{n,}\left[x\coloneqq m\right]:\Delta\left[x\coloneqq m\right]}{\Gamma\vdash m\overline{,n}\,:\,\left(x:M\right)\rightarrow\Delta}\operatorname{ty-ls-ext}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Meta rules
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-meta-ty"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Data definitions can be added to contexts if all of their constituents are
 well typed and 
\series bold
ok
\series default
.
 The rules are listed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-ok"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The 
\begin_inset Formula $\operatorname{\mathbf{ok}-abs-data}$
\end_inset

 rule allows data to be considered abstractly if it is formed with a plausible
 telescope.
 
\begin_inset Formula $\operatorname{\mathbf{ok}-data}$
\end_inset

 checks a full data definition with an abstract reference to a data definition
 in context, which allows recursive data definitions such as 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

 which needs 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

 to be in scope to define the 
\begin_inset Formula $\mathtt{S}$
\end_inset

 constructor.
 This thesis does not formalize a syntax that adds data to context, though
 a very module system has been implemented in the prototype.
 It is taken for granted that any well formed data in context is fine.
 This presentation of data definitions largely follows 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\vdash\Delta\,\mathbf{ok}}{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\mathbf{ok}}\operatorname{\mathbf{ok}-abs-data}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\mathbf{ok}}{\Gamma,\mathsf{data}\,D\,\Delta\,\mathbf{ok}}\operatorname{\mathbf{ok}-data-ext}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\mathbf{ok}\quad\forall d.\Gamma,\mathsf{data}\,D\,\Delta\vdash\varTheta_{d}\,\mathbf{ok}\quad\forall d.\:\Gamma,\mathsf{data}\,D\,\Delta,\varTheta_{d}\vdash\overline{m}_{d}:\Delta}{\Gamma\vdash\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta_{d}\rightarrow D\overline{m}_{d}}\right\} \,\mathbf{ok}}\operatorname{\mathbf{ok}-data}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta\rightarrow D\overline{m}}\right\} \,\mathbf{ok}}{\Gamma,\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta\rightarrow D\overline{m}}\right\} \,\mathbf{ok}}\operatorname{\mathbf{ok}-data-ext}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Data ok
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-ok"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The type assignment system with direct elimination must be extended with
 the rules in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-ty"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These rules make use of several convenient shorthands: 
\begin_inset Formula $\mathsf{data}\,D\,\Delta\in\Gamma$
\end_inset

 and 
\begin_inset Formula $d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma$
\end_inset

 extract the type constructor definitions and data constructor definitions
 from the context respectively.
 
\begin_inset Formula $\operatorname{ty-TCon}$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\operatorname{ty-Con}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 allow type and data constructors to be used as functions of appropriate
 type.
 The 
\begin_inset Formula $\operatorname{ty-}\mathsf{case}<>$
\end_inset

 rule types a case expression by ensuring that the correct data definition
 for 
\begin_inset Formula $D$
\end_inset

 is in context, the scrutinee 
\begin_inset Formula $n$
\end_inset

 has the correct type, the motive 
\begin_inset Formula $M$
\end_inset

 is well formed under the type arguments and the scrutinee, 
\begin_inset ERT
status open

\begin_layout Plain Layout

% The motive requires checking in the case of empty data
\end_layout

\end_inset

 finally every data constructor is verified to have a corresponding branch.
 
\begin_inset Formula $\operatorname{ty-}\mathsf{case}$
\end_inset

 allows for the same typing logic, but does not require the motive be annotated
 in syntax.
 In both rules we allow telescopes to rename their variables with the shorthand
 
\begin_inset Formula $\overline{x}:\Delta$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\,:\,\Delta\rightarrow\star}\operatorname{ty-TCon}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma}{\Gamma\vdash d\,:\,\varTheta\rightarrow D\overline{m}}\operatorname{ty-Con}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\left\{ ...\right\} \in\Gamma\\
\Gamma\vdash n:D\overline{N}\\
\Gamma,\overline{x}:\Delta,z:D\,\overline{x}\vdash M:\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{o}\in\Gamma.\quad\Gamma,\overline{y}_{d}:\varTheta\vdash m_{d}\left[\overline{x}\coloneqq\overline{o}\left[\varTheta\coloneqq\overline{y}_{d}\right]\right]:M\left[\overline{x}\coloneqq\overline{o}\left[\varTheta\coloneqq\overline{y}_{d}\right],z\coloneqq d\,\overline{y}_{d}\right]\\
\mathrm{No\ duplicate\ branches}
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{N,}n\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{x\Rightarrow}\,d\overline{y}_{d}\,\Rightarrow m_{d}}\right\} \\
:M\left[\overline{x}\coloneqq\overline{N},z\coloneqq n\right]
\end{array}}\operatorname{ty-}\mathsf{case}<>
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\left\{ ...\right\} \in\Gamma\\
\Gamma\vdash n:D\overline{N}\\
\Gamma,\overline{x}:\Delta,z:D\,\overline{x}\vdash M:\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{o}\in\Gamma.\quad\Gamma,\overline{y}_{d}:\varTheta\vdash m_{d}\left[\overline{x}\coloneqq\overline{o}\left[\varTheta\coloneqq\overline{y}_{d}\right]\right]:M\left[\overline{x}\coloneqq\overline{o}\left[\varTheta\coloneqq\overline{y}_{d}\right],z\coloneqq d\,\overline{y}_{d}\right]
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{N,}n\,\left\{ \overline{|\,\overline{x\Rightarrow}\,d\overline{y}_{d}\,\Rightarrow m_{d}}\right\} \\
:M\left[\overline{x}\coloneqq\overline{N},z\coloneqq n\right]
\end{array}}\operatorname{ty-}\mathsf{case}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Data Typing
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-ty"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
suspect this also hinges on regularity, which should be addressed more directly
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Extensions to the parallel reduction rules are listed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-red"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 They follow the scheme of parallel reductions laid out in chapter 2.
 The 
\begin_inset Formula $\textrm{\Rrightarrow-\mathsf{case}-red}$
\end_inset

 rule
\begin_inset Foot
status open

\begin_layout Plain Layout
Also called 
\begin_inset Formula $\iota$
\end_inset

, or Iota reduction
\end_layout

\end_inset

 reduces a case expression by choosing the appropriate branch.
 The 
\begin_inset Formula $\textrm{\Rrightarrow-\mathsf{case}<>-red}$
\end_inset

 rule removes the motive annotation, much like the annotation rule in Chapter
 2.
 The rules 
\begin_inset Formula $\textrm{\Rrightarrow-\mathsf{case}<>}$
\end_inset

, 
\begin_inset Formula $\textrm{\Rrightarrow-}D$
\end_inset

, and 
\begin_inset Formula $\textrm{\Rrightarrow-}d$
\end_inset

 keep the 
\begin_inset Formula $\Rrightarrow$
\end_inset

 relation reflexive.
 The reduction relation must be generalized to lists in the expected way.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad\overline{m}\Rrightarrow\overline{m'}\\
\exists\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \\
m_{d}\Rrightarrow m_{d}'
\end{array}}{\mathsf{case}\,\overline{N,}\,d\overline{m}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow m_{d}\left[\overline{x}\coloneqq\overline{N'},\overline{y}_{d}\coloneqq\overline{m'}\right]}\,\textrm{\Rrightarrow-\mathsf{case}-red}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad m\Rrightarrow m'\\
\forall\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} .\:m_{d}\Rrightarrow m_{d}'
\end{array}}{\mathsf{case}\,\overline{N,}\,m\,\left\langle ...\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow\mathsf{case}\,\overline{N',}\,m'\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}'}\right\} }\,\textrm{\Rrightarrow-\mathsf{case}<>-red}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad m\Rrightarrow m'\\
M\Rrightarrow M'\\
\forall\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}\in\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} .\:m_{d'}\Rrightarrow m'_{d'}
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{N,}\,m\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} \Rrightarrow\\
\mathsf{case}\,\overline{N,}\,m'\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M'\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d\,\overline{y}_{d})\Rightarrow m'_{d}}\right\} 
\end{array}}\,\textrm{\Rrightarrow-\mathsf{case}<>}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{D\Rrightarrow D}\,\textrm{\Rrightarrow-}D
\]

\end_inset


\begin_inset Formula 
\[
\frac{\,}{d\Rrightarrow d}\,\textrm{\Rrightarrow-}d
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Data Reduction
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-red"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are now in a position to select a sub relation of 
\begin_inset Formula $\Rrightarrow$
\end_inset

 reductions that will be used to characterize call-by-value evaluation.
 This relation could be used used to prove type safety, and is close to
 the reduction used in the implementation.
 The rules are listed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-cbv"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
extend cbv over lists
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\mathsf{case}\,\overline{N,}\,n\,\left\langle ...\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow\mathsf{case}\,\overline{N,}\,n\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }\textrm{\rightsquigarrow-\mathsf{case}<>}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\exists\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }{\mathsf{case}\,\overline{V,}\,d\overline{v}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow m_{d}\left[\overline{x}\coloneqq\overline{V},\overline{y}_{d}\coloneqq\overline{v}\right]}\,\textrm{\rightsquigarrow-\mathsf{case}-red}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{N}\rightsquigarrow\overline{N'}}{\mathsf{case}\,\overline{N,}\,n\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow\mathsf{case}\,\overline{N',}\,n\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }\,
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{n\rightsquigarrow n'}{\mathsf{case}\,\overline{V,}\,n\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow\mathsf{case}\,\overline{V,}\,n'\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }\,
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Data CBV
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-cbv"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
extend step over lists
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally we characterize what it means for a context to be empty in the presence
 of data in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-empty"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{\lozenge\,\mathbf{Empty}}\operatorname{Empty-ctx}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{Empty}\quad\Gamma\vdash\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta_{d}\rightarrow D\overline{m}_{d}}\right\} \,\mathbf{ok}}{\Gamma,\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta_{d}\rightarrow D\overline{m}_{d}}\right\} \,\mathbf{Empty}}\operatorname{Empty-ctx}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Empty
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-empty"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
While a system with a similar presentation has proven type soundness in
 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset

, we will not prove the type soundness of the system here.
 For clarity we will list the important properties as conjectures.
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the surface language extended with data and elimination preserves types
 over reduction.
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the surface language extended with data and elimination has progress if
 
\begin_inset Formula $\Gamma\,\mathbf{Empty}$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma\vdash m:M$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, then 
\begin_inset Formula $m$
\end_inset

 is a value, or 
\begin_inset Formula $m\rightsquigarrow m'$
\end_inset

 .
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the surface language extended with data and elimination is type sound.
\end_layout

\begin_layout Section
Bidirectional Type Checking
\end_layout

\begin_layout Standard
A bidirectional type checking procedure exists for the type assignment rules
 listed above.
 An outline of these rules is in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-empty"
plural "false"
caps "false"
noprefix "false"

\end_inset

.As noted in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3450952"
literal "false"

\end_inset

, the bidirectional rules around data are open to some interpretation.
 The dependent case simplifies these questions since only a few schemes
 are feasible.
\end_layout

\begin_layout Standard
The type of data constructors and type constructors can always be inferred.
 If the motive does not depend on the scrutinee or type arguments, it can
 be used to check against the type of the branches.
 An unmotivated 
\begin_inset Formula $\mathsf{case}$
\end_inset

 will be type checked.
 A 
\begin_inset Formula $\mathsf{case}$
\end_inset

 with a motive will have its type inferred.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\overrightarrow{\,:\,}\Delta\rightarrow*}\operatorname{\overrightarrow{ty}-TCon}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma}{\Gamma\vdash d\overrightarrow{\,:\,}\varTheta\rightarrow D\overline{m}}\operatorname{\overrightarrow{ty}-Con}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\left\{ ...\right\} \in\Gamma\\
\Gamma\vdash\overline{N}\overleftarrow{\,:\,}\Delta\quad\Gamma\vdash n\overleftarrow{\,:\,}D\overline{N}\\
\Gamma,\overline{x}:\Delta,z:D\,\overline{x}\vdash M\overleftarrow{\,:\,}\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{o}\in\Gamma.\quad\Gamma,\overline{y}_{d}:\varTheta\vdash m_{d}\left[\overline{x}\coloneqq\overline{o}\right]\overleftarrow{\,:\,}M\left[\overline{x}\coloneqq\overline{o},z\coloneqq d\,\overline{y}_{d}\right]
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{,N},n\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} \\
\overrightarrow{\,:\,}M\left[\overline{x}\coloneqq\overline{N},z\coloneqq n\right]
\end{array}}\operatorname{\overrightarrow{ty}-}\mathsf{case}<>
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\left\{ ...\right\} \in\Gamma\\
\Gamma\vdash\overline{N}\overleftarrow{\,:\,}\Delta\quad\Gamma\vdash n\overrightarrow{\,:\,}D\overline{N}\\
\Gamma\vdash M\overleftarrow{\,:\,}\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{o}\in\Gamma.\quad\Gamma,\overline{y}_{d}:\varTheta\vdash m_{d}\left[\overline{x}\coloneqq\overline{o}\right]\overleftarrow{\,:\,}M
\end{array}}{\Gamma\vdash\mathsf{case}\,\overline{N,}n\,\left\{ \overline{|\overline{x\Rightarrow}\,(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} \overleftarrow{\,:\,}M}\operatorname{\overleftarrow{ty}-}\mathsf{case}<>
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
reparam 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
o in 
\begin_inset Formula $\left[\overline{x}\coloneqq\overline{o}\right]$
\end_inset

 also
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Bidirectional type checking 
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-bi-ty"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can confidently conjecture that the desired bidirectional properties
 hold.
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the data extension to the bidirectional surface language is type sound.
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the data extension to the bidirectional surface language is weakly annotatable
 from the data extension of the surface language.
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
symbolically
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a minimal (and somewhat crude) accounting of bidirectional data.
 It is possible to imagine syntactic sugar that doesn't require the 
\begin_inset Formula $\overline{N,}$
\end_inset

 and 
\begin_inset Formula $\overline{x\Rightarrow}\,$
\end_inset

 the in case expression of the 
\begin_inset Formula $\operatorname{\overleftarrow{ty}-}\mathsf{case}<>$
\end_inset

 rule.
 In the dependent rule 
\begin_inset Formula $\operatorname{\overrightarrow{ty}-}\mathsf{case}<>$
\end_inset

 it is also also possible to imagine some type constructor arguments being
 inferred.
 These features and more will be subsumed by the dependent pattern matching
 of the next section, though this will complicate the meta-theory.
\end_layout

\begin_layout Part
Pattern Matching
\end_layout

\begin_layout Standard
Unfortunately, the direct eliminator style is cumbersome for programmers
 to deal with.
 For instance, Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-eliminators"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows how 
\begin_inset Formula $\mathtt{Vec}$
\end_inset

 data can be directly eliminated to extract the first element of a non-empty
 list in the definition of 
\begin_inset Formula $\mathtt{head'}$
\end_inset

.
 The 
\begin_inset Formula $\mathtt{head'}$
\end_inset

 function needs to redirect unreachable vector inputs to a dummy type (
\begin_inset Formula $\mathtt{Unit}$
\end_inset

) and requires several copies of the same 
\begin_inset Formula $\mathtt{A}$
\end_inset

 variable that are not identified automatically by the eliminator described
 in the last section.
 The usual solution is to extend case elimination with 
\series bold
Pattern matching.
\end_layout

\begin_layout Standard
Pattern matching is much more ergonomic than a direct eliminator 
\begin_inset Formula $\mathsf{case}$
\end_inset

.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-eliminators"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the 
\begin_inset Formula $\mathtt{head}$
\end_inset

 defined though pattern matching is simpler and clearer.
 Nested constructor matching is now possible.
 When pattern matching is extended to dependent types variables will be
 assigned their definitions as needed, and unreachable branches can be omitted
 from code.
 For this reason, pattern matching has been considered an 
\begin_inset Quotes eld
\end_inset

essential
\begin_inset Quotes erd
\end_inset

 feature for dependently typed languages since 
\begin_inset CommandInset citation
LatexCommand cite
key "coquand1992pattern"
literal "false"

\end_inset

 and is implemented implemented in most popular systems, such as Agda and
 the user facing language of Coq.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% This style of case elimination is pervasive in ML style languages and
 has become popular in more mainstream languages such as Python and Java
 (double check and perhaps not restrictions)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

 -- eliminator style
\end_layout

\begin_layout Plain Layout

 head' : (A : *) -> (n : Nat) ->
\end_layout

\begin_layout Plain Layout

   Vec A (S n) ->
\end_layout

\begin_layout Plain Layout

   A ;
\end_layout

\begin_layout Plain Layout

 head' A n v =
\end_layout

\begin_layout Plain Layout

   case A, (S n), v <
\end_layout

\begin_layout Plain Layout

     A' => n' => _ : Vec A' n' =>
\end_layout

\begin_layout Plain Layout

       case n' < _ => *> {
\end_layout

\begin_layout Plain Layout

         | (Z  ) => Unit
\end_layout

\begin_layout Plain Layout

         | (S _) => A'
\end_layout

\begin_layout Plain Layout

       }
\end_layout

\begin_layout Plain Layout

   >{
\end_layout

\begin_layout Plain Layout

   | _ => (Z)   => (Nil _       ) => tt
\end_layout

\begin_layout Plain Layout

   | _ => (S _) => (Cons _ a _ _) => a
\end_layout

\begin_layout Plain Layout

   } ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  -- pattern match style
\end_layout

\begin_layout Plain Layout

 head : (A : *) -> (n : Nat) ->
\end_layout

\begin_layout Plain Layout

   Vec A (S n) ->
\end_layout

\begin_layout Plain Layout

   A ;
\end_layout

\begin_layout Plain Layout

 head A n v =
\end_layout

\begin_layout Plain Layout

   case v < _ => A > {
\end_layout

\begin_layout Plain Layout

   | (Cons _ a _ _) => a
\end_layout

\begin_layout Plain Layout

   } ;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
match the single eliminator syntax
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
clean when I get motive inference working
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
example def by cases
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eliminators vs.
 Pattern Matching
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:data-eliminators"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Surface data syntax
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the extensions to the surface language for data and pattern matching.
 Our case expression match a list of scrutinees, allowing us to be very
 precise about the typing of branches.
 Additionally this style allows for syntactic sugar for easy definitions
 of functions by cases.
 The syntax of the direct eliminator style 
\begin_inset Formula $\mathsf{case}$
\end_inset

s of the last section was designed to be a special case of pattern matching.
 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
Example of why it was needed
\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{n,}\,\left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 without motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{n,}\,\left\langle \overline{x\Rightarrow}M\right\rangle \left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 with motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
patterns,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $pat$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
match a variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(d\,\overline{pat})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
match a constructor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Data
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Patterns correspond to a specific form of expression syntax.
 When an expression matches a pattern it will capture the relevant subexpression
s as variables.
 For instance, the expression.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $Cons\,\mathbb{B}\,true\,\left(S\left(S\left(S\left(Z\right)\right)\right)\right)\,\left(Cons\,\mathbb{B}\,false\,\left(S\left(S\left(Z\right)\right)\right)\,y'\right)$
\end_inset


\end_layout

\begin_layout Standard
will match the patterns
\end_layout

\begin_layout Itemize
\begin_inset Formula $Cons\,w\,x\,y\,z$
\end_inset

 with bindings 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $w=\mathbb{B}$
\end_inset

,
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $x=true$
\end_inset

, 
\begin_inset Formula $y=3$
\end_inset

, 
\begin_inset Formula $z=Cons\,\mathbb{B}\,false\,\left(S\left(S\left(Z\right)\right)\right)\,y'$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $x$
\end_inset

 with bindings 
\begin_inset Formula $x=Cons\,\mathbb{B}\,true\,\left(S\left(S\left(S\left(Z\right)\right)\right)\right)\,\left(Cons\,\mathbb{B}\,false\,\left(S\left(S\left(Z\right)\right)\right)\,y'\right)$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Cons\,-\,x\,-\,\left(Cons\,-\,y\,-\,-\right)$
\end_inset

 with bindings 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $x=true$
\end_inset

, 
\begin_inset Formula $y=false$
\end_inset


\end_layout

\begin_layout Standard
When patterns are used in the case construct, the appropriate branch will
 reduce with the correct bindings in scope.
 Therefore the expression 
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathsf{case}\,Cons\,\mathbb{B}\,true\,\left(S\left(S\left(S\left(Z\right)\right)\right)\right)\,\left(Cons\,\mathbb{B}\,false\,\left(S\left(S\left(Z\right)\right)\right)\,y'\right)\left\{ Cons\,-\,x\,-\,\left(Cons\,-\,y\,-\,-\right)\Rightarrow x\&y\right\} $
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
reduces to 
\begin_inset Formula $false$
\end_inset

.
\end_layout

\begin_layout Standard
The explicit rules for pattern matching are listed in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-match"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where 
\begin_inset Formula $\sigma$
\end_inset

 will hold a possibly empty set of assignments.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{x\ \mathbf{Match}_{\left\{ x\coloneqq m\right\} }\ m}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{pat}\ \mathbf{Match}_{\sigma}\ \overline{m}}{d\overline{pat}\ \mathbf{Match}_{\sigma}\ d\overline{m}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{pat'\ \mathbf{Match}_{\sigma'}\ n\quad\overline{pat}\ \mathbf{Match}_{\sigma}\ \overline{m}}{pat',\overline{pat}\ \mathbf{Match}_{\sigma'\cup\sigma}\ n,\overline{m}}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\,}{.\,\mathbf{Match}_{\emptyset}\,.}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Match
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-match"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is now easier for case branches to overlap, which could allow nondeterministi
c reduction.
 There are several plausible ways to handle this, such as requiring each
 branch to have independent patterns, or requiring patterns have the same
 behavior when they overlap 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-54833-8_6"
literal "false"

\end_inset

.
 For the purposes of this thesis, we will use the programatic convention
 that the first matching pattern takes precedence.
 For example, we will be able to type check
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathsf{case}\,4\,\left\langle s:\mathbb{N}\Rightarrow\mathbb{B}\right\rangle \left\{ |S\left(S\,-\right)\Rightarrow True\,|\,-\Rightarrow False\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
and it will reduce to 
\begin_inset Formula $True$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% pattern matching is hard
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

While pattern matching is an extremely practical feature, typing these expressio
ns tends to be messy.
 To implement dependently typed pattern matching, a procedure is needed
 to resolve the equational constraints that arise within each pattern, and
 to confirm the impossibility of unwritten branches.
\end_layout

\begin_layout Standard
Since arbitrary computation can be embedded in the arguments of a type construct
or
\begin_inset Foot
status open

\begin_layout Plain Layout
At least in a full spectrum theory, such as the one we study here.
\end_layout

\end_inset

, the equational constraints are undecidable in general.
 Any approach to constraint solving will have to be an approximation that
 performs well enough in practice.
 Usually this procedure usually takes the form of a first order unification.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%Similarly it is undecidable when a given pattern cannot be inhabited, so
 coverage checking will also necessarily be a conservative approximation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Unfortunately, the unification procedure involves terms outside of the
 pattern,  hence it is hard to pinpoint the exact point of error to the
 pattern.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Worryingly, it is easy to unintentionally validate or contradict principles
 like Streicher's axiom K, or the Law of the Excluded Middle.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
talk about or formalize the more subtle inference in the actual system
\end_layout

\end_inset


\end_layout

\begin_layout Section
First Order Unification
\end_layout

\begin_layout Standard
When type checking the branches of the a case expression, the patterns are
 interpreted as expressions under bindings for each variable used in the
 pattern.
 If these equations can be unified, then the brach will type-check under
 the variable assignments, with the additional typing information.
 For instance, the pattern
\end_layout

\begin_layout Standard
\begin_inset Formula $Cons\,x\,\left(S\,y\right)\,2\,z$
\end_inset


\end_layout

\begin_layout Standard
could be checked against the type 
\begin_inset Formula $Vec\,Nat\,w$
\end_inset


\end_layout

\begin_layout Standard
this implies the typings 
\begin_inset Formula $x:*,y:Nat,\left(S\,y\right):x,2:Nat,z:Vec\,x\,2,\left(Cons\,x\,\left(S\,y\right)\,2\,z\right):Vec\,Nat\,w$
\end_inset


\end_layout

\begin_layout Standard
which in turn imply the equalities
\end_layout

\begin_layout Standard
\begin_inset Formula $x=Nat,w=3$
\end_inset


\end_layout

\begin_layout Standard
This is a very simple example, in the worst case we may have equations in
 the form 
\begin_inset Formula $m\,n=m'\,n'$
\end_inset

 which are hard to solve directly (but may become easy to solve if assignment
 of 
\begin_inset Formula $m=\lambda x.x$
\end_inset

, and 
\begin_inset Formula $m'=\lambda-.0$
\end_inset

 are discovered).
\end_layout

\begin_layout Standard
One advantage of the first order unification approach is that if the algorithm
 succeeds, it will succeed with a unique, most general solution.
 Since assignments are maximal, we are sure that a unified pattern will
 still be able to match any well typed syntax.
\end_layout

\begin_layout Standard
A simplified version of a typical unification procedure is listed in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-unification"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Several variations are explored in 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx_devriese_2018"
literal "false"

\end_inset

.
 Unification is not guaranteed to terminate since it relies on definitional
 equalities, which are undecidable in the surface language.
 The unification procedure does not exclude the possibly cyclic assignments
 that could occur, such as 
\begin_inset Formula $x=S\,x$
\end_inset


\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
as a threat to soundness this should be corrected?
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{U\left(\emptyset,\emptyset\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E,a\right)\quad m\equiv m'}{U\left(\left\{ m\sim m'\right\} \cup E,a\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E\left[x\coloneqq m\right],a\left[x\coloneqq m\right]\right)}{U\left(\left\{ x\sim m\right\} \cup E,\left\{ a,x\coloneqq m\right\} \right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E\left[x\coloneqq m\right],a\left[x\coloneqq m\right]\right)}{U\left(\left\{ m\sim x\right\} \cup E,a\cup\left\{ x\coloneqq m\right\} \right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\overline{m}\sim\overline{m'}\cup E,a\right)\quad n\equiv d\overline{m}\quad n'\equiv d\overline{m'}}{U\left(\left\{ n\sim n'\right\} \cup E,a\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\overline{m}\sim\overline{m'}\cup E,a\right)\quad N\equiv D\overline{m}\quad N'\equiv D\overline{m'}}{U\left(\left\{ N\sim N'\right\} \cup E,a\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Unification
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-unification"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After the branches have type checked we should makes sure that they are
 exhaustive, such that every possible branch will be covered.
 There are several possible strategies.
 In general it is undecidable wether any given pattern is impossible or
 not, so a practical approximation must be chosen.
 At least programmers have the ability to manually include non-obviously
 unreachable branches and prove their unreachability, (or direct those branches
 to dummy outputs).
 Though there is a real risk that the unification procedure gets stuck in
 ways that are not clear to the programmer, and a clean error message may
 be very difficult.
\end_layout

\begin_layout Standard
Usually a branch is characterized as unreachable if a contradiction is found
 in the unification procedure.
 But that pattern or patterns must still be generated, given the explicit
 branches the programmer introduced.
 There is no clear 
\begin_inset Quotes eld
\end_inset

best way
\begin_inset Quotes erd
\end_inset

 to do this since a more fine devision of patterns may allow enough additional
 definitional information to show unsatisfiability, while a more coarse
 devision of patterns will be more efficient.
 Agda uses a tree branching approach, that is efficient, but generates course
 patterns.
 The implementation of the language in this thesis generates patterns by
 a system of complements, this system seams slightly easier to implement,
 more uniform, and generates a much finer system of patterns then the case
 trees used in Agda.
 However this approach is exponentially less performant then Agda in the
 worse case.
\end_layout

\begin_layout Standard
The bidirectional system can be extended with pattern matching with rules
 that look like 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\Gamma\vdash\overline{n}\overrightarrow{\,:\,}\ \Delta\\
\Gamma,\Delta\vdash M\overleftarrow{\,:\,}\star\\
\forall\:i\,\left(\Gamma\vdash\overline{pat}_{i}:_{E}?\Delta\quad U\left(E,\sigma\right)\quad\sigma\left(\Gamma,|\overline{pat}_{i}|\right)\vdash\sigma m\overleftarrow{\,:\,}\sigma\left(M\left[\Delta\coloneqq\overline{pat}_{i}\right]\right)\right)\\
\Gamma\vdash\overline{\overline{pat}}:\Delta\ \mathbf{complete}
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{n,}\,\left\langle \Delta_{?}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} \\
\overrightarrow{\,:\,}M\left[\Delta_{?}\coloneqq\overline{n}\right]
\end{array}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
more detail
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\Gamma\vdash\overline{n}\overrightarrow{\,:\,}\ \Delta\\
\forall\:i\,\left(\Gamma\vdash\overline{pat}_{i}:_{E}?\Delta\quad U\left(E,\sigma\right)\quad\sigma\left(\Gamma,|\overline{pat}_{i}|\right)\vdash\sigma m\overleftarrow{\,:\,}\sigma\left(M\right)\right)\\
\Gamma\vdash\overline{\overline{pat}}:\Delta\ \mathbf{complete}
\end{array}}{\Gamma\vdash\mathsf{case}\,\overline{n,}\,\left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} \overleftarrow{\,:\,}M}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\Gamma\vdash\overline{pat}:_{E}?\Delta$
\end_inset

 is shorthand for a set of equations that allow a list of patterns to type
 check under 
\begin_inset Formula $\Delta$
\end_inset

.
 and 
\begin_inset Formula $\Gamma\vdash\overline{\overline{pat}}:\Delta\ \mathbf{complete}$
\end_inset

 is shorthand for the exhaustiveness check.
 
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
Their exists a suitable
\begin_inset Foot
status open

\begin_layout Plain Layout
supporting at least subject reduction, type soundness, and regularity
\end_layout

\end_inset

 extension to the surface language TAS that supports patten matching style
 elimination
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
The bidirectional extension listed here is weakly annotatable with that
 extension to the surface language.
\end_layout

\begin_layout Standard
Additionally, it makes sense to allow some additional type annotations in
 the motive and for these annotations to switch the the type inference of
 the scrutinee into a type-check.
 The implementation includes this along with a simple syntax for modules,
 and even mutually defined data types.
 For simplicity these have been excluded from the formal presentation.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
ECHO VIEW from the left to 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
Inductive families
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pattern matching seems simple, but is a surprisingly subtle.
\end_layout

\begin_layout Standard
Even without dependent types, pattern matching is a strange feature.
 How important is it that patterns correspond exactly to a subset expression
 syntax? What about capture annotations or side conditions? Restricting
 patterns to constructors and variable means that it is hard to encapsulate
 functionality, a problem noticed as early as
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/41625.41653"
literal "false"

\end_inset

 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
review
\end_layout

\end_inset

.
 This has lead to making pattern behavior override-able in Scala via Extractor
 Objects.
 An extension in GHC allows some computations to happen within a pattern
 match via the 
\begin_inset Formula $ViewPatterns$
\end_inset

 extension 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
lots of prior work https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns
\end_layout

\end_inset

.
 It seems unreasonable to extend patterns to arbitrary computation (though
 this is allowed in the Curry language
\begin_inset Foot
status open

\begin_layout Plain Layout
https://curry.pages.ps.informatik.uni-kiel.de/curry-lang.org/
\end_layout

\end_inset

 as a syntax for its logical programming features).
 
\end_layout

\begin_layout Standard
In the presence of full-spectrum dependent types, the perspective dramatically
 shifts.
 Any terminating typing procedure will necessarily exclude some type-able
 patterns and be unable to exclude some unreachable branches.
 Even though only data values are considered, dependent patterns are already
 attacking a much more difficult problem then in the non-dependent case.
 It may make sense to extend the notion of pattern matching to include other
 useful but difficult features.
 To some extent this is similar to the with syntax of 
\begin_inset CommandInset citation
LatexCommand cite
key "mcbride_mckinna_2004"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
discuss stuck state of unification explicitly, x = f a vs.
 f a = g b, and how it for instance makes it so you can't prove transitivity
 of ID fa gb, ID gb hc -> ID fa hc.
 also calls into quesiton preservation entirely.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
Epigram
\end_layout

\end_inset

, Agda and Idris make pattern matching more powerful using 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathsf{with}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 syntax that allows further pattern based branching by attaching a computation
 to a branch.
 This is justified as syntactic sugar that corresponds to helper functions
 that can be appropriately elaborated and typed.
 The language described in this thesis does not use the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathsf{with}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 side condition since nested case expressions carry the same computational
 behavior, and the elaboration to the cast language will allow possibly
 questionable typing anyway.
\end_layout

\begin_layout Standard
More aggressive choices should be explored beyond the with construct.
 In principle it seems that dependent case expressions could be extended
 with relevant proof search, arbitrary computation or some amount of constraint
 solving, without being any theoretically worse than usual first order unificati
on.
 
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Discus how stratified type systems like ATS handle things (additional equational
 information)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% There are other questions that How should overlapping branches be handled?
 (think this got covered)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The details of pattern matching change the logical character of the system
\begin_inset CommandInset citation
LatexCommand cite
key "cockx_devriese_2018"
literal "false"

\end_inset

.
 Since non-termination is allowed in the language described here, the logical
 issues that arise from pattern are less of a concern then the immediate
 logical unsoundness that was discussed in chapter 2.
 However it is worth noting that pattern matching as described here validates
 axiom k and thus appears unsuitable for Hott or CTT developments.
\end_layout

\begin_layout Standard
This chapter has glossed over the definitional behavior of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathsf{case}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
s, since we plan to sidestep the issue with the cast language.
 It is worth noting that their are several ways to set up the definitional
 reductions.
 Agda style case trees may result in unpredictable definitional equalities
 (in so far as definitional behavior is ever predictable) 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-54833-8_6"
literal "false"

\end_inset

 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
review
\end_layout

\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1007/978-3-642-54833-8_6"
literal "false"

\end_inset

 advocates for a more conservative approach that makes function definitions
 by cases definitional (but shifts the difficulties to overlapping branches
 and does not allow the 
\begin_inset Quotes eld
\end_inset

first match
\begin_inset Quotes erd
\end_inset

 behavior programmers are used to).
 Another extreme would be to only allow reductions at fully computed scrutinee
 values, as in trellies work 
\begin_inset CommandInset citation
LatexCommand cite
key "sjoberg2012irrelevance"
literal "false"

\end_inset


\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
confirm
\end_layout

\end_inset

.
 Alternatively a partial reduction is possible, such that branches are eliminate
d as they are found unreachable and substitutions made as they are available.
 This last approach is experimentally implemented for the language defined
 here.
\end_layout

\begin_layout Standard
This complicates the simple story from chapter 2, where the bidirectional
 system made the TAS system checkable by only adding annotations (and having
 annotatability).
 We have only conjectured the existence of a suitable TAS system for pattern
 matching.
 If the definitional equality that feeds the TAS is generated by a system
 of reductions, any of the reduction strategies will generate a different
 TAS with subtly different characteristics.
 For instance, insisting on a call-by-value case reduction will leave many
 equivalent computations unassociated.
 If the TAS system uses partial reductions it will need to inspect the construct
ors of the scrutinee in order to preserve typing when reduction eliminates
 branches.
 Agda style reductions need to extend syntax under reduction to account
 for side conditions.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% For this reason it is rare to see a fully formailized account of pattern
 matching.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ideally the typing rule for pattern matching case expression in the TAS
 should not use the notion of unification at all.
 Instead the rule should characterize the behavior that is required directly
 and formally
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
key "coquand1992pattern"
literal "false"

\end_inset

 has a good informal description
\end_layout

\end_inset

.
 An ideal rule might look like
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{cl}
\Gamma\vdash\overline{n}:\Delta' & (scrutinees\ type\ check)\\
\Gamma,\overline{x}:\Delta'\vdash M:\star & (motive\ exists\ and\ is\ well\ formed)\\
\forall i.\:? & (every\ branch\ is\ well\ typed\ over\ all\ possible\ instantiations)\\
? & (all\ scrutinees\ are\ handled)
\end{array}}{\Gamma\vdash\mathsf{case}\,\overline{n,}\,\left\{ \overline{|\,\overline{pat\Rightarrow}_{i}m_{i}}\right\} :M\left[\overline{x}\coloneqq\overline{n}\right]}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
last condition is optional if you're willing to modify type soundness to
 allow pattern match errors (again, they are no worse then the non-termination
 already allowed, and better behaved).
\end_layout

\begin_layout Part
Related work
\end_layout

\begin_layout Section
Systems with Data
\end_layout

\begin_layout Standard
Many systems that target data only formalize a representative collection
 of data types, expecting the reader to be able to generalize the scheme.
 This data usually covers Nats (for recursion) dependent pairs (for type
 constructor arguments) and unit to end a chain of dependent pairs.
 For example, Martin Lof's original paper treated data this way
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
confirm, cite
\end_layout

\end_inset

, and is still a common approach tp data (for instance in 
\begin_inset CommandInset citation
LatexCommand cite
key "jia2010dependent"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
Martin Lof generalized the notion of data to W types of well founded trees
 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
confirm, cite
\end_layout

\end_inset

 and this still serves as a theoretical justification for data.
\end_layout

\begin_layout Standard
Unified Type Theory (UTT)
\begin_inset CommandInset citation
LatexCommand cite
key "luo1990extended,luo1994computation"
literal "false"

\end_inset

 is an extension to ECC that specifies a scheme to define strictly positive
 data types by way of a logical framework defined in MLTT.
 This scheme generates primitive recursors for schematized data, and does
 not inherently support pattern matching.
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
finish reading this
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Calculus of Inductive Constructions (CiC) is an extension to the calculus
 of constructions that includes a system of first class data.
 It was first presented in 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Inductive definitions in the system Coq rules and properties
\begin_inset Quotes erd
\end_inset

 confirm
\end_layout

\end_inset

 , but the most complete up to date formulation is maintained as part of
 the Coq manual 
\begin_inset Foot
status open

\begin_layout Plain Layout
https://coq.github.io/doc/v8.9/refman/language/cic.html
\end_layout

\end_inset

.
 A bidirectional account of CIC is given in 
\begin_inset CommandInset citation
LatexCommand cite
key "lennonbertrand:LIPIcs.ITP.2021.24"
literal "false"

\end_inset

, though it uses a different style of bidirectionally then discussed here
 to maintain compatibility with the existing Coq system.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
CTT, higher inductive types, quotient types
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pattern matching
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Clean up this section
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Early work by Coq92 
\begin_inset CommandInset citation
LatexCommand cite
key "coquand1992pattern"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
with a lot of follow up from McBride 
\begin_inset CommandInset citation
LatexCommand cite
key "mcbride_mckinna_2004"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
reiterated in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
A tutorial implementation of dynamic pattern unification Adam Gundry and
 Conor McBride (2012) http://adam.gundry.co.uk/pub/pattern-unify/ (this links
 give you the choice to read a more detailed chapter of Adam Gundry's thesis
 instead)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
with substantial follow up in 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx_devriese_2018"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
https://research.chalmers.se/en/publication/519011 ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
https://sozeau.gitlabpages.inria.fr/www/research/publications/Equations:_A_Dependen
t_Pattern-Matching_Compiler.pdf ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.99.1405&rep=rep1&type=pdf
 ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
talk about normalization
\end_layout

\end_inset


\end_layout

\begin_layout Standard
https://popl19.sigplan.org/details/POPL-2019-Research-Papers/33/Higher-Inductive-T
ypes-in-Cubical-Computational-Type-Theory
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/thesis/bibliography/dtest"
options "alpha"

\end_inset


\end_layout

\begin_layout Part
TODO
\end_layout

\begin_layout Itemize
differentiate identifiers with font, font stuff with code
\end_layout

\begin_deeper
\begin_layout Itemize
Make identifiers consistent with chapter 2, and locations in chapter 3
\end_layout

\end_deeper
\begin_layout Itemize
definition package?
\end_layout

\begin_layout Itemize
syntax highlighting
\end_layout

\begin_layout Itemize
additional equations al la ATS +trellis
\end_layout

\begin_layout Itemize
allowing equality matching (based on typeclass?)
\end_layout

\begin_layout List of TODOs

\end_layout

\begin_layout Section
notes
\end_layout

\begin_layout Standard
Other extensions to the Calculus of Constructions that are primarily concerned
 with data (UCC, CIC) will be reviewed in chapter 4.
\end_layout

\begin_layout Standard
Coq and Lean trace their core theory back to the Calculus of Constructions.
\end_layout

\begin_layout Section
unused
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\Delta\,\overleftarrow{\mathbf{ok}}}{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\overleftarrow{\mathbf{ok}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,\Delta\quad\forall d.\Gamma,\mathsf{data}\,D\,\Delta\vdash\varTheta_{d}\quad\forall d.\:\Gamma,\mathsf{data}\,D\,\Delta,\varTheta_{d}\vdash\overline{m}_{d}:\Delta}{\Gamma\vdash\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta_{d}\rightarrow D\overline{m}_{d}}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\end_body
\end_document
