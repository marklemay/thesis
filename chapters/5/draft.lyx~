#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xcolor}
\usepackage{tikz-cd}
\tikzcdset{%
    triple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure' 
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    quadruple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure'
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    Rrightarrow/.code={\tikzcdset{triple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}},
    RRightarrow/.code={\tikzcdset{quadruple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}}
}    
\newcommand*{\tarrow}[2][]{\arrow[Rrightarrow, #1]{#2}\arrow[dash, shorten >= 0.5pt, #1]{#2}}
\newcommand*{\qarrow}[2][]{\arrow[RRightarrow, #1]{#2}\arrow[equal, double distance = 0.25pt, shorten >= 1.28pt, #1]{#2}}
\end_preamble
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Chapter 5 (draft): Symbolic Execution
\end_layout

\begin_layout Author
Mark Lemay
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Not yest implemanted (earlier version was, but this contains substantial
 changes)
\end_layout

\end_inset


\end_layout

\begin_layout Part
Symbolic Execution
\end_layout

\begin_layout Standard
one of the vlaues of type checking is the imeduacy of feedback.
 We have outlined here a system that will give warning messages immedialy,
 but requires evaluation to give the detailed error messages that are most
 helpful to correct a program.
 This is especially important if the user wants to use the system as a (clasical
) proof language, and will not generally exicute thier proofs.
 The symbolic evaluation sytem recaptures some of that qiucker feed back,
 by specifing a system that passively tries to find errors.
\end_layout

\begin_layout Standard
This process is semidecidable in general (by testing against all well typed
 syntax).
 But this is infeasably inefficient for Type syntax and function syntax,
 So we will present a procesure that treats elements of those types extentionall
y.
 Additionally we can again reduce the search space by only engaging with
 values of data type instead of all expressions.
\end_layout

\begin_layout Standard
Additionally since this preocedure operates over the cast langauge, we must
 decide what is a reonsable exicution of code
\end_layout

\begin_layout Itemize
on one extreame, our testing code could introduce new blame that is exercied
\end_layout

\begin_layout Itemize
the testing code could introduce casts as long as no blame error occurs
\end_layout

\begin_layout Itemize
the testing code could insist that no blame is possible
\end_layout

\begin_layout Standard
we will attempt to use the middle ground criterion.
\end_layout

\begin_layout Standard
Since the procedure remains semidecidable, we intend to run it incrementally,
 with whatever resources aer availible.
 The procedure is inteded to be run durring the continous integration phase
 of standard software development.
\end_layout

\begin_layout Section
Examples
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
subsume into parts
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
in free functions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f h = h (
\backslash
 x => err) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
functions consitent
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f h = 
\end_layout

\begin_layout Plain Layout

  case h 1  
\end_layout

\begin_layout Plain Layout

    True => case h 1
\end_layout

\begin_layout Plain Layout

      False => err
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
and all varients
\end_layout

\end_inset


\end_layout

\begin_layout Standard
but worse
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f h g = 
\end_layout

\begin_layout Plain Layout

  case h g  
\end_layout

\begin_layout Plain Layout

    True => case h (
\backslash
x => g x)
\end_layout

\begin_layout Plain Layout

      False => err
\end_layout

\end_inset


\end_layout

\begin_layout Standard
but worse (can recursively rely on itself)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

g: Nat -> Nat ;
\end_layout

\begin_layout Plain Layout

h: (Nat -> Nat) -> Nat ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f h g = 
\end_layout

\begin_layout Plain Layout

  case h g  
\end_layout

\begin_layout Plain Layout

    True => case h (
\backslash
x => h (x (
\backslash
y => 0))
\end_layout

\begin_layout Plain Layout

      False => err
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
handle inflexable recursion
\end_layout

\end_inset


\end_layout

\begin_layout Standard
surface
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f (eq : Id (Nat -> Nat) (
\backslash
x => x+1) (
\backslash
x => 1+x)) = 
\end_layout

\begin_layout Plain Layout

  case eq  
\end_layout

\begin_layout Plain Layout

    _ => ...?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

paremetric
\begin_inset Quotes erd
\end_inset

 types
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f T t t' h = 
\end_layout

\begin_layout Plain Layout

  case h t t'  
\end_layout

\begin_layout Plain Layout

    True => case h t t'  
\end_layout

\begin_layout Plain Layout

      False => err
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
and all varients
\end_layout

\end_inset


\end_layout

\begin_layout Standard
surface
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f T (t :T) (eq : Id _ T (Id Nat 1 2)) = 
\end_layout

\begin_layout Plain Layout

  case eq  
\end_layout

\begin_layout Plain Layout

    _ => ...?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
handle the k binders
\end_layout

\end_inset


\end_layout

\begin_layout Part
The functional fragment
\end_layout

\begin_layout Standard
\begin_inset Formula $I$
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

thin ctx
\begin_inset Quotes erd
\end_inset

 may need to add an evaluation context
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright\mathsf{fun}\,f\,x\Rightarrow b:\left(x:A\right)\rightarrow B\quad I\vdash y:A}{I\boxempty c:C\ o.app[a]\vartriangleright b\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow b,x\coloneqq y\right]:B\left[x\coloneqq y\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
a little abuse of notation
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright\left(x:A\right)\rightarrow B:\star}{I\boxempty c:C\ o.Arg\vartriangleright A:\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright\left(x:A\right)\rightarrow B:\star\quad I\vdash a:A}{I\boxempty c:C\ o.Bod[a]\vartriangleright B\left[x\coloneqq a\right]:\star}
\]

\end_inset


\end_layout

\begin_layout Standard
(use a var insteead of a?)
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright fa:C'\quad I\vdash a:A}{I\boxempty c:C\ o.Inspect\vartriangleright a:A}
\]

\end_inset


\end_layout

\begin_layout Standard
from ctx
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright a:A'\quad x\equiv\star\in I}{I\boxempty c:C\ o\vartriangleright a\left[x\coloneqq a\right]:A\left[x\coloneqq a\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright a:A'\quad x\equiv\left(y:A\right)\rightarrow B\in I}{I\boxempty c:C\ o\vartriangleright a\left[x\coloneqq\left(y:A\right)\rightarrow B\right]:A\left[x\coloneqq\left(y:A\right)\rightarrow B\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright a:A'\quad xb\equiv y\in I}{I\boxempty c:C\ o\vartriangleright a\left[xb\coloneqq y\right]:A\left[xa\coloneqq b\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
like conv
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{I\boxempty c:C\ o\vartriangleright a:A\quad a\rightsquigarrow a'}{I\boxempty c:C\ o\vartriangleright a':A}
\]

\end_inset


\end_layout

\begin_layout Standard
the goal is to reach a location with blame
\end_layout

\begin_layout Standard
need probes still
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Subsection
Testing
\end_layout

\begin_layout Standard
many of the testinf strategies for typed functional programming trace their
 heritage to property based testing in QuickCheck 
\begin_inset CommandInset citation
LatexCommand cite
key "quickcheck"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
QuickChick 
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/QuickChick/QuickChick
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "denes2014quickchick"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lampropoulos2017generating,lampropoulos2017beginner,lampropoulos2018random"
literal "false"

\end_inset

 uses type-level predicates to construct generators with soundness and completen
ess properties, but without support for higher order functions.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset citation
LatexCommand cite
key "dybjer2003combining"
literal "false"

\end_inset

 added QuickCheck style testing to Agda 1
\end_layout

\begin_layout Subsection
Symbolic Exicution
\end_layout

\begin_layout Standard
Symbolic evaluation is a technique to efficiently extract errors from programs.
 Usually this happens in the context of an imperative language with the
 assistance of an SMT solver.
 Symbolic evaluation can be suplemented with other teqniques and a rich
 literature existes on teh topic.
 
\end_layout

\begin_layout Standard
The situration described in this chapter is unuasual from the perspective
 of symbolic exicution.
 But symbolic exicution is probly still a good description
\end_layout

\begin_layout Itemize
the number of bvlamable source positions is limited by the location tags.
 Thus the search is error guided, rather then civerage guided.
\end_layout

\begin_layout Itemize
The laguage is dependently typed.
 Often teh language under test is untyped.
\end_layout

\begin_layout Itemize
The language needs higher order exicution.
 often the reasurch in this area focuses on base types taht are efficiently
 handlable with an SMT solver.
\end_layout

\begin_layout Standard
This limits the proir work to relatively few papers
\end_layout

\begin_layout Itemize
A Symbolic exicution engine for haskell is presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.1145/3314221.3314618"
literal "false"

\end_inset

, but at teh time of publication it did not supert higher order functions.
\end_layout

\begin_layout Itemize
A scheme for handling higher order functions is presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "nguyen2017higher"
literal "false"

\end_inset

, however the system is designed for Racket and is untyped.
 Addtionally it seems that there might be a state space explosion in teh
 presnes of higher order functions.
\end_layout

\begin_layout Itemize
Closest to the goal here, 
\begin_inset CommandInset citation
LatexCommand cite
key "lin_et_al:LIPIcs:2020:12349"
literal "false"

\end_inset

 uses game semantics to build a symvbolic execution engine for a subset
 of ML with some nice theoretical properties.
\end_layout

\begin_layout Itemize
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
That crazy stuff B.P.
 was up to
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion and Future Work
\end_layout

\begin_layout Standard
The goal of this chapter has been to describe a procedure that is suitable
 for implementation.
 To accomplish this several areas of meta-theory have been ignored.
 This approach suggests two desirable properties
\end_layout

\begin_layout Enumerate
Every error that could be caused by the program can be observed via symbolic
 execution
\end_layout

\begin_layout Enumerate
Every error in observed by symbolic executions can be realized as a program
 (no error is spurious)
\end_layout

\begin_layout Standard
We strongly conjecture the first property to hold 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
time permitteing prove, via logging
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The 2nd property is more subtle.
 We have not described evaluaiton contexts sufficiently, this is to maintian
 compatability with modules that have not been formalized.
 For insatnce,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

f : * ;
\end_layout

\begin_layout Plain Layout

f = (x : Bool) -> (Nat :: Bool) ;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will not be able to induce a term level error, since no term level observation
 can observe the type cast
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
this isn't exactlye right f can be aplied in a wierd way
\end_layout

\end_inset

.
 However we want to obseve errors here becuase f could be exported through
 the module system and used in an unforseen type annotation where an error
 could be observed.
\end_layout

\begin_layout Standard
More subtle is that the procedure described here will allow f to observe
 parellel or, even though parellel or cannot be constructed within the language.
 This hints that the aproach presented here could be revised in terms of
 games semantics (perhaps along lines like 
\begin_inset CommandInset citation
LatexCommand cite
key "lin_et_al:LIPIcs:2020:12349"
literal "false"

\end_inset

).
 Though game semantics for dependent types is a complicated subject in and
 of isteslf 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Part
The Full Language
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
all thos other papers about symbolic exicution for functions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Game semantics?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/thesis/bibliography/dtest"
options "alpha"

\end_inset


\end_layout

\begin_layout Part
TODO
\end_layout

\begin_layout List of TODOs

\end_layout

\begin_layout Section
notes
\end_layout

\begin_layout Standard
there are several simpler systems that can be worked through: eliminator
 style patterns, cast patterns, but to bring it all together we need congruence
 over functions.
\end_layout

\begin_layout Standard
adding paths and path variables means that constructs can still fail at
 runtime, but they can blame the actually problematic components
\end_layout

\begin_layout Standard
validating the K axiom, not that equalities are unique, merely that we don't
 care which one of the unique equalities is used.
\end_layout

\begin_layout Section
unused
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

-- standard data in normal form, 3
\end_layout

\begin_layout Plain Layout

S (S (S 0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- cast data in normal form
\end_layout

\begin_layout Plain Layout

S (S (S 0) :: Nat ) :: Nat :: Nat :: Nat
\end_layout

\begin_layout Plain Layout

S (S (S 0) :: Nat ) :: Bool :: Nat
\end_layout

\begin_layout Plain Layout

True :: Nat
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- cast pattern matching
\end_layout

\begin_layout Plain Layout

case x <_ => Bool> {
\end_layout

\begin_layout Plain Layout

| (Z :: _) => True
\end_layout

\begin_layout Plain Layout

| (S (Z :: _) :: _) => True
\end_layout

\begin_layout Plain Layout

| (S (S :: _) :: _) => False
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- extract specific blame,
\end_layout

\begin_layout Plain Layout

-- c is a path from Bool~Nat
\end_layout

\begin_layout Plain Layout

case x <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| (S ((true::c)::_) :: _) =>
\end_layout

\begin_layout Plain Layout

 add (false :: c) 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- can reconstitute any term,
\end_layout

\begin_layout Plain Layout

-- not always possible with unification
\end_layout

\begin_layout Plain Layout

-- based pattern matching
\end_layout

\begin_layout Plain Layout

case x <_:Nat => Nat> {
\end_layout

\begin_layout Plain Layout

| (Z :: c) => Z :: c
\end_layout

\begin_layout Plain Layout

| (S x :: c) => S x :: c
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- direct blame
\end_layout

\begin_layout Plain Layout

case x <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| (S (true::c) :: _) => Bool =/=c Nat
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peek x =
\end_layout

\begin_layout Plain Layout

case x <_: Id Nat 0 1 => Nat> {
\end_layout

\begin_layout Plain Layout

  | (refl x :: _) => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peek (refl 4 :: Id Nat 0 1) = 4
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
to stylize consistently, should use math font, or like a nice image
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
break into smaller more relevant examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Pattern Matching
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-pattern-matching"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <pr : Id A a a => Id (Id A a a) pr (refl A a) > {
\end_layout

\begin_layout Plain Layout

| (refl A' a') :: p => 
\end_layout

\begin_layout Plain Layout

refl (((Id A')::(A -> A -> *)) (a'::A) (a'::A) ) :: (pr' : (Id A a a) ->
 Id (Id A a a) pr' pr')
\end_layout

\begin_layout Plain Layout

(refl A')::((a : A) -> Id A a a) (a'::A)) :: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $p:Id\,A'\,a'\,a'\thickapprox Id\,A\,a\,a$
\end_inset

, ...
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{HK\,\mathbf{ok}}{HK\vdash\lozenge:.}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H,x:A;K\vdash\Delta\quad H;K\vdash A:\star\quad H;K\vdash patc:\Delta}{HK\vdash x,patc\::\:\left(x:A\right)\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
d\,:\,\varTheta\rightarrow D\overline{b}\in H\\
HK\vdash\overline{patc'}:\varTheta\\
H,\left(\overline{patc'}:\varTheta\right),x_{p}:D\overline{b}\thickapprox D\overline{a},K\vdash patc:\Delta\left[x\coloneqq d\,\overline{patc'}::_{x_{p}}\right]
\end{array}}{HK\vdash d\,\overline{patc'}::_{x_{p}},patc\::\:\left(x:D\overline{a}\right),\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{HK\vdash A:\star}{HK\vdash x:A}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma,x:M\vdash\Delta\quad\Gamma\vdash m:M\quad\Gamma\vdash\overline{n}\left[x\coloneqq m\right]:\Delta\left[x\coloneqq m\right]}{\Gamma\vdash m,\overline{n}\,:\,x:M,\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\,:\,\Delta\rightarrow*}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma}{\Gamma\vdash d\,:\,\varTheta\rightarrow D\overline{m}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{HK\vdash x:A}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash A:\star}{H\vdash refl:A\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash B:\star\quad H,x:B\vdash C:\star\quad H\vdash b:B\quad H\vdash b':B\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv A'}{H\vdash A_{\ell.x\Rightarrow C}A':A\thickapprox A'}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT, would then need to resolve endpoint def equality
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash a':A\quad H,x:A\vdash C:\star}{H\vdash assert_{\ell.(a=a':A).x\Rightarrow C}:C\left[x\coloneqq a\right]\thickapprox C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash p:A\thickapprox B\quad H\vdash p':B\thickapprox C}{H\vdash p\,p':A\thickapprox C}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash p:A\thickapprox B}{H\vdash rev\,p:B\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Standard
typing rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash C:\star\quad H\vdash p:A\thickapprox B\quad AandBDisagree}{H\vdash A\neq_{p}B:C}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H,x:B\vdash C:\star\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv B}{H\vdash a::_{A,\ell.x\Rightarrow C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash a':A\quad H,x:A\vdash C:\star\quad H\vdash a:c\left[x\coloneqq a\right]}{H\vdash c::_{\ell\left(a=a':A\right).x\Rightarrow C}\quad:C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT remove concrete casts and merely use a symbolic cast instead?
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H,x:B\vdash C:\star\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv B\quad p:b\thickapprox b'}{H\vdash a::_{A,p.x\Rightarrow C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash c:C\left[x\coloneqq a\right]\quad H,x:A\vdash C:\star\quad H\vdash p:a\thickapprox a'}{H\vdash c::_{p.x\Rightarrow C}\quad:C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
H\vdash\overline{a}:\Delta\\
H,\Delta\vdash B:\star\\
\forall\:i\,\left(H\vdash Gen\left(\overline{patc}_{i}:\Delta,\Theta\right)\quad\Gamma,\Theta\vdash m:M\left[\Delta\coloneqq\overline{patc}_{i}\right]\right)\\
H\vdash\overline{\overline{patc}}:\Delta\ \mathbf{complete}
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{a,}\,\left\langle \overline{\Delta\Rightarrow}B\right\rangle \left\{ \overline{|\,\overline{patc\Rightarrow}b}\right\} \\
:M\left[\Delta\coloneqq\overline{n}\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
Gen is defined as 
\begin_inset Formula 
\[
\frac{\,}{H\vdash Gen\left(.:.,.\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\sim H\vdash A:\star\sim}{H\vdash Gen\left(x:(x:A),\;x:A\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\sim H\vdash A:\star\sim}{H\vdash Gen\left(x:A,\;x:A\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{d\,:\,\varTheta\rightarrow D\overline{a}\in H\quad H\vdash Gen\left(\overline{pat_{c}}:\varTheta,\Delta\right)}{H\vdash Gen\left(d\overline{pat_{c}}::_{x_{p}}:D\overline{b},\;\Delta,x_{p}:D\overline{a}\thickapprox D\overline{b}\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash Gen\left(pat_{c}:A,\Theta\right)\quad H,\Theta\vdash Gen\left(\overline{pat_{c}}:\Delta\left[x\coloneqq pat_{c}\right],\Theta'\right)}{H\vdash Gen\left(pat_{c}\overline{pat_{c}}:\left(x:A,\Delta\right),\Theta\Theta'\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
other rules similar to the surface lang
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
old style red rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{rev\,\left(p\,p'\right)\rightsquigarrow\left(rev\,p'\right)\left(rev\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inTC_{i}\,\left(p\,p'\right)\rightsquigarrow\left(inTC_{i}\,p'\right)\left(inTC_{i}\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(p\,p'\right)\rightsquigarrow\left(inC_{i}\,p'\right)\left(inC_{i}\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inTC_{i}\,refl\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,refl\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{a}_{i}=a'\;\overline{c}_{i}=c'\;\overline{b}_{i}=b'}{inTC_{i}\,\left(D\,\overline{a}_{\ell.D\,\overline{c}}D\,\overline{b}\right)\rightsquigarrow a'_{\ell.c'}b'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(\left(a::A\right)_{\ell.c}b\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(a_{\ell.c}\left(b::B\right)\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(a_{\ell.\left(c::C\right)}b\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\overline{a}_{i}=a'\;\overline{c}_{i}=c'\;\overline{b}_{i}=b'}{inTC_{i}\,\left(d\,\overline{a}_{\ell.d\,\overline{c}}d\,\overline{b}\right)\rightsquigarrow a'_{\ell.c'}b'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a::_{A,p\,refl,x.C}B\rightsquigarrow a::_{A,p,x.C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\begin{array}{c}
a::_{A,p\,A'_{\ell.C''}B',x.C}B\rightsquigarrow\\
a::_{A,p,x.C}C\left[x\coloneqq A'\right]::_{\ell.C\left[x\coloneqq C''\right]}C\left[x\coloneqq B'\right]
\end{array}c}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
c?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left(a::_{A,p,x.C}C\right)\sim_{\ell o}b\rightsquigarrow a\sim_{\ell o}b}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a\sim_{\ell o}\left(b::_{B,p,x.C}C\right)\rightsquigarrow a\sim_{\ell o}b}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="33" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path var,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion index,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kin$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k=left$
\end_inset

 | 
\begin_inset Formula $k=right$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
casts under assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{\overline{kin,}p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path exp.,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p,p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concrete cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $refl$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\begin_inset Formula $p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastL_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastR_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast pattern,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $patc$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $d\,\overline{patc}::_{x_{p}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast expression,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
force blame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ a\sim_{k,o,\ell}b\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assert same
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{C\rightsquigarrow C'}{Assert_{k\Rightarrow C}\rightsquigarrow Assert_{k\Rightarrow C'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{refl\,p\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{p\,refl\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\quad}{\left(q\,p\right)^{-1}\rightsquigarrow p^{-1}\,q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'\quad p}{q\,p\rightsquigarrow q'\,p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\ \mathbf{Val}\quad p\rightsquigarrow p'}{q\,p\rightsquigarrow q\,p'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(Assert_{k\Rightarrow C}\right)^{-1}\rightsquigarrow Assert_{k\Rightarrow\mathbf{Swap}_{k}C}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(Assert_{k\Rightarrow D\overline{A}}\right)\rightsquigarrow Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(Assert_{k\Rightarrow d\overline{A}}\right)\rightsquigarrow Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\end_layout

\begin_layout Standard
TODO review this
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{remove\,k=left\,casts\quad a\:\mathbf{whnf}}{uncastL\,\left(Assert_{k\Rightarrow a::\overline{\overline{kin,}p;}}\right)\rightsquigarrow Assert_{k\Rightarrow a::\overline{\overline{kin',}p';}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
probly need to modify substution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{refl^{-1}\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
TODO review this
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{uncastL\,\left(refl\right)\rightsquigarrow?}
\]

\end_inset


\end_layout

\begin_layout Standard
term redcutions
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{!_{p}\rightsquigarrow!_{p'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ a::\overline{\overline{kin,}p;}\overline{kin,}q\,Assert_{k\Rightarrow C};\overline{\overline{kin',}p';}\sim_{k,o,\ell}b\right\} \rightsquigarrow\left\{ a::\overline{\overline{kin,}p;}\overline{kin,}q;\overline{\overline{kin',}p';}\sim_{k,o,\ell}b\right\} ::\overline{kin,}k=left\,Assert_{k\Rightarrow C};}
\]

\end_inset


\end_layout

\begin_layout Standard
symetric around 
\begin_inset Formula $\sim$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \star\sim_{k,o,\ell}\star\right\} \rightsquigarrow\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \left(x:A\right)\rightarrow B\sim_{k,o,\ell}\left(x:A'\right)\rightarrow B'\right\} \rightsquigarrow\left(x:\left\{ A\sim_{k,o.arg,\ell}A'\right\} \right)\rightarrow\left\{ B\sim_{k,o.bod\left[x\right],\ell}B'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \mathsf{fun}\,f\,x\Rightarrow b\sim_{k,o,\ell}\mathsf{fun}\,f\,x\Rightarrow b'\right\} \rightsquigarrow\mathsf{fun}\,f\,x\Rightarrow\left\{ b\sim_{k,o.app\left[x\right],\ell}b'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ d\overline{a}\sim_{k,o,\ell}d\overline{a'}\right\} \rightsquigarrow d\overline{\left\{ a_{i}\sim_{k,o.o.DCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ D\overline{a}\sim_{k,o,\ell}D\overline{a'}\right\} \rightsquigarrow D\overline{\left\{ a_{i}\sim_{k,o.o.TCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a::\overline{\overline{kin,};}\rightsquigarrow a}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{pointwise\ concatination}{\left(a::\overline{\overline{kin,p};}\right)::\overline{\overline{kin',p'};}\rightsquigarrow...}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)b\rightsquigarrow\left(\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)\left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right)::kin,Assert_{k\Rightarrow B\left[x\coloneqq\left\lfloor \left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right\rfloor _{k=kin}\right]};}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Match\,\overline{a}\,patc_{i}}{\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc_{i}\Rightarrow}b_{i}}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} \rightsquigarrow b_{i}\left[patc_{i}\coloneqq\overline{a}\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}}{q\circ refl\circ p\rightsquigarrow q\circ p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}\quad q\ \mathbf{Val}}{\left(q\circ p\right)^{-1}\rightsquigarrow p^{-1}\circ q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'}{p\circ q\rightsquigarrow p\circ q'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\ \mathbf{Val}\quad p\rightsquigarrow p'}{p\circ q\rightsquigarrow p'\circ q}
\]

\end_inset


\end_layout

\end_body
\end_document
