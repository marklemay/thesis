#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xcolor}
\usepackage{tikz-cd}
\tikzcdset{%
    triple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure' 
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    quadruple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure'
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    Rrightarrow/.code={\tikzcdset{triple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}},
    RRightarrow/.code={\tikzcdset{quadruple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}}
}    
\newcommand*{\tarrow}[2][]{\arrow[Rrightarrow, #1]{#2}\arrow[dash, shorten >= 0.5pt, #1]{#2}}
\newcommand*{\qarrow}[2][]{\arrow[RRightarrow, #1]{#2}\arrow[equal, double distance = 0.25pt, shorten >= 1.28pt, #1]{#2}}
\end_preamble
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Chapter 4b (draft): Data and Pattern Matching in the Cast Language
\end_layout

\begin_layout Author
Mark Lemay
\end_layout

\begin_layout Part
Cast Language Data
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Cast pattern matching is easy!
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Surprisingly, the cast system can be extended with a pattern matching construct
 without unification.
\end_layout

\begin_layout Standard
Consider the normal forms of data terms.
 While in standard dependent type theory a normal form of data, in a closed
 context, must have the data constructor in head position (justifying the
 pattern syntax), in the cast language the normal form of data will have
 a stack of 0 or more casts applied to it.
 Casts will be wrapped around constructors during the elaboration procedure,
 and will accumulate during evaluation.
 If the cast language is extended with a path variable that can represent
 the stack of equalities then that stack can be matched and used in the
 body of the branch.
 Since the type constructor is known, it is possible to check the coverage
 of the patterns against it's constructors.
 If every constructor is accounted for, only blameable data remains.
 Quantifying over casts allows blame to be redirected, so if the program
 gets stuck in a pattern branch it can blame the malformed input.
 
\end_layout

\begin_layout Standard
If we hope to target the lemmas of Chapter 3 we need the cast language to
 be 
\series bold
cast sound
\series default
 and elaboration to have the 
\series bold
gradual correctness
\series default
 properties relative to the type assignment system.
 
\end_layout

\begin_layout Standard
To account for unreachable patterns, we can record the proof of inequality
 that makes the unification unsatisfiable with an explicit blame syntax.
 It is perfectly possible for a case expression to reduce into such an 
\begin_inset Quotes eld
\end_inset

unreachable
\begin_inset Quotes erd
\end_inset

 branch if a bad case is made.
 If this happens blame will be reflected back onto the specific problematic
 cast of the input.
\end_layout

\begin_layout Standard
When we internalize the notion of path we need to support path operations
 that correspond to each of operations used by the unification of the bidirectio
nal type system.
 Specifically we need to index into the arguments of data constructors,
 and data type constructors.
 We will also need to be able to reverse paths and concatenate paths since
 the unification algorithm implicitly uses these properties of equality.
 Finally we need new rules to remove casts from the endpoints of paths.
 For example, if 
\begin_inset Formula $A::B=C$
\end_inset

 then 
\begin_inset Formula $A=C$
\end_inset

 except for possible miscasts in 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Standard
During elaboration, after a pattern is unified, we will inject the proofs
 of equality into the branch terms so that they cast check.
 this will require that our notion of paths is congruent.
 The most strait forward way to do this seems to be inserting an operator
 into the syntax that ensures that 2 expressions have the same behavoir.
 This operator will be linked to a path assertion and track the observation
 locally.
\end_layout

\begin_layout Standard
These observations allow for observations that were impossible before.
 we can now observe specific arguments in type constructors and tern constructor
s.
 Since function terms can appear directly in data type constructors it is
 now possible to observe functions directly.
\end_layout

\begin_layout Standard
How should these new syntaxes interact with each-other? Since every term
 level equivalence will be bound to a specific assertion there will only
 ever be a finite combination to deal with, though inelegant (and inefficient)
 we can keep track of an array of casts covering every possible assumption.
 Then we can commute equivalences in a plausible way.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
rearange
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For instance if the user case matches the head of 
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $Vec\,A\,(Sn)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <_:Vec Bool (S n) => Bool> {
\end_layout

\begin_layout Plain Layout

| Cons _ a _ _ => a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What can go wron in the presence of casts?
\end_layout

\begin_layout Itemize
\begin_inset Formula $x$
\end_inset

 a fualt cast assumtion may have made 
\begin_inset Formula $x$
\end_inset

 apear to be a Vector even when it is not.
 for instance True:: Vec Bool 3
\end_layout

\begin_layout Itemize
the vector may be empty but cast to look like it is inhabited.
 for instance Nil Bool :: Vec Bool 5
\end_layout

\begin_layout Itemize
the vector may have a type that is not Bool.
 for instance Cons Nat 3 ...
 ...
 :: Vec Bool 5
\end_layout

\begin_layout Standard
elaboration will perform unification resulting in the term
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x {
\end_layout

\begin_layout Plain Layout

| Cons _ a _ _ :: p => a::InTc0(p)
\end_layout

\begin_layout Plain Layout

| Nil _ :: p => !InTc1(p)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
if the case tries to eliminate True:: Vec Bool 3, teh constructor is not
 mached so the fualty assumption can be blamed
\end_layout

\begin_layout Itemize
if teh scrutinee is empty, we will fall into the Nil branch, which will
 reflect the underlieig fualty assumption, via the explicit blame syntax
\end_layout

\begin_layout Itemize
if the vector is inhabited by an incorrect type, it will return 3:: Bool
 with the a cast that rests on the faulty assumption of Vec Nat 5=Vec Bool
 5.
 if checking is extended to CBV it will fail imediately, If checking is
 not done by name, the blame will be discoverd whenever the result is matched.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
rearange
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider the more involved example that sums the first 2 numbers of a vector
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <_:Vec Nat 2 => Nat> {
\end_layout

\begin_layout Plain Layout

| Cons _ i _ (Cons _ j _ _) => i+j
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the elaboration procedure will produce
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x {
\end_layout

\begin_layout Plain Layout

| (Cons Nat' i n' (Cons Nat'' j n'' rest):: p1):: p2 => i::InTc0(p2) + j::(InTc0
(p1).InTc0(p2))
\end_layout

\begin_layout Plain Layout

| (Nil Nat') :: p => !InTc1(p)
\end_layout

\begin_layout Plain Layout

| (Cons Nat' i n' (Nil Nat''):: p1):: p2 => !InTc1(p1).InTc1(p2) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
in the first branch we have, p1 : Vec Nat'' (S n'') = Vec Nat' n', p2 :
 Vec Nat' (S n') = Vec Nat 2, i:Nat', j:Nat''
\end_layout

\begin_deeper
\begin_layout Itemize
this means we can deduce InTc0(p2) : Nat' = Nat, and InTc0(p1) InTc0(p2)
 : Nat'' = Nat
\end_layout

\end_deeper
\begin_layout Itemize
in teh 2nd branch, p : Vec Nat' 0 = Vec Nat' 2
\end_layout

\begin_deeper
\begin_layout Itemize
wich is unsatisifable, by InTc1(p) : 0 = 2
\end_layout

\end_deeper
\begin_layout Itemize
in teh 3rd branch, p1 : Vec Nat'' 0 = Vec Nat' n', p2 : Vec Nat' (S n')
 = Vec Nat 2
\end_layout

\begin_deeper
\begin_layout Itemize
wich is unsatisfiable by InTc1(p1) InTc1(p2) : 0 = 2.
 We don't need to know which path is problematic beforehand, only that the
 combination cuases trouble.
\end_layout

\end_deeper
\begin_layout Standard
We know from unification what the type and value of ever tem is suposed
 to be, so casts can be injected using evidence from the pattern
\end_layout

\begin_layout Standard
But there are more complicated possiblities consider
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <_:Id Nat 2 2 => Vec Nat 2> {
\end_layout

\begin_layout Plain Layout

| refl _ a => rep a Nat 9
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
this will elaborate to
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x {
\end_layout

\begin_layout Plain Layout

| (refl Nat' a)::p => (rep (a::InTc0(p))):: Cong (?) x=> (A : *) -> A ->
 Vec Nat x
\end_layout

\begin_layout Plain Layout

   Nat 9
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
since we have p: Id Nat' a a = Nat 2 2, 
\end_layout

\begin_layout Standard
(a::InTc0(p)) casts a to a Nat but then we need to ecidence that (A : *)
 -> A -> Vec Nat (a::InTc0(p)) = (A : *) -> A -> Vec Nat 2
\end_layout

\begin_layout Standard
this means we fisr need congurence to select the portion of intrest .
 Ideally we would have a path from (a::InTc0(p)) = 2, but we only have a
 path (InTc1(p)): a = 2 .
 It is unclear how best to handle this
\end_layout

\begin_layout Itemize
have 2::InTc0(p) = 2 hold definitionally, but this is dubous becueas p can
 contain additional failures
\end_layout

\begin_layout Itemize
allow a different path constructor that allows casts to endpoints
\end_layout

\begin_layout Itemize
have 2::InTc0(p) be indestinguishable from 2 except for blame derived from
 p
\end_layout

\begin_layout Standard
of these the additional constructor sounds easiest to deal with.
\end_layout

\begin_layout Section
Cast
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

-- standard data in normal form, 3
\end_layout

\begin_layout Plain Layout

S (S (S 0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- cast data in normal form
\end_layout

\begin_layout Plain Layout

S (S (S 0) :: Nat ) :: Nat :: Nat :: Nat
\end_layout

\begin_layout Plain Layout

S (S (S 0) :: Nat ) :: Bool :: Nat
\end_layout

\begin_layout Plain Layout

True :: Nat
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- cast pattern matching
\end_layout

\begin_layout Plain Layout

case x <_ => Bool> {
\end_layout

\begin_layout Plain Layout

| (Z :: _) => True
\end_layout

\begin_layout Plain Layout

| (S (Z :: _) :: _) => True
\end_layout

\begin_layout Plain Layout

| (S (S :: _) :: _) => False
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- extract specific blame,
\end_layout

\begin_layout Plain Layout

-- c is a path from Bool~Nat
\end_layout

\begin_layout Plain Layout

case x <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| (S ((true::c)::_) :: _) =>
\end_layout

\begin_layout Plain Layout

 add (false :: c) 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- can reconstitute any term,
\end_layout

\begin_layout Plain Layout

-- not always possible with unification
\end_layout

\begin_layout Plain Layout

-- based pattern matching
\end_layout

\begin_layout Plain Layout

case x <_:Nat => Nat> {
\end_layout

\begin_layout Plain Layout

| (Z :: c) => Z :: c
\end_layout

\begin_layout Plain Layout

| (S x :: c) => S x :: c
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- direct blame
\end_layout

\begin_layout Plain Layout

case x <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| (S (true::c) :: _) => Bool =/=c Nat
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peek x =
\end_layout

\begin_layout Plain Layout

case x <_: Id Nat 0 1 => Nat> {
\end_layout

\begin_layout Plain Layout

  | (refl x :: _) => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peek (refl 4 :: Id Nat 0 1) = 4
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Pattern Matching
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-pattern-matching"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
to stylize consistently, should use math font, or like a nice image
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Revise into the above
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% direct blame
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

It makes sense to further extend the cast syntax so that blame can be invoked
 directly by a path.
 For example, in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-pattern-matching"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Branches set up in this way prove their 
\begin_inset Quotes eld
\end_inset

unreachability
\begin_inset Quotes erd
\end_inset

 by using their input to generate blame.
 Once direct blame is added it makes sense to allow operations on paths,
 such as concatenation, and reverse so that more proofs of inequality are
 possible.
 Proofs of inequality can be further helped by inspecting the arguments
 of type constructors and data constructors.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the extended path syntax.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% This seems to require heavy modifications to the cast syntax
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Extending the syntax in this way complicates the type system and the reduction
 rules.
 We include a sample of our reduction rules in .
 We conjecture that these extensions support all of our expected properties.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Conruence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
dangly bits
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
sumstution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="34" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path var,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion index,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion assumption, 
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kin$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k=left$
\end_inset

 | 
\begin_inset Formula $k=right$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
casts under assumption, 
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{\overline{kin,}p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path exp.,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p,p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concrete assumption
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{p\circ}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concatinated paths
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastL_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remove
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastR_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
remove
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $castL_{kcast}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $castR_{kcast}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast pattern,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $patc$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $d\,\overline{patc}::_{x_{p}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast expression,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
force blame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ a\sim_{k,o,\ell}b\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
asert same
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
steal path syntax from CTT?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
extend H ctxs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Data
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
abrevations, 
\end_layout

\begin_layout Standard
empty path 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
= refl
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
p = refl 
\backslash
circ p
\end_layout

\begin_layout Standard
\begin_inset Formula $uncastL_{kcast}\,p$
\end_inset

 as repeted 
\begin_inset Formula $castL_{kcast}\,p$
\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
cbv reductions
\end_layout

\begin_layout Standard
path reductions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{C\ \mathbf{Val}}{Assert_{k\Rightarrow C}\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
not actually this more restictions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}\quad q\ \mathbf{Val}}{q\circ p\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{kcast\ \mathbf{Val}}{uncastL_{kcast}\,\left(refl\right)\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{kcast\ \mathbf{Val}}{uncastR_{kcast}\,\left(refl\right)\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\:\mathbf{whnf}\quad b\:\mathbf{whnf}\quad\mathbf{head}\,a\neq\mathbf{head}\,b}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left\{ a\sim_{k,o,\ell}b\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
..
 extracted from each sensable place
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{C\rightsquigarrow C'}{Assert_{k\Rightarrow C}\rightsquigarrow Assert_{k\Rightarrow C'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{p\circ Assert_{-\Rightarrow\star}\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{q\circ refl\circ p\rightsquigarrow q\circ p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\quad}{\left(q\circ p\right)^{-1}\rightsquigarrow p^{-1}\circ q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'}{p\circ q\rightsquigarrow p\circ q'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{p\circ q\rightsquigarrow p'\circ q}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(Assert_{k\Rightarrow C}\right)^{-1}\rightsquigarrow Assert_{k\Rightarrow\mathbf{Swap}_{k}C}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(p\circ Assert_{k\Rightarrow D\overline{A}}\right)\rightsquigarrow inTC_{i}\left(p\right)\circ Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(p\circ Assert_{k\Rightarrow d\overline{A}}\right)\rightsquigarrow inC_{i}\left(p\right)\circ Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{kcast\rightsquigarrow kcast'}{castL_{kcast}\rightsquigarrow castL_{kcast'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(p\circ castL_{refl}\right)\rightsquigarrow inTC_{i}\left(p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(p\circ castL_{D...}\right)\rightsquigarrow inTC_{i}\left(p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
remove
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{kcast\rightsquigarrow kcast'}{uncastL_{kcast}\,p\rightsquigarrow uncastL_{kcast'}\,p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{kcast\rightsquigarrow kcast'}{uncastR_{kcast}\,p\rightsquigarrow uncastR_{kcast'}\,p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{uncastL_{refl}p\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{uncastR_{refl}p\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
remove path value restrictions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO review this
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{remove\,k=left\,casts\quad a\:\mathbf{whnf}}{uncastL_{kcast}\,\left(Assert_{k\Rightarrow a::kcast'}\right)\rightsquigarrow Assert_{k\Rightarrow a::kcast''}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{remove\,k=left\,casts\quad a\:\mathbf{whnf}}{castL_{kcast}\,\left(Assert_{k\Rightarrow a::kcast'}\right)\rightsquigarrow Assert_{k\Rightarrow a::kcast''}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
probly need to modify substution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{refl^{-1}\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
assumption reductions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{\begin{array}{c}
kcast\\
\overline{kin,}p;\\
kcast'
\end{array}\rightsquigarrow\begin{array}{c}
kcast\\
\overline{kin,}p';\\
kcast'
\end{array}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\rightsquigarrow a'}{a::kcast\rightsquigarrow a'::kcast}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{kcast\rightsquigarrow kcast'}{a::kcast\rightsquigarrow a::kcast'}
\]

\end_inset


\end_layout

\begin_layout Standard
term redcutions
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{!_{p}\rightsquigarrow!_{p'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ a::\begin{array}{l}
kcast\\
\overline{kin,}p\circ Assert_{k\Rightarrow C};\\
kcast'
\end{array}\sim_{k,o,\ell}b\right\} \rightsquigarrow\left\{ a::\begin{array}{c}
kcast\\
\overline{kin,}p;\\
kcast'
\end{array}\sim_{k,o,\ell}b\right\} ::\overline{kin,}k=left\,Assert_{k\Rightarrow C};}
\]

\end_inset


\end_layout

\begin_layout Standard
symetric around 
\begin_inset Formula $\sim$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \star\sim_{k,o,\ell}\star\right\} \rightsquigarrow\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \left(x:A\right)\rightarrow B\sim_{k,o,\ell}\left(x:A'\right)\rightarrow B'\right\} \rightsquigarrow\left(x:\left\{ A\sim_{k,o.arg,\ell}A'\right\} \right)\rightarrow\left\{ B\sim_{k,o.bod\left[x\right],\ell}B'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \mathsf{fun}\,f\,x\Rightarrow b\sim_{k,o,\ell}\mathsf{fun}\,f\,x\Rightarrow b'\right\} \rightsquigarrow\mathsf{fun}\,f\,x\Rightarrow\left\{ b\sim_{k,o.app\left[x\right],\ell}b'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ d\overline{a}\sim_{k,o,\ell}d\overline{a'}\right\} \rightsquigarrow d\overline{\left\{ a_{i}\sim_{k,o.o.DCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ D\overline{a}\sim_{k,o,\ell}D\overline{a'}\right\} \rightsquigarrow D\overline{\left\{ a_{i}\sim_{k,o.o.TCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a::\overline{\overline{kin,};}\rightsquigarrow a}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{pointwise\ concatination}{\left(a::\overline{\overline{kin,p};}\right)::\overline{\overline{kin',p'};}\rightsquigarrow...}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)b\rightsquigarrow\left(\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)\left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right)::kin,Assert_{k\Rightarrow B\left[x\coloneqq\left\lfloor \left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right\rfloor _{k=kin}\right]};}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Match\,\overline{a}\,patc_{i}}{\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc_{i}\Rightarrow}b_{i}}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} \rightsquigarrow b_{i}\left[patc_{i}\coloneqq\overline{a}\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
probly need to modify substution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
need to account for the casts being bundles?
\end_layout

\begin_layout Standard

\series bold
Conjecture
\series default
 there is a suitable definitional equality 
\begin_inset Formula $\equiv$
\end_inset

 such that
\end_layout

\begin_layout Itemize
\begin_inset Formula $\equiv$
\end_inset

 is an equivelence
\end_layout

\begin_layout Itemize
\begin_inset Formula $a\rightsquigarrow_{*}b$
\end_inset

 and 
\begin_inset Formula $a'\rightsquigarrow_{*}b$
\end_inset

 implies 
\begin_inset Formula $a\equiv a'$
\end_inset


\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $\mathbf{head\ }a\neq\mathbf{head}\ b$
\end_inset

 then 
\begin_inset Formula $a\cancel{\equiv}b$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{x_{p}:A\thickapprox A'\in H}{HK\vdash x_{p}:A\thickapprox A'}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK,k=left\vdash C:\star\quad HK,k=right\vdash C:\star}{HK\vdash Assert_{k\Rightarrow C}:\left\lfloor C\right\rfloor _{k=left}\thickapprox\left\lfloor C\right\rfloor _{k=right}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
is this ok?
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash A:\star}{HK\vdash refl:A\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
A ok.
 A type is too restrictive
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:A\thickapprox B\quad HK\vdash q:B\thickapprox C}{HK\vdash p\,q:A\thickapprox C}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
needs to conv the ends
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:b\thickapprox b\quad H,K\vdash b:B\quad H,K\vdash b':B\quad H,x:B,K\vdash A}{HK\vdash cong_{x\Rightarrow a}p:a\left[x\coloneqq b\right]\thickapprox a\left[x\coloneqq b'\right]}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{}{HK\vdash castL_{kcast}:A::kcast\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
A ok
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:A\thickapprox B}{HK\vdash p^{-1}:B\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:D\,\overline{a}\thickapprox D\,\overline{b}}{HK\vdash inTC_{i}\,p:a_{i}\thickapprox b_{i}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:d\,\overline{a}\thickapprox d\,\overline{b}}{HK\vdash inC_{i}\,p:a_{i}\thickapprox b_{i}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
remove these rules
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:\ A::kcast\thickapprox B\quad A\:\mathbf{whnf}}{HK\vdash uncastL_{kcast}\,p:A\thickapprox B}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:\ B\thickapprox A::kcast\quad A\:\mathbf{whnf}}{HK\vdash uncastR_{kcast}\,p:B\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
how to best remove teh cast
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
remove this questionable thing?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:\ b\thickapprox a\quad HK\vdash a:A\quad HK\vdash kcast:\ A\thickapprox A\quad}{HK\vdash castR_{kcast}\,p:B\thickapprox A::kcast}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{k=left\in K\quad HK\vdash a:A}{HK\vdash\left\{ a\sim_{k,o,\ell}b\right\} :A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{k=right\in K\quad HK\vdash b:B}{HK\vdash\left\{ a\sim_{k,o,\ell}b\right\} :B}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{kin_{i}\subset K\quad HK\vdash a:A\quad HK\vdash p_{i}:A\thickapprox B}{HK\vdash a::\overline{kin_{i},}p_{i}|:B}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
HK\vdash\overline{a}:\Delta\\
H,\Delta,K\vdash B:\star\\
\forall\:i\,\left(HK\vdash\overline{pat}_{i}:\Delta\quad H,\left(\overline{pat}_{i}:\Delta\right)K\vdash b_{i}:B\right)\\
\forall\:j\,\left(HK\vdash\overline{pat}_{j}:\Delta\right)\\
HK\vdash\overline{\overline{patc}}\,\overline{\overline{patc'}}:\Delta\ \mathbf{complete}
\end{array}}{\begin{array}{c}
HK\vdash\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc_{i}\Rightarrow}b_{i}}\overline{|\,\overline{patc'_{j}\Rightarrow}!_{\ell}}\right\} \\
:M\left[\Delta\coloneqq\overline{n}\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
HK\vdash C:\star\\
HK\vdash p:A\thickapprox B\\
A\:\mathbf{whnf}\quad B\:\mathbf{whnf}\\
\mathbf{Head}(A)\neq\mathbf{Head}(B)
\end{array}}{HK\vdash!_{p}\ :C}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language typing and pathing rukes
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
technically speaking, telescopes should generalize to the different syntactic
 classes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
not sure it's good to have paths be quantifiable?it will never come up in
 elabvoration.
 try it now for simplicity 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{HK\,\mathbf{ok}}{HK\vdash\lozenge:.}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H,x:A;K\vdash\Delta\quad H;K\vdash A:\star\quad H;K\vdash patc:\Delta}{HK\vdash x,patc\::\:\left(x:A\right)\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
d\,:\,\varTheta\rightarrow D\overline{b}\in H\\
HK\vdash\overline{patc'}:\varTheta\\
H,\left(\overline{patc'}:\varTheta\right),x_{p}:D\overline{b}\thickapprox D\overline{a},K\vdash patc:\Delta\left[x\coloneqq d\,\overline{patc'}::_{x_{p}}\right]
\end{array}}{HK\vdash d\,\overline{patc'}::_{x_{p}},patc\::\:\left(x:D\overline{a}\right),\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
as a matter of convineince we will allow well formed patterns to be appended
 to their relevient ctx.
\end_layout

\begin_layout Standard

\series bold
Conjecture
\series default
 The cast system preseves types and paths over normalization
\end_layout

\begin_layout Standard

\series bold
Conjecture
\series default
 a well typed path in an empty context is a value, takes a step, or produces
 blame
\end_layout

\begin_layout Standard

\series bold
Conjecture
\series default
 A well typed term in an empty context is a value, takes a step, or produces
 blame
\end_layout

\begin_layout Part
Elaborating Eliminations
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% elaboration unification
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

To make the overall system behave as expected we do not want to expose users
 to equality patterns, or force them to manually do the path bookkeeping.
 To work around this we extend a standard unification algorithm to cast
 patterns with instrumentation to remember paths that were required for
 the solution.
 Then if pattern matching is satisfiable, compile additional casts into
 the branch based on its assignments.
 Unlisted patterns can be checked to confirm they are unsatisfiable.
 If the pattern is unsatisfiable then elaboration can use the proof of unsatisfi
ability to construct explicit blame.
 If an unlisted pattern cannot be proven 
\begin_inset Quotes eld
\end_inset

unreachable
\begin_inset Quotes erd
\end_inset

 then we could warn the user, and like most functional programming languages,
 blame the incomplete match if that pattern ever occurs.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

can
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

could
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, weasel word until implemented
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
add rules of unification? the rules as implemented are standard, needing
 extended normalization is weird
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We found that our normalization procedure (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-red"
plural "false"
caps "false"
noprefix "false"

\end_inset

) unexpectedly blocked unification.
 This is because the normalization is conservative about throwing away casts
 that could later lead to errors.
 For instance, with normalization, unification will get stuck on terms like
 
\begin_inset Formula $x::_{\mathbb{N}}\mathbb{N}=5$
\end_inset

.
 Thus we employ a more optimistic normalization procedure that will collapse
 casts that are equivalent
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
the exact equivalence is unprincipled and hacky.
 But all of dependent pattern matching is unprincipled and hacky.
 I can't actually contrive a situation where this could be an issue, but
 feel like it needs to be mentioned.
\end_layout

\end_inset

 Thus 
\begin_inset Formula $x::_{\mathbb{N}}\mathbb{N}\overset{::}{\rightsquigarrow}x$
\end_inset

 allows us to solve the unification problem and assign 
\begin_inset Formula $x:=5$
\end_inset

.
 This approach has worked well so far.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% more modifications
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

In order to make the additional casts generated from unification we further
 extend the cast construct so it supports congruence.
 For instance, if 
\begin_inset Formula $x$
\end_inset

 has type 
\begin_inset Formula $Vec\,y\,z$
\end_inset

 and the unification procedure established 
\begin_inset Formula $y:=Bool$
\end_inset

 and 
\begin_inset Formula $z:=5$
\end_inset

 then we should cast 
\begin_inset Formula $x::Vec\,Bool\,5$
\end_inset

.
 Unlike in Section 3 this requires that we use evidence to inject a cast
 within a type.
 This can be done inherently by adding an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

untyped
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

 component to the cast annotation.
 The syntax that achieves this can be seen in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO example axiom k?
\end_layout

\end_inset


\end_layout

\begin_layout Part
Related work
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/thesis/bibliography/dtest"
options "alpha"

\end_inset


\end_layout

\begin_layout Part
TODO
\end_layout

\begin_layout Standard
CBV
\end_layout

\begin_layout List of TODOs

\end_layout

\begin_layout Section
notes
\end_layout

\begin_layout Standard
there are several simpler systems that can be worked through: eliminator
 style patterns, cast patterns, but to bring it all together we need congruence
 over functions.
\end_layout

\begin_layout Standard
adding paths and path variables means that constructs can still fail at
 runtime, but they can blame the actually problematic components
\end_layout

\begin_layout Standard
validating the K axiom, not that equalities are unique, merely that we don't
 care which one of the unique equalities is used.
\end_layout

\begin_layout Section
unused
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{HK\vdash A:\star}{HK\vdash x:A}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma,x:M\vdash\Delta\quad\Gamma\vdash m:M\quad\Gamma\vdash\overline{n}\left[x\coloneqq m\right]:\Delta\left[x\coloneqq m\right]}{\Gamma\vdash m,\overline{n}\,:\,x:M,\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\,:\,\Delta\rightarrow*}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma}{\Gamma\vdash d\,:\,\varTheta\rightarrow D\overline{m}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{HK\vdash x:A}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash A:\star}{H\vdash refl:A\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash B:\star\quad H,x:B\vdash C:\star\quad H\vdash b:B\quad H\vdash b':B\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv A'}{H\vdash A_{\ell.x\Rightarrow C}A':A\thickapprox A'}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT, would then need to resolve endpoint def equality
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash a':A\quad H,x:A\vdash C:\star}{H\vdash assert_{\ell.(a=a':A).x\Rightarrow C}:C\left[x\coloneqq a\right]\thickapprox C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash p:A\thickapprox B\quad H\vdash p':B\thickapprox C}{H\vdash p\,p':A\thickapprox C}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash p:A\thickapprox B}{H\vdash rev\,p:B\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Standard
typing rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash C:\star\quad H\vdash p:A\thickapprox B\quad AandBDisagree}{H\vdash A\neq_{p}B:C}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H,x:B\vdash C:\star\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv B}{H\vdash a::_{A,\ell.x\Rightarrow C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash a':A\quad H,x:A\vdash C:\star\quad H\vdash a:c\left[x\coloneqq a\right]}{H\vdash c::_{\ell\left(a=a':A\right).x\Rightarrow C}\quad:C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT remove concrete casts and merely use a symbolic cast instead?
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H,x:B\vdash C:\star\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv B\quad p:b\thickapprox b'}{H\vdash a::_{A,p.x\Rightarrow C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash c:C\left[x\coloneqq a\right]\quad H,x:A\vdash C:\star\quad H\vdash p:a\thickapprox a'}{H\vdash c::_{p.x\Rightarrow C}\quad:C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
H\vdash\overline{a}:\Delta\\
H,\Delta\vdash B:\star\\
\forall\:i\,\left(H\vdash Gen\left(\overline{patc}_{i}:\Delta,\Theta\right)\quad\Gamma,\Theta\vdash m:M\left[\Delta\coloneqq\overline{patc}_{i}\right]\right)\\
H\vdash\overline{\overline{patc}}:\Delta\ \mathbf{complete}
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{a,}\,\left\langle \overline{\Delta\Rightarrow}B\right\rangle \left\{ \overline{|\,\overline{patc\Rightarrow}b}\right\} \\
:M\left[\Delta\coloneqq\overline{n}\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
Gen is defined as 
\begin_inset Formula 
\[
\frac{\,}{H\vdash Gen\left(.:.,.\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\sim H\vdash A:\star\sim}{H\vdash Gen\left(x:(x:A),\;x:A\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\sim H\vdash A:\star\sim}{H\vdash Gen\left(x:A,\;x:A\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{d\,:\,\varTheta\rightarrow D\overline{a}\in H\quad H\vdash Gen\left(\overline{pat_{c}}:\varTheta,\Delta\right)}{H\vdash Gen\left(d\overline{pat_{c}}::_{x_{p}}:D\overline{b},\;\Delta,x_{p}:D\overline{a}\thickapprox D\overline{b}\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash Gen\left(pat_{c}:A,\Theta\right)\quad H,\Theta\vdash Gen\left(\overline{pat_{c}}:\Delta\left[x\coloneqq pat_{c}\right],\Theta'\right)}{H\vdash Gen\left(pat_{c}\overline{pat_{c}}:\left(x:A,\Delta\right),\Theta\Theta'\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
other rules similar to the surface lang
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
old style red rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{rev\,\left(p\,p'\right)\rightsquigarrow\left(rev\,p'\right)\left(rev\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inTC_{i}\,\left(p\,p'\right)\rightsquigarrow\left(inTC_{i}\,p'\right)\left(inTC_{i}\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(p\,p'\right)\rightsquigarrow\left(inC_{i}\,p'\right)\left(inC_{i}\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inTC_{i}\,refl\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,refl\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{a}_{i}=a'\;\overline{c}_{i}=c'\;\overline{b}_{i}=b'}{inTC_{i}\,\left(D\,\overline{a}_{\ell.D\,\overline{c}}D\,\overline{b}\right)\rightsquigarrow a'_{\ell.c'}b'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(\left(a::A\right)_{\ell.c}b\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(a_{\ell.c}\left(b::B\right)\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(a_{\ell.\left(c::C\right)}b\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\overline{a}_{i}=a'\;\overline{c}_{i}=c'\;\overline{b}_{i}=b'}{inTC_{i}\,\left(d\,\overline{a}_{\ell.d\,\overline{c}}d\,\overline{b}\right)\rightsquigarrow a'_{\ell.c'}b'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a::_{A,p\,refl,x.C}B\rightsquigarrow a::_{A,p,x.C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\begin{array}{c}
a::_{A,p\,A'_{\ell.C''}B',x.C}B\rightsquigarrow\\
a::_{A,p,x.C}C\left[x\coloneqq A'\right]::_{\ell.C\left[x\coloneqq C''\right]}C\left[x\coloneqq B'\right]
\end{array}c}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
c?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left(a::_{A,p,x.C}C\right)\sim_{\ell o}b\rightsquigarrow a\sim_{\ell o}b}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a\sim_{\ell o}\left(b::_{B,p,x.C}C\right)\rightsquigarrow a\sim_{\ell o}b}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="33" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path var,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion index,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kin$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k=left$
\end_inset

 | 
\begin_inset Formula $k=right$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
casts under assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{\overline{kin,}p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path exp.,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p,p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concrete cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $refl$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\begin_inset Formula $p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastL_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastR_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast pattern,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $patc$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $d\,\overline{patc}::_{x_{p}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast expression,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
force blame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ a\sim_{k,o,\ell}b\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
asert same
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{C\rightsquigarrow C'}{Assert_{k\Rightarrow C}\rightsquigarrow Assert_{k\Rightarrow C'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{refl\,p\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{p\,refl\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\quad}{\left(q\,p\right)^{-1}\rightsquigarrow p^{-1}\,q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'\quad p}{q\,p\rightsquigarrow q'\,p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\ \mathbf{Val}\quad p\rightsquigarrow p'}{q\,p\rightsquigarrow q\,p'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(Assert_{k\Rightarrow C}\right)^{-1}\rightsquigarrow Assert_{k\Rightarrow\mathbf{Swap}_{k}C}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(Assert_{k\Rightarrow D\overline{A}}\right)\rightsquigarrow Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(Assert_{k\Rightarrow d\overline{A}}\right)\rightsquigarrow Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\end_layout

\begin_layout Standard
TODO review this
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{remove\,k=left\,casts\quad a\:\mathbf{whnf}}{uncastL\,\left(Assert_{k\Rightarrow a::\overline{\overline{kin,}p;}}\right)\rightsquigarrow Assert_{k\Rightarrow a::\overline{\overline{kin',}p';}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
probly need to modify substution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{refl^{-1}\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
TODO review this
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{uncastL\,\left(refl\right)\rightsquigarrow?}
\]

\end_inset


\end_layout

\begin_layout Standard
term redcutions
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{!_{p}\rightsquigarrow!_{p'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ a::\overline{\overline{kin,}p;}\overline{kin,}q\,Assert_{k\Rightarrow C};\overline{\overline{kin',}p';}\sim_{k,o,\ell}b\right\} \rightsquigarrow\left\{ a::\overline{\overline{kin,}p;}\overline{kin,}q;\overline{\overline{kin',}p';}\sim_{k,o,\ell}b\right\} ::\overline{kin,}k=left\,Assert_{k\Rightarrow C};}
\]

\end_inset


\end_layout

\begin_layout Standard
symetric around 
\begin_inset Formula $\sim$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \star\sim_{k,o,\ell}\star\right\} \rightsquigarrow\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \left(x:A\right)\rightarrow B\sim_{k,o,\ell}\left(x:A'\right)\rightarrow B'\right\} \rightsquigarrow\left(x:\left\{ A\sim_{k,o.arg,\ell}A'\right\} \right)\rightarrow\left\{ B\sim_{k,o.bod\left[x\right],\ell}B'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \mathsf{fun}\,f\,x\Rightarrow b\sim_{k,o,\ell}\mathsf{fun}\,f\,x\Rightarrow b'\right\} \rightsquigarrow\mathsf{fun}\,f\,x\Rightarrow\left\{ b\sim_{k,o.app\left[x\right],\ell}b'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ d\overline{a}\sim_{k,o,\ell}d\overline{a'}\right\} \rightsquigarrow d\overline{\left\{ a_{i}\sim_{k,o.o.DCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ D\overline{a}\sim_{k,o,\ell}D\overline{a'}\right\} \rightsquigarrow D\overline{\left\{ a_{i}\sim_{k,o.o.TCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a::\overline{\overline{kin,};}\rightsquigarrow a}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{pointwise\ concatination}{\left(a::\overline{\overline{kin,p};}\right)::\overline{\overline{kin',p'};}\rightsquigarrow...}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)b\rightsquigarrow\left(\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)\left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right)::kin,Assert_{k\Rightarrow B\left[x\coloneqq\left\lfloor \left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right\rfloor _{k=kin}\right]};}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Match\,\overline{a}\,patc_{i}}{\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc_{i}\Rightarrow}b_{i}}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} \rightsquigarrow b_{i}\left[patc_{i}\coloneqq\overline{a}\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}}{q\circ refl\circ p\rightsquigarrow q\circ p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}\quad q\ \mathbf{Val}}{\left(q\circ p\right)^{-1}\rightsquigarrow p^{-1}\circ q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'}{p\circ q\rightsquigarrow p\circ q'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\ \mathbf{Val}\quad p\rightsquigarrow p'}{p\circ q\rightsquigarrow p'\circ q}
\]

\end_inset


\end_layout

\end_body
\end_document
