#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xcolor}
\usepackage{tikz-cd}
\tikzcdset{%
    triple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure' 
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    quadruple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure'
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    Rrightarrow/.code={\tikzcdset{triple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}},
    RRightarrow/.code={\tikzcdset{quadruple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}}
}    
\newcommand*{\tarrow}[2][]{\arrow[Rrightarrow, #1]{#2}\arrow[dash, shorten >= 0.5pt, #1]{#2}}
\newcommand*{\qarrow}[2][]{\arrow[RRightarrow, #1]{#2}\arrow[equal, double distance = 0.25pt, shorten >= 1.28pt, #1]{#2}}
\end_preamble
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Chapter 4a (draft): Data and Pattern Matching in the Surface Language
\end_layout

\begin_layout Author
Mark Lemay
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
for the perposes of this draft seperating the 
\begin_inset Quotes eld
\end_inset

conventional stuff
\begin_inset Quotes erd
\end_inset

 from the new stuff? should it be recombined?
\end_layout

\end_inset


\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
clean up!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% why data?
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

User defined data is a core feature of a realistic programming language.
 Simple data types like 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

 and 
\begin_inset Formula $\mathtt{Bool}$
\end_inset

 are essential for organizing readable programs.
 In dependently typed languages, dependent data can represent mathematical
 predicates like equality.
 Dependent data can also be used to preserve invariants, like the length
 of a list in 
\begin_inset Formula $\mathtt{Vec}$
\end_inset

, or the 
\begin_inset Quotes eld
\end_inset

color
\begin_inset Quotes erd
\end_inset

 of a node in a red-black-tree.
 The church encoded data form Chapter 2 is unrealistically inconvenient
 and is especially implausible for an 
\begin_inset Quotes eld
\end_inset

easy to use
\begin_inset Quotes erd
\end_inset

 dependently typed programming language.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% However, the combination of user defined data and dependent types can
 be subtle.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%What data defs/ constructors
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% The langugae defined in this thesus uses data definitions like those found
 in systems like Agda and Coq.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A data definition is formed by a type constructor indexed by arguments,
 and a set of constructors that tag data and characterize their arguments.
 See Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-defs"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the definitions of several standard data types.
 Data defined in this style is easy to build and reason about, since data
 can only be created from its constructors.
 Unfortunately data elimination is more murky.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

data Bool : * {
\end_layout

\begin_layout Plain Layout

| True : Bool
\end_layout

\begin_layout Plain Layout

| False : Bool
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

data Nat : * {
\end_layout

\begin_layout Plain Layout

| Z : Nat
\end_layout

\begin_layout Plain Layout

| S : Nat -> Nat
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

-- Syntactic sugar expands decimal numbers
\end_layout

\begin_layout Plain Layout

-- into their unary representation.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data Vec : (A : *) -> Nat -> * {
\end_layout

\begin_layout Plain Layout

| Nil  : (A : *) -> Vec A Z
\end_layout

\begin_layout Plain Layout

| Cons : (A : *) -> A -> (x : Nat)
\end_layout

\begin_layout Plain Layout

        -> Vec A x -> Vec A (S x)
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

data Id : (A : *) -> A -> A -> * {
\end_layout

\begin_layout Plain Layout

| refl  : (A : *) -> (a : A) -> Id A a a
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% include if notation is used
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% -- Syntactic sugar expands list notation,
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% -- for example
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% -- [True, False]<Bool> =
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% -- Cons Bool True 1 (Cons Bool False 1 (Nil Bool))
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Caption Standard

\begin_layout Plain Layout
Definitions of Common Data Types
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:data-defs"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Data and direct elimination
\end_layout

\begin_layout Standard
How should data be used? Since the term of a given type can only be created
 from one of a few constructors, we can completely handle data of a type
 if each sonstructor is acconted for.
 For instance, Nat has the two constructors Z and S (which holds the preceding
 number), so teh expression 
\begin_inset Formula $\mathsf{case}\,n\,\left\{ |\,Z\Rightarrow Z\,|\,S\,x\Rightarrow x\right\} $
\end_inset

 will extract teh preceeding number from 
\begin_inset Formula $n$
\end_inset

(or 
\begin_inset Formula $0$
\end_inset

 if 
\begin_inset Formula $n=0$
\end_inset

).
 In this light, boolean case eleimination is corresponds to an if-then-else
 expression.
 This style of case elimination is pervasive in ML style langugaes and has
 become popular in more mainstrame languages such as Python and Java
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
double check and perhaps not restricitons
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We will need to extend the syntax above to support realistic dependent type
 checking.
 Specifically, we will need to add a motive that allows the type checker
 to compute the output type of the branches if the very in terms of the
 input.
 For insance, recursively generating a vector of a given length.
 We may also want to use some values of teh type level argument to calculate
 the motive, and type the branches.
 this will be allowed with additional bindings in the motive and in each
 branch
\begin_inset Foot
status open

\begin_layout Plain Layout
This slightly awkward case eliminator syntax is designed to be forward compatibl
e with the pattern matching system defined in the rest of this chapter,
 which in turn allows function definition by cases.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This version of data can be given by extending the surface language syntax
 in Chapter 2, as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-defs"
plural "false"
caps "false"
noprefix "false"

\end_inset

 .
 This direct eliminator scheme, is similar to how Coq handles data in it's
 core language.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="23" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
telescope,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Delta,\varTheta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $.$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
empty telescope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x:M,\,\Delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extend telescope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
list of 
\begin_inset Formula $O$
\end_inset

, separated with 
\begin_inset Formula $s$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{sO}$
\end_inset

,
\begin_inset Formula $\overline{Os}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $s$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
empty list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $sO\overline{sO}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extend list
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data type identifier,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data constructor identifier,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
contexts,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma,\mathsf{data}\,D\,:\,\Delta\rightarrow*\,\left\{ \overline{|\,d\,:\,\varTheta\rightarrow D\overline{m}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data def extension
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma,\mathsf{data}\,D\,:\,\Delta\rightarrow*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
abstract data extension
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m,n,M,N$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{N,}n\,\left\{ \overline{|\overline{x\Rightarrow}(d\,\overline{y})\Rightarrow m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 without motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{N,}n\,\left\langle \overline{x\Rightarrow}y:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\overline{x\Rightarrow}(d\,\overline{y})\Rightarrow m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 with motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D\,\overline{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d\,\overline{v}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
short hands
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Data
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-min"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
ebnf? if reinventing it underline
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
differentiate identifiers with font
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
motive should not need to insist on the type info of the binder? grey out?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Grey out things that are surface syntax but not needed for theory
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Make identifiers consistent with chapter 2, and locations in chapter 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The case eliminator first takes the explicit type arguments, followed by
 a scrutinee of correct type.
 Then optionally a motive that characterizes the output type of each branch
 with all the type arguments and scrutiny abstracted and in scope.
 For instance, this case expression checks if a vector 
\begin_inset Formula $x$
\end_inset

 is empty,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x:Vec\,\mathbb{B}\,1\vdash\mathsf{case}\,\mathbb{B},1,x\,\left\langle y\Rightarrow z\Rightarrow s:Vec\,y\,z\Rightarrow\mathbb{B}\right\rangle \left\{ |y\Rightarrow z\Rightarrow Nil\,-\Rightarrow True\,|\,y\Rightarrow z\Rightarrow Cons\,----\Rightarrow False\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Additionally we define telescopes, which generalize 0 or more typed bindings.
 This allows us to set up data definitnions in a clean way.
 Also we define syntactic lists, when syntax is listed it can be used to
 generalize dependent pairs, this becomes helpfule wehn we need to extract
 the applide arguments of a constructor.
\end_layout

\begin_layout Standard
In the presence of general recursion this form of case eliminator is very
 expressive.
 Well-founded recursion can be used to make structurally inductive computations
 that can be interperted as proofs.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
abbreviate away dumb arrows, unstated separator is a space, also usual syntax
 (:*)? also shorthands for telescopes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
define a closed context
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Adding data allows for two additional sources of bad behavior.
 In-exhaustive matches, and non strictly positive data.
\end_layout

\begin_layout Section
Incomplete Eliminations
\end_layout

\begin_layout Standard
Consider the match 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x:\mathbb{N}\vdash\mathsf{case}\,x\,\left\langle s:\mathbb{N}\Rightarrow\mathbb{B}\right\rangle \left\{ |S-\Rightarrow True\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
this match will get stuck if 
\begin_inset Formula $0$
\end_inset

 is substitutted for 
\begin_inset Formula $x$
\end_inset

.
 Because it is easy to ensure all constructors are matched, the surface
 language type assignment system will require cases to be exhuastive.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Since this is a 
\begin_inset Quotes eld
\end_inset

well behaved
\begin_inset Quotes erd
\end_inset

 failure it is usually only a warning in other programming languges.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When we get to the cast language, we will allow in-exhaustive data to ber
 reported as an elaboration warning and that will allow 
\begin_inset Quotes eld
\end_inset

unmatched
\begin_inset Quotes erd
\end_inset

 errors to be observed at runtime.
\end_layout

\begin_layout Section
(non) Strict Positivity
\end_layout

\begin_layout Standard
A more subtle concern is posed by data definitions that are not strictly
 positive.
 
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Example!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This data can cause unexpected non-termination.
 Dependent types usually requires a strictness check to eliminate this possiblit
y.
 However this would block usfule constructions like higher order abstract
 synax, and co-inductive uses of data.
 Additionally since non-termination is already allowed in the surface TAS,
 we will not restrict ourselves to strictly positive date.
\end_layout

\begin_layout Section
Specification
\end_layout

\begin_layout Standard
The type assignment system must be extended with the rules in 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
telescopes are well formed
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}}{\Gamma\vdash.\,\mathbf{ok}}\,...
\]

\end_inset


\begin_inset Formula 
\[
\frac{\Gamma\vdash M:\star\quad\Gamma,x:M\vdash\Delta\,\mathbf{ok}}{\Gamma\vdash x:M,\Delta\,\mathbf{ok}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
suspect this also hinges on regularity
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}}{\Gamma\vdash\lozenge:.}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma,x:M\vdash\Delta\quad\Gamma\vdash m:M\quad\Gamma\vdash\overline{n}\left[x\coloneqq m\right]:\Delta\left[x\coloneqq m\right]}{\Gamma\vdash m,\overline{n}\,:\,\left(x:M\right),\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\,:\,\Delta\rightarrow*}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma}{\Gamma\vdash d\,:\,\varTheta\rightarrow D\overline{m}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
define these 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\in$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\in\Gamma\\
\Gamma\vdash n:D\overline{N}\\
\Gamma,\overline{x}:\Delta,z:D\,\overline{x}\vdash M:\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma.\quad\Gamma,\overline{x}:\Delta,\overline{y}_{d}:\varTheta\vdash m_{d}:M
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{N,}n\,\left\{ \overline{|\,\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} \\
:M\left[\overline{x}\coloneqq\overline{N},z\coloneqq n\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
don't need 
\begin_inset Formula $\Gamma\vdash\overline{N}:\Delta$
\end_inset

?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\in\Gamma\\
\Gamma\vdash\overline{N}:\Delta\quad\Gamma\vdash n:D\overline{N}\\
\Gamma,\overline{x}:\Delta,z:D\,\overline{x}\vdash M:\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma.\quad\Gamma,\overline{x}:\Delta,\overline{y}_{d}:\varTheta\vdash m_{d}:M
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{N,}n\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} \\
:M\left[\overline{x}\coloneqq\overline{N},z\coloneqq n\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
may not need scrut wf check? oh but what about the empty types!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\Delta\,\mathbf{ok}}{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\mathbf{ok}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\mathbf{ok}\quad\forall d.\Gamma,\mathsf{data}\,D\,\Delta\vdash\varTheta_{d}\,\mathbf{ok}\quad\forall d.\:\Gamma,\mathsf{data}\,D\,\Delta,\varTheta_{d}\vdash\overline{m}_{d}:\Delta}{\Gamma\vdash\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta_{d}\rightarrow D\overline{m}_{d}}\right\} \,\mathbf{ok}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
to ensure regularity
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\mathbf{ok}}{\Gamma,\mathsf{data}\,D\,\Delta\,\mathbf{ok}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta\rightarrow D\overline{m}}\right\} \,\mathbf{ok}}{\Gamma,\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta\rightarrow D\overline{m}}\right\} \,\mathbf{ok}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
red
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad\overline{m}\Rrightarrow\overline{m'}\\
\forall\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} .\:m_{d}\Rrightarrow m_{d}'\\
m_{d}\Rrightarrow m_{d}'
\end{array}}{\mathsf{case}\,\overline{N,}\,d\overline{m}\,\left\langle ...\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow\mathsf{case}\,\overline{N',}\,d\overline{m'}\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}'}\right\} }\,\textrm{\Rrightarrow-\mathsf{case}<>-red}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
it's actually kind of fine discriminating between non converting motives?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad\overline{m}\Rrightarrow\overline{m'}\\
\exists\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \\
m_{d}\Rrightarrow m_{d}'
\end{array}}{\mathsf{case}\,\overline{N,}\,d\overline{m}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow m_{d}'\left[\overline{x}\coloneqq\overline{N'},\overline{y}_{d}\coloneqq\overline{m'}\right]}\,\textrm{\Rrightarrow-\mathsf{case}-red}
\]

\end_inset


\end_layout

\begin_layout Standard
structural reductions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad m\Rrightarrow m'\\
M\Rrightarrow M'\\
\forall d.\:\overline{\Rightarrow x}\Rightarrow(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \\
m_{d}\Rrightarrow m_{d}'
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{N,}\,m\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow\\
\mathsf{case}\,\overline{N,}\,m'\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M'\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} 
\end{array}}\,\textrm{\Rrightarrow-\mathsf{case}<>}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad m\Rrightarrow m'\\
M\Rrightarrow M'\\
\forall d.\:\overline{\Rightarrow x}\Rightarrow(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \\
m_{d}\Rrightarrow m_{d}'
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{N,}\,m\,\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow\\
\mathsf{case}\,\overline{N,}\,m'\,\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} 
\end{array}}\,\textrm{\Rrightarrow-\mathsf{case}<>}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{m}\Rrightarrow\overline{m'}}{D\overline{m}\Rrightarrow D\overline{m'}}\,...
\]

\end_inset


\begin_inset Formula 
\[
\frac{\overline{m}\Rrightarrow\overline{m'}}{d\overline{m}\Rrightarrow d\overline{m'}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
extend reductions over lists
\end_layout

\end_inset


\end_layout

\begin_layout Standard
cbv
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\mathsf{case}\,\overline{N,}\,n\,\left\langle ...\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow\mathsf{case}\,\overline{N,}\,n\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\exists\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }{\mathsf{case}\,\overline{V,}\,d\overline{v}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow m_{d}\left[\overline{x}\coloneqq\overline{V},\overline{y}_{d}\coloneqq\overline{v}\right]}\,\textrm{\Rrightarrow-\mathsf{case}-red}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{n}\rightsquigarrow\overline{n'}}{\mathsf{case}\,\overline{V,}\,d\overline{n}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow\mathsf{case}\,\overline{V,}\,d\overline{n'}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }\,
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{N}\rightsquigarrow\overline{N'}}{\mathsf{case}\,\overline{N,}\,d\overline{n}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \rightsquigarrow\mathsf{case}\,\overline{N',}\,d\overline{n}\,\left\{ \overline{|\,\overline{x\Rightarrow}(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} }\,
\]

\end_inset


\end_layout

\begin_layout Standard
structural reductions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad m\Rrightarrow m'\\
M\Rrightarrow M'\\
\forall d.\:\overline{\Rightarrow x}\Rightarrow(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \\
m_{d}\Rrightarrow m_{d}'
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{N,}\,m\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow\\
\mathsf{case}\,\overline{N,}\,m'\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M'\right\rangle \left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} 
\end{array}}\,\textrm{\Rrightarrow-\mathsf{case}<>}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\overline{N}\Rrightarrow\overline{N'}\quad m\Rrightarrow m'\\
\forall d.\:\overline{\Rightarrow x}\Rightarrow(d\,\overline{y}_{d})\Rightarrow m_{d}\in\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \\
m_{d}\Rrightarrow m_{d}'
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{N,}\,m\,\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} \Rrightarrow\\
\mathsf{case}\,\overline{N,}\,m'\,\left\{ \overline{|\,\overline{\Rightarrow x}\Rightarrow(d'\,\overline{y}_{d'})\Rightarrow m_{d'}}\right\} 
\end{array}}\,\textrm{\Rrightarrow-\mathsf{case}<>}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{m}\rightsquigarrow\overline{m'}}{D\overline{m}\rightsquigarrow D\overline{m'}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
what about D? how much of a value should it be?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{m}\rightsquigarrow\overline{m'}}{D\overline{m}\rightsquigarrow D\overline{m'}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
extend step over lists
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While similar systems are explored in 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
Cite
\end_layout

\end_inset

, we will not prove the Type soundness of the system here.
 For clarity we will list it as a conjecture.
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the data aextention to the surface langugae is type sound.
\end_layout

\begin_layout Section
Bidirectional extension
\end_layout

\begin_layout Standard
A bidirectional interpretation exists over the type assignment rules listed
 above
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\overrightarrow{\,:\,}\Delta\rightarrow*}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma}{\Gamma\vdash d\overrightarrow{\,:\,}\varTheta\rightarrow D\overline{m}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
bidirectional non-dependent elimination
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\in\Gamma\\
\Gamma\vdash n\overrightarrow{\,:\,}D\overline{N}\\
\Gamma,\overline{x}:\Delta,z:D\,\overline{x}\vdash M\overleftarrow{\,:\,}\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma.\quad\Gamma,\overline{x}:\Delta,\overline{y}_{d}:\varTheta\vdash m_{d}\overleftarrow{\,:\,}M
\end{array}}{\Gamma\vdash\mathsf{case}\,n\,\left\{ \overline{|\,(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} \overleftarrow{\,:\,}M}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
tying information flows outside in.
\end_layout

\begin_layout Standard
bidirectional dependent elimination
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\mathsf{data}\,D\,\Delta\in\Gamma\\
\Gamma\vdash\overline{N}\overleftarrow{\,:\,}\Delta\quad\Gamma\vdash n\overleftarrow{\,:\,}D\overline{N}\\
\Gamma,\overline{x}:\Delta,z:D\,\overline{x}\vdash M\overleftarrow{\,:\,}\star\\
\forall\:d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma.\quad\Gamma,\overline{x}:\Delta,\overline{y}_{d}:\varTheta\vdash m_{d}\overleftarrow{\,:\,}M
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{,N},n\,\left\langle \overline{x\Rightarrow}z:D\,\overline{x}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{x\Rightarrow}(d\,\overline{y}_{d})\Rightarrow m_{d}}\right\} \\
\overrightarrow{\,:\,}M\left[\overline{x}\coloneqq\overline{N},z\coloneqq n\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
information flows from the inside out
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
may not need scrut wf check? oh but what about the empty types!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\Delta\,\overleftarrow{\mathbf{ok}}}{\Gamma\vdash\mathsf{data}\,D\,\Delta\,\overleftarrow{\mathbf{ok}}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
abuse of notation...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ok?
\begin_inset Formula $\Gamma\vdash\Delta\overleftarrow{\,:\,}\overline{\star}$
\end_inset

, perhaps 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma\vdash\Delta\,wf$
\end_inset

 and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma\vdash\Delta\,\overleftarrow{wf}$
\end_inset

 .
 or
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma\vdash\Delta\,\mathbf{ok}$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
...
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
or
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma\vdash\Delta\,\vdash$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
...
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
or 
\begin_inset Formula $\Gamma\,\mathbf{context}$
\end_inset

 , 
\begin_inset Formula $\Delta\,\mathbf{telescope}$
\end_inset

 as in 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset CommandInset citation
LatexCommand cite
key "cockx_devriese_2018"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
abuse of notation...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash\mathsf{data}\,D\,\Delta\quad\forall d.\Gamma,\mathsf{data}\,D\,\Delta\vdash\varTheta_{d}\quad\forall d.\:\Gamma,\mathsf{data}\,D\,\Delta,\varTheta_{d}\vdash\overline{m}_{d}:\Delta}{\Gamma\vdash\mathsf{data}\,D\,:\,\Delta\left\{ \overline{|\,d\,:\,\varTheta_{d}\rightarrow D\overline{m}_{d}}\right\} }\,...
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the data extention to the bidirectional surface langugae is type sound.
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
the data extention to the bidirectional surface langugae is weakly annotatatable
 from the data extention of the surface langugae.
\end_layout

\begin_layout Part
Pattern Matching
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% why pattern matching
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 Unfortunately, the eliminator style is cumbersome for programmers to deal
 with directly.
 For instance, in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:data-eliminators"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we show how 
\begin_inset Formula $\mathtt{Vec}$
\end_inset

 data can be directly eliminated in the definition of 
\begin_inset Formula $\mathtt{head'}$
\end_inset

.
 The 
\begin_inset Formula $\mathtt{head'}$
\end_inset

 function needs to redirect impossible inputs to a dummy type and requires
 several copies of the same variable that are not identified automatically
 by eliminators.
 Pattern matching is much more ergonomic than a direct eliminator, where
 variables will be assigned their definitions as needed, and unreachable
 branches can be omitted from code.
 For this reason, pattern matching has been considered an 
\begin_inset Quotes eld
\end_inset

essential
\begin_inset Quotes erd
\end_inset

 feature for dependently typed languages since 
\begin_inset CommandInset citation
LatexCommand cite
key "coquand1992pattern"
literal "false"

\end_inset

 and is implemented in Agda and the user facing language of Coq.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

 -- eliminator style
\end_layout

\begin_layout Plain Layout

 head' : (A : *) -> (n : Nat) ->
\end_layout

\begin_layout Plain Layout

   Vec A (S n) ->
\end_layout

\begin_layout Plain Layout

   A ;
\end_layout

\begin_layout Plain Layout

 head' A n v =
\end_layout

\begin_layout Plain Layout

   case A, (S n), v <
\end_layout

\begin_layout Plain Layout

     A' => n' => _ : Vec A' n' =>
\end_layout

\begin_layout Plain Layout

       case n' < _ => *> {
\end_layout

\begin_layout Plain Layout

         | (Z  ) => Unit
\end_layout

\begin_layout Plain Layout

         | (S _) => A'
\end_layout

\begin_layout Plain Layout

       }
\end_layout

\begin_layout Plain Layout

   >{
\end_layout

\begin_layout Plain Layout

   | _ => (Z)   => (Nil _       ) => tt
\end_layout

\begin_layout Plain Layout

   | _ => (S _) => (Cons _ a _ _) => a
\end_layout

\begin_layout Plain Layout

   } ;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  -- pattern match style
\end_layout

\begin_layout Plain Layout

 head : (A : *) -> (n : Nat) ->
\end_layout

\begin_layout Plain Layout

   Vec A (S n) ->
\end_layout

\begin_layout Plain Layout

   A ;
\end_layout

\begin_layout Plain Layout

 head A n v =
\end_layout

\begin_layout Plain Layout

   case v < _ => A > {
\end_layout

\begin_layout Plain Layout

   | (Cons _ a _ _) => a
\end_layout

\begin_layout Plain Layout

   } ;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
clean when I get motive inference working
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
syntax highlighting would be bomb
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Eliminators vs.
 Pattern Matching
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:data-eliminators"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Surface data syntax
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the extensions to the surface language for data and pattern matching.
 The syntax of data constructors and data type constructors is standard.
 Our case eliminators match a tuple of expressions, allowing us to be very
 precise about the typing of branches.
 Additionally this style allows for syntactic sugar for easy definitions
 of functions by cases.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% For instance, we can simulate direct elimination by quantifying over every
 type constructor argument.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{n,}\,\left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 without motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{n,}\,\left\langle \overline{x\Rightarrow}M\right\rangle \left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 with motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
patterns,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $pat$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
match a variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(d\,\overline{pat})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
match a constructor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Data
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Patterns correspond to a specific form of expression syntax.
 When an expression matches a pattern it will choose the appropriate branch
 to reduce.
 For instance,
\end_layout

\begin_layout Standard
\begin_inset Formula $Cons\,\mathbb{B}\,true\,\left(S\left(S\left(S\left(Z\right)\right)\right)\right)\,\left(Cons\,\mathbb{B}\,false\,\left(S\left(S\left(Z\right)\right)\right)\,y'\right)$
\end_inset


\end_layout

\begin_layout Standard
will match the patterns
\end_layout

\begin_layout Standard
\begin_inset Formula $x$
\end_inset

 where 
\begin_inset Formula $x$
\end_inset

 is equal to the full expression
\end_layout

\begin_layout Standard
\begin_inset Formula $Cons\,w\,x\,y\,z$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $w=\mathbb{B}$
\end_inset

,
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $x=true$
\end_inset

, 
\begin_inset Formula $y=3$
\end_inset

, 
\begin_inset Formula $z=Cons\,\mathbb{B}\,false\,\left(S\left(S\left(Z\right)\right)\right)\,y'$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Cons\,-\,x\,-\,\left(Cons\,-\,y\,-\,-\right)$
\end_inset

 where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $x=true$
\end_inset

, 
\begin_inset Formula $y=false$
\end_inset


\end_layout

\begin_layout Standard
so the expression 
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathsf{case}\,Cons\,\mathbb{B}\,true\,\left(S\left(S\left(S\left(Z\right)\right)\right)\right)\,\left(Cons\,\mathbb{B}\,false\,\left(S\left(S\left(Z\right)\right)\right)\,y'\right)\left\{ Cons\,-\,x\,-\,\left(Cons\,-\,y\,-\,-\right)\Rightarrow x\&y\right\} $
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
reduces to 
\begin_inset Formula $false$
\end_inset


\end_layout

\begin_layout Standard
The explicit rules for pattern matching are listed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-match"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{x\sim_{\left\{ x\coloneqq m\right\} }m}\,...
\]

\end_inset


\begin_inset Formula 
\[
\frac{\overline{pat}\sim_{\sigma}\overline{m}}{d\overline{pat}\sim_{\sigma}d\overline{m}}\,...
\]

\end_inset


\begin_inset Formula 
\[
\frac{pat'\sim_{\sigma}n\quad\overline{pat}\sim_{\sigma'}\overline{m}}{pat',\overline{pat}\sim_{\sigma\cup\sigma'}n,\overline{m}}\,...
\]

\end_inset


\begin_inset Formula 
\[
\frac{\,}{.\sim_{\emptyset}.}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Match
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-match"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is now possible for branches to overlap, which could allow nondeterministic
 reduction.
 There are several pluasable ways to handle this, such as reuiring each
 branch to have independent patterns, or requireing patterns have the same
 behavour when tehy oeverlap 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 For the purposes of this thesis, we will use the programatic convention
 that the first matching pattern has precedence.
 For example, we will be able to type check
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathsf{case}\,4\,\left\langle s:\mathbb{N}\Rightarrow\mathbb{B}\right\rangle \left\{ |S\left(S\,-\right)\Rightarrow True\,|\,-\Rightarrow False\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
and it will reduce to 
\begin_inset Formula $True$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% pattern matching is hard
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

While pattern matching is an extremely practical feature, typing these expressio
ns tends to be messy.
 To implement dependently typed pattern matching, a procedure is needed
 to resolve the equational constraints that arise on each branch, and to
 confirm the impossibility of unwritten branches.
 There is no 
\begin_inset Quotes eld
\end_inset

optimal
\begin_inset Quotes erd
\end_inset

 strategy to handle these equational constraints, since the constraints
 are undecidable in general, since arbitrary computation can be embedded
 in the arguments of a type constructor.
 Any approach will have to be an aproxomation that performs well in practice.
 Several options are explored in 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx_devriese_2018"
literal "false"

\end_inset

.
 In practice this procedure usually takes the form of a first order unification.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Unfortunately, the unification procedure involves terms outside of the
 pattern,  hence it is hard to pinpoint the exact point of error to the
 pattern.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Worryingly, it is easy to unintentionally validate or contradict principles
 like Streicher's axiom K, or the Law of the Excluded Middle.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
there is a lot of jenkyness about unification in general, but I think the
 additional points lose focus?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%Parentheses are used to distinguish between matching a single variable
 and a constructor that takes no arguments
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
uniquness of match.
 or better yet, any determinitic way to resolve paths
\end_layout

\end_inset


\end_layout

\begin_layout Section
First Order Unification
\end_layout

\begin_layout Standard
When type checing the branches of the a case expression, teh patterns are
 interperted as epressions under bindings for each variable used in teh
 pattern.
 If thses equations can be unified, then the brach will typecheck under
 the variable assignments, with teh additional typing information.
 For insatnce, the pattern
\end_layout

\begin_layout Standard
\begin_inset Formula $Cons\,x\,\left(S\,y\right)\,2\,z$
\end_inset


\end_layout

\begin_layout Standard
could be checked against the type 
\begin_inset Formula $Vec\,Nat\,w$
\end_inset


\end_layout

\begin_layout Standard
this implies the typings 
\begin_inset Formula $x:*,y:Nat,\left(S\,y\right):x,2:Nat,z:Vec\,x\,2,\left(Cons\,x\,\left(S\,y\right)\,2\,z\right):Vec\,Nat\,w$
\end_inset


\end_layout

\begin_layout Standard
which in turn imply the equalities
\end_layout

\begin_layout Standard
\begin_inset Formula $x=Nat,w=3$
\end_inset


\end_layout

\begin_layout Standard
note that this is a ver simple example, in the worst case we may have equations
 in the form 
\begin_inset Formula $m\,n=m'\,n'$
\end_inset

 which are hard to solve (until an assignment of 
\begin_inset Formula $m=\lambda x.x$
\end_inset

, and 
\begin_inset Formula $m'=\lambda-.0$
\end_inset

 are solved).
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
uniquness of unificaiton solution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A simplified version of a typical unifiaction procedure is listed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-data-unification"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The unifiacation does not exclude teh possibly cyclic assingnemtns that
 could occur 
\begin_inset Formula $x=S\,x$
\end_inset


\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
as a threat to soundness this should be corrected?
\end_layout

\end_inset

.
 Unification is not guarenteed to terminate since it relies on definitional
 equaliteis.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{U\left(\emptyset,\emptyset\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E,a\right)\quad m\equiv m'}{U\left(\left\{ m\sim m'\right\} \cup E,a\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E\left[x\coloneqq m\right],a\left[x\coloneqq m\right]\right)}{U\left(\left\{ x\sim m\right\} \cup E,\left\{ a,x\coloneqq m\right\} \right)}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E\left[x\coloneqq m\right],a\left[x\coloneqq m\right]\right)}{U\left(\left\{ m\sim x\right\} \cup E,a\cup\left\{ x\coloneqq m\right\} \right)}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\overline{m}\sim\overline{m'}\cup E,a\right)\quad n\equiv d\overline{m}\quad n'\equiv d\overline{m'}}{U\left(\left\{ n\sim n'\right\} \cup E,a\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\overline{m}\sim\overline{m'}\cup E,a\right)\quad N\equiv D\overline{m}\quad N'\equiv D\overline{m'}}{U\left(\left\{ N\sim N'\right\} \cup E,a\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Unificaiton
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-unification"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After the branches have typechecked we should makes sure that they are exhastive.
again tehre are several possible strategies.
 In general it is undecidabel wether any given pattern is impossible or
 not, so a practical approxomation must be chosen.
 At least programmers have the ability to manually include non bovous branches
 and prove thier imposiblity, or direct those branches to dummy outputs.
 Thoudh there is a real risk that the unification procedure gets stuck in
 ways that are not clear to the programmer, and a clean error messafge may
 be very dificult.
\end_layout

\begin_layout Standard
Ususally this priomative impossiblility is tied to a contrediction of the
 unificaiton procedure.
 but there is still a matter of generating patterns that cover all the unmatched
 cases.
 Again there is no clear best way to do this since a more fine devision
 of patterns may allow enough aditional dffinitional information to show
 unsatisfiablity, while a more coarse devision of patterns may be more efficient.
 Agda uses a tree branching approach, that is efficincent but generates
 course patterns.
 The current experemental implementation of the language in this thesis
 generates patterns by a system of complements, this system seams slightly
 eaiser to implement, more uniform, and generates a much finer system of
 pattterns then the case trees used in agda.
 However this aproach is exponentially less performant then Agda in the
 worse case.
\end_layout

\begin_layout Standard
All told we can extend the bidriectional system with rules that look like
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\Gamma\vdash\overline{n}\overrightarrow{\,:\,}\ \Delta\\
\Gamma,\Delta\vdash M\overleftarrow{\,:\,}\star\\
\forall\:i\,\left(\Gamma\vdash\overline{pat}_{i}:_{E}?\Delta\quad U\left(E,\sigma\right)\quad\sigma\left(\Gamma,|\overline{pat}_{i}|\right)\vdash\sigma m\overleftarrow{\,:\,}\sigma\left(M\left[\Delta\coloneqq\overline{pat}_{i}\right]\right)\right)\\
\Gamma\vdash\overline{\overline{pat}}:\Delta\ \mathbf{complete}
\end{array}}{\begin{array}{c}
\Gamma\vdash\mathsf{case}\,\overline{n,}\,\left\langle \Delta_{?}\Rightarrow M\right\rangle \left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} \\
\overrightarrow{\,:\,}M\left[\Delta_{?}\coloneqq\overline{n}\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\Gamma\vdash\overline{n}\overrightarrow{\,:\,}\ \Delta\\
\forall\:i\,\left(\Gamma\vdash\overline{pat}_{i}:_{E}?\Delta\quad U\left(E,\sigma\right)\quad\sigma\left(\Gamma,|\overline{pat}_{i}|\right)\vdash\sigma m\overleftarrow{\,:\,}\sigma\left(M\right)\right)\\
\Gamma\vdash\overline{\overline{pat}}:\Delta\ \mathbf{complete}
\end{array}}{\Gamma\vdash\mathsf{case}\,\overline{n,}\,\left\{ \overline{|\,\overline{pat\Rightarrow}m}\right\} \overleftarrow{\,:\,}M}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $\Gamma\vdash\overline{pat}:_{E}?\Delta$
\end_inset

 is shorthad for a set of equations that allow a list of patterns to typecheck
 under 
\begin_inset Formula $\Delta$
\end_inset

.
 and 
\begin_inset Formula $\Gamma\vdash\overline{\overline{pat}}:\Delta\ \mathbf{complete}$
\end_inset

 is shorthand for teh exuastiveness check.
 
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
Their exists a suitable
\begin_inset Foot
status open

\begin_layout Plain Layout
supporting at least subject reduction, type soundnes, and regularity
\end_layout

\end_inset

 extention to the surface language TAS that supports patten matching style
 elimination
\end_layout

\begin_layout Standard

\series bold
Conjecture 
\series default
The bidirecitonal extention listed here is weakly anotatable with that extention
 to teh surface language.
\end_layout

\begin_layout Standard
Additionally, it makessense to allow some additional type annotations in
 the motive and for these annotations to swich the the type inference of
 teh scrutinee into a type-check.
 Along with a full syntax of modules, and even mutually defined data types.
 For simplicity these have been excluded from teh formal presentation.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
Pattern matching seems simple, but is a surprisingly subtle.
\end_layout

\begin_layout Standard
Even without dependent types, pattern matching is a strange feature.
 How important is it that patterns correspond exactly to a subset expression
 syntax? What about capture annotations or side conditions? Restricting
 patterns to constructors and variable means that it is hard to encapsulate
 functionality, a fact noticed by wadler as early as 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 This has lead to making pattern behavior override-able in Scala.
 An extension in GHC allows some computations to happen within a pattern
 match
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
Which
\end_layout

\end_inset

.
 It seems unreasonable to extend patterns to arbitrary computation (thought
 this is exactly what teh Curry language does as a way to make use of it's
 logical programming features).
 
\end_layout

\begin_layout Standard
In the presence of full-spectrum dependent types, the perspective shifts.
 Any terminating typing procedure will necessarily exclude some typable
 patterns and be unable to exclude some reachable branches.
 Since dependent patterns are already attacking a much more difficult problem
 then in the non-dependent case but also only considering data values (no
 functions), it may make sense to extend the notion of pattern matching
 to include other useful but difficult features.
 To some extent this is similar to the with syntax of 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 In principle it seems that dependent case expressions could be extended
 with uniqueness side conditions, arbitrary computation or some amount of
 constraint solving, without being any theoretically worse than usual unificatio
n.
 
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
Epigram
\end_layout

\end_inset

, Agda and Idris attempt to deal with these issues using 
\series bold
with
\series default
 syntaxx that allows further branging based on teh computation of each branch.
 This is justifed as syntactic sugar that corresponds to several halper
 functions that can be apropriately typed.
 The language described in this thesis does not use the with side condition
 since nested case expressions carry the same compuatational behavour, and
 the elaboration to the cast langugae will allow possibly questionable typing.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
ATS
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How should overlapping branches be handled? partial evaluation of case expressio
ns can change the definitional nature of the theory.
 
\end_layout

\begin_layout Standard
the details of pattern matching chang e the logical character of the system.
 Since non-ermination is allowed in the langugae described here the logical
 issues are less of a concern.
 However it is worth noting that pattern matching as described here validates
 axiom k and thus apears unsuatable for Hott or CTT developments.
\end_layout

\begin_layout Standard
We have glossed over the definitional behavior of case branches in this
 chapter since we plan sidestep the issue with the cast langauge.
 Though it is still worth noting that their are several ways to set up the
 definitional reductions.
 Agda style case trees may result in unpredicatble definitional equalities
 (in so far as definitional behavour is ever predicatable)
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

 advocates for a more conservative aproach that makes function definitionas
 be cases defintiional (wich is nice in that it respectes the surface langauge
 euqality, but shifts teh dificulties to overlapping branches and does not
 allow shadowinf behavior programmers are used to).
 another extream would be to only allowredcutions at fully computed scrutinee
 valuess, as in trellies worke)
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

.
 Alternatively a partial reduction is possible, such that branches are eliminate
d as they are found unreachable and substituations made as that are availible.
 This last aproach is experimantally implemented in the implementation.
\end_layout

\begin_layout Standard
This complicates the simple story from chapter 2, where the bidirectional
 system made the TAS system tractable by only adding annotations (and having
 annotatability).
 We have only conjectured the existnace of a saitable TAS system.
 If the definitinoal equality that feeds the TAS is generated by a system
 of reductions, any of the reduction strategies from the last section will
 generate a different TAS with subtly different characteristics.
 For instance, insisting on a call-by-value case reduction will leave many
 equivelent computiaitons unassociated.
 If the TAS system uses partial reductions it will need to inspect the construct
ors of the scrutinee in order to preserve typeing over reduction.
 Agda style reductions need to extend syntax under reduction to account
 for side conditions.
 For this reason it is rare to see a fully formailized account of pattern
 matching.
\end_layout

\begin_layout Standard
Ideally the typeing rule for pattern matching case expression in teh TAS
 should not use the notion of pattern matching at all.
 Instead the rule should characterize the behavour that is required directly
 and formally
\begin_inset Foot
status open

\begin_layout Plain Layout
Cite has a good imformal description
\end_layout

\end_inset

.
 An ideal rule might look like
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{cl}
\Gamma\vdash\overline{n}:\Delta' & (scrutinees\ type\ check)\\
\Gamma,\overline{x}:\Delta'\vdash M:\star & (motive\ exists\ and\ is\ well\ formed)\\
\forall i.\:? & (every\ branch\ is\ well\ typed\ over\ all\ possible\ instantiations)\\
? & (all\ scrutinees\ are\ handled)
\end{array}}{\Gamma\vdash\mathsf{case}\,\overline{n,}\,\left\{ \overline{|\,\overline{pat\Rightarrow}_{i}m_{i}}\right\} :M\left[\overline{x}\coloneqq\overline{n}\right]}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
last condition is optional if you're willing to modify type soundness to
 allow pattern match errors (again, they are no worse then the non-termination
 already allowed, and much better behaved).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO example axiom k?
\end_layout

\end_inset


\end_layout

\begin_layout Part
Related work
\end_layout

\begin_layout Section
Systems with Data
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Minimal data with Sigma and Unit
\end_layout

\end_inset


\end_layout

\begin_layout Standard
ML W types
\end_layout

\begin_layout Standard
UTT
\begin_inset CommandInset citation
LatexCommand cite
key "luo1990extended,luo1994computation"
literal "false"

\end_inset

 is an extention to ECC that specifies a scheme to define strictly positive
 data types by way of a logical framework defined in MLTT.
 This scheme generates primative recursors, and does not iunherently support
 pattern matching.
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
finish reading this
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I am unaware of any clear, complete account of CIC in English.
 A bidirectional account of CIC is given in 
\begin_inset CommandInset citation
LatexCommand cite
key "lennonbertrand:LIPIcs.ITP.2021.24"
literal "false"

\end_inset

, though it uses a different style of biderectionality then discussed here
 to maintain compatibility with the existing Galina language.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
CTT, higher inductive types, qoatent types
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pattern matching
\end_layout

\begin_layout Standard
Early work by Coq92 
\begin_inset CommandInset citation
LatexCommand cite
key "coquand1992pattern"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
with a lot of follow up from McBride 
\begin_inset CommandInset citation
LatexCommand cite
key "mcbride_mckinna_2004"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
reiterated in 
\begin_inset CommandInset citation
LatexCommand cite
key "norell2007towards"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
A tutorial implementation of dynamic pattern unification Adam Gundry and
 Conor McBride (2012) http://adam.gundry.co.uk/pub/pattern-unify/ (this links
 give you the choice to read a more detailed chapter of Adam Gundry's thesis
 instead)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
with substantial follow up in 
\begin_inset CommandInset citation
LatexCommand cite
key "cockx_devriese_2018"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
https://research.chalmers.se/en/publication/519011 ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
https://sozeau.gitlabpages.inria.fr/www/research/publications/Equations:_A_Dependen
t_Pattern-Matching_Compiler.pdf ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.99.1405&rep=rep1&type=pdf
 ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
talk about normalization
\end_layout

\end_inset


\end_layout

\begin_layout Standard
https://popl19.sigplan.org/details/POPL-2019-Research-Papers/33/Higher-Inductive-T
ypes-in-Cubical-Computational-Type-Theory
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/thesis/bibliography/dtest"
options "alpha"

\end_inset


\end_layout

\begin_layout Part
TODO
\end_layout

\begin_layout List of TODOs

\end_layout

\begin_layout Section
notes
\end_layout

\begin_layout Standard
Other extensions to the Calculus of Constructions that are primarily concerned
 with data (UCC, CIC) will be reviewed in chapter 4.
\end_layout

\begin_layout Standard
Coq and Lean trace their core theory back to the Calculus of Constructions.
\end_layout

\begin_layout Section
unused
\end_layout

\begin_layout Standard
...
\end_layout

\end_body
\end_document
