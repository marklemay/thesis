\section{Discussion}

\todo{ECHO VIEW from the left to explore this more}

\todo{Inductive families? don't seem to make sense in this formulation}

Pattern matching seems simple, but is a surprisingly subtle.

Even without dependent types, pattern matching is a strange programming construct. 
How important is it that patterns correspond exactly to a subset expression syntax?
What about capture annotations or side conditions?
Restricting patterns to constructors and variable means that it is hard to encapsulate functionality, a problem noticed as early as \cite{10.1145/41625.41653}\todo{review}. 
This has lead to making pattern behavior override-able in Scala via Extractor Objects.
An extension in GHC allows some computations to happen within a pattern match via the $ViewPatterns$ extension\todo{font. lots of prior work https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns}.
It seems unreasonable to extend patterns to arbitrary computation (though this is allowed in the Curry language\footnote{https://curry.pages.ps.informatik.uni-kiel.de/curry-lang.org/} as a syntax for its logical programming features). 

In the presence of full-spectrum dependent types, the perspective dramatically shifts.
Any terminating typing procedure will necessarily exclude some type-able patterns and be unable to exclude some unreachable branches.
Even though only data values are considered, dependent patterns are already attacking a much more difficult problem then in the non-dependent case.
It may make sense to extend the notion of pattern matching to include other useful but difficult features.
One such interesting feature was the $\mathsf{with}$ syntax of \cite{mcbride_mckinna_2004}.

\todo{discuss stuck state of unification explicitly, x = f a vs. f a = g b, and how it for instance makes it so you can't prove transitivity
of ID fa gb, ID gb hc -> ID fa hc. also calls into quesiton preservation entirely. }

Epigram, Agda and Idris make pattern matching more powerful using $\mathsf{with}$ syntax that allows further pattern based branching by attaching a computation to a branch.
This is justified as syntactic sugar that corresponds to helper functions that can be appropriately elaborated and type-checked.
The language described in this thesis does not use the $\mathsf{with}$ side condition since nested case expressions carry the same computational behavior, and the elaboration to the cast language will allow possibly questionable typing anyway.

More aggressive choices should be explored beyond the $\mathsf{with}$ construct.
In principle it seems that dependent case expressions could be extended with relevant proof search, arbitrary computation or some amount of constraint solving, without being any theoretically worse than usual first order unification. 

\todo[inline]{Discus how stratified type systems like ATS handle things (additional equational information)}

% There are other questions that How should overlapping branches be handled? (think this got covered (HA!))

The details of pattern matching change the logical character of the system\cite{cockx_devriese_2018}.
Since non-termination is allowed in the language described here, the logical issues that arise from patterns are less of a concern then the immediate logical unsoundness that was discussed in \ch{2}.
However, it is worth noting that pattern matching as described here validates axiom k and thus appears unsuitable for Hott or CTT developments.\todo{acronyms}

This Chapter has glossed over the definitional behavior of $\mathsf{case}$s, since we plan to sidestep definitional issues entirely with the cast language.
It is worth noting that their are several ways to set up the definitional reductions.
Agda style case trees may result in unpredictable definitional equalities (in so far as definitional behavior is ever predictable) \cite{10.1007/978-3-642-54833-8_6}\todo{review}.
\cite{10.1007/978-3-642-54833-8_6} advocates for a more conservative approach that makes function definitions by cases definitional (but shifts the difficulties to overlapping branches and does not allow the ``first match'' behavior programmers are used to).
Another extreme would be to only allow reductions when the scrutinee is a value, similar to the work in \cite{sjoberg2012irrelevance}\todo{confirm}.
Alternatively a partial reduction is possible, such that branches are eliminated as they are found unreachable and substitutions made as they are available.
This last approach is experimentally implemented for the language defined here.
However it is unclear how partial reduction could be handled in the meta-theory.

Patten matching complicates the simple story from Chapter 2, where the bidirectional system made the TAS system checkable by only adjusting annotations.
We have only conjectured the existence of a suitable TAS system for pattern matching.
If the definitional equality that feeds the TAS is generated by a system of reductions, any of the reduction strategies listed above will generate a different TAS with subtly different characteristics.
For instance, insisting on a call-by-value case reduction will leave many equivalent computations unassociated.
If the TAS system uses partial reductions it will need to inspect the constructors of the scrutinee in order to preserve typing when reduction eliminates branches.
Agda style reductions need to extend syntax under reduction to account for side conditions. 

% For this reason it is rare to see a fully formailized account of pattern matching.

Ideally the typing rule for pattern matching case expression in the TAS should not use the notion of unification at all.
Instead the rule should characterize the behavior that is required directly and formally\footnote{\cite{coquand1992pattern} has a good informal description}.
An ideal rule might look like

\[
\frac{\begin{array}{cl}
\Gamma\vdash\overline{n}:\Delta' & (scrutinees\ type\ check)\\
\Gamma,\overline{x}:\Delta'\vdash M:\star & (motive\ exists\ and\ is\ well\ formed)\\
\forall i.\:? & (every\ branch\ is\ well\ typed\ over\ all\ possible\ instantiations)\\
? & (all\ scrutinees\ are\ handled)
\end{array}}{\Gamma\vdash\mathsf{case}\,\overline{n,}\,\left\{ \overline{|\,\overline{pat\Rightarrow}_{i}m_{i}}\right\} :M\left[\overline{x}\coloneqq\overline{n}\right]}\,...
\]

% Where the last condition is optional if you're willing to modify type soundness to allow pattern match errors (again, they are no worse then the non-termination already allowed, and better behaved).
