\section{\SLang{} Type Assignment System}
 
When is an expression reasonable? The expression $\star\star\star\star$ is allowed by the syntax of the language, but seems dubious.
%Since $\star$  is not a function,  it has no way of being given an input by application.
Type systems can disallow bad terms like these, which in turn prevents bad runtime behavior.
 
We will present our type system as a \textbf{type assignment system} (\ac{TAS}).
Type assignment systems are convenient to study the theory of a dependently typed language because terms do not need to contain information to help type checking, allowing simpler syntax. %type annotations. %and will be easier to work with than other styles of typing that require variables to be annotated.
% For instance, $\mathsf{fun}\,f\,x\Rightarrow m$ does not require a type be given for $f$ or $a$.
\todo{church/curry?}
Practically this means that the type assignment system should\ccnote{keeping as should since you can use the rules as an inefficient procedure} not be used as a type checking algorithm since it may need to ``infer'' an unrealistic amount of information.
This also means that terms do not necessarily have unique typings.\ccnote{don't think the uniqueness is salient here}
For instance, $\tasys\lambda x\Rightarrow x:\mathbb{N}_{c}\rightarrow\mathbb{N}_{c}$, and $\tasys\lambda x\Rightarrow x:\mathbb{B}_{c}\rightarrow\mathbb{B}_{c}$.
These issues will be addressed when the more practical, \bidir{} type system is introduced in the next section.
\todo{move negative stuff later?}
 
\begin{figure}
\[
\frac{x:M\in\Gamma}{\Gamma\tasys x\,:\,M}\,\rulename{ty-var}
\]
 
\[
\frac{\Gamma\tasys m\,:\,M \quad \Gamma\tasys M\,:\,\star\
}{\Gamma\tasys m::M\,:\,M}
\,\rulename{ty-::}
\]
 
\[
\frac{{\color{gray}\ }}{\Gamma\tasys\star\,:\,\star}\,\rulename{ty-\star}
\]
 
\[
\frac{\Gamma\tasys M\,:\,\star\quad\Gamma,x:M\tasys N\,:\,\star}{\Gamma\tasys\left(x:M\right)\rightarrow N\,:\,\star}\,\rulename{ty-\mathsf{fun}-ty}
\]
 
\[
\frac{\Gamma\tasys m\,:\,\left(x:N\right)\rightarrow M\quad\Gamma\tasys n\,:\,N}{\Gamma\tasys m\,n\,:\,M\left[x\coloneqq n\right]}\,\rulename{ty-\mathsf{fun}-app}
\]
 
\[
\frac{\Gamma,f:\left(x:N\right)\rightarrow M,x:N\tasys m\,:\,M}{\Gamma\tasys\mathsf{fun}\,f\,x\Rightarrow m\,:\,\left(x:N\right)\rightarrow M}\,\rulename{ty-\mathsf{fun}}
\]
 
\[
\frac{\Gamma\tasys m\,:\,M\quad M\equiv M'}{\Gamma\tasys m\,:\,M'}\,\rulename{ty-conv}
\]
 
\caption{\SLang{} Type Assignment System}
\label{fig:surface-TAS}
\end{figure}
 
The rules of the type assignment system are listed in \Fref{surface-TAS}.
Variables get their type from the typing context by the \rulename{ty-var} rule.
Type annotations reflect a correct typing derivation in the \rulename{ty-::} rule.
\Tit{} is recognized by the \rulename{ty-\star} rule.
The \rulename{ty-\mathsf{fun}-ty} rule forms dependent function types.
The \rulename{ty-\mathsf{fun}-app} rule shows how to type function application, by substituting the argument term directly into the dependent function type.
Functions are typed with a variable for recursive reference along with a variable for the argument in \rulename{ty-\mathsf{fun}}.
Finally, \rulename{ty-conv} allows type derivations to be \textbf{converted} to an equivalent type.
% The $\equiv$ relation will be defined later. 
\ccnote{I don't think a forward reference for $\equiv$ here is helpful, since a discussion is only 2 paragraphs away}
 
% meta-theory type soundness From the programming language perspective
The most important property of a type system is \textbf{type soundness}\footnote{
  Also called \textbf{type safety}.
}.
Type soundness is often motivated with the slogan, ``well typed programs don't get stuck''\cite{MILNER1978348}\footnote{
  In Milner's original paper, he used ``go wrong'' instead of ``get stuck''.
  In that paper he defined "wrong" as a semantic notion that behaves like a runtime type error.
  % The presentation here can be simplified by only considering "stuck" terms.
}.
Given the syntax of the \slang{}, there is potential for a program to ``get stuck'' when an argument is applied to a non-function constructor.
For example, $\star\ 1_{c}$ would be stuck since $\star$ is not a function, so it cannot compute when given the argument $1_{c}$.
A good type system will make such unreasonable programs impossible.
\todo{WHY! talk about the incremenatal advantage of the construction}
 
Type soundness can be shown with a \textbf{progress} and \textbf{preservation}\footnote{
  Also called \textbf{Subject Reduction}.
} style proof\footnote{
  The first proof published in this style is \cite{WRIGHT199438} though their progress lemma is a bit different from modern presentations.
  Most relevant textbooks outline forms of this proof for non-dependent type systems.
  For instance, \cite[Part 2]{pierce2002types}, \cite{KOKKE2020102440}, and \cite[Chapter 11]{chlipala2017formal}.
  % Chapter 3 of \cite{sjoberg2015dependently} has a similar progress and preservation style proof for a dependently typed language.
}. \todo{move bolding to definition}
\todo{TAPL cites Harper as a co-originator of progress-preservation.
  Maybe just email him?  it might be also good to get him for intractability (blum stuff).
  might want to review his book first}
The preservation theorem shows that typing information is invariant over evaluation.\ccnote{I'm using evaluation since this can apply to a number of computation relations}
The progress theorem shows that a step of computation for a well typed term in an empty context will not ``get stuck''.
By iterating these theorems together, it is possible to show that the type system prevents a well typed term from ever reaching a stuck state.
For a progress and preservation style proof of a dependently typed language, everything hinges on a suitable definition of the $\equiv$ relation.
 
The $\equiv$ relation characterizes when terms are ``obviously'' or ``automatically'' equal.
Because the $\equiv$ relation is usually based on the definition of computation, rather than on observable properties, it is called \textbf{definitional equality}\todo{is that actually why?}\footnote{
  Also called \textbf{Judgmental Equality}, since it is defined via judgments.
}.\todo{or it effects judgments? either way that is a real dumb name}
Usually it is desirable to make the definitional equality relation as large as possible, since the programmer in the system will get more equalities ``for free''.
This Chapter will opt for an easier (but less powerful) $\equiv$ relation, since Chapter 3 will propose a way to avoid definitional equality in general.
 
In a progress and preservation style proof, the $\equiv$ relation should:
 
\begin{itemize}
\item Be reflexive, $m\equiv m$.
\item Be symmetric, if $m\equiv m'$ then $m'\equiv m$. % since computation will be run in reverse
\item Be transitive, if $m\equiv m'$ and $m'\equiv m''$ then $m\equiv m''$.
\item Be closed under substitutions and evaluation, for instance if $m\equiv m'$ and $n\equiv n'$ then $m\left[x\coloneqq n\right]\equiv m'\left[x\coloneqq n'\right]$.
\item Distinguish between type formers, for instance $\star\cancel{\equiv}\left(x:N\right)\rightarrow M$.
\end{itemize}
A particularly clean definition of $\equiv$ arises by equating any terms that share a reduct via a system of parallel reductions ($\Rrightarrow$),
 
\[
\frac{m\Rrightarrow_{\ast}\,n\quad m'\Rrightarrow_{\ast}\,n}{m\equiv m'}\,\rulename{\equiv-Def}
\]
 
This relation:\ccnote{this bit is meant to be an outline to motivate things, I have included explicit forward references}
\begin{itemize}
\item Is reflexive, by the definition of $\Rrightarrow_{\ast}$.
\item Is symmetric, automatically.
\item Is transitive, if $\Rrightarrow_{\ast}$ is confluent (Theorem \ref{thm:conf-par-red}).
\item Is closed under substitution if $\Rrightarrow_{\ast}$ is closed under substitution (Lemma \ref{lem:sub-par-red}), and closed under evaluation automatically.
\item Distinguishes type constructors, if they are stable under reduction.
For instance,
\begin{itemize}
\item for any $N$, $M$, $\left(x:N\right)\rightarrow M\Rrightarrow P$ implies $P=\left(x:N'\right)\rightarrow M'$ (Lemma \ref{lem:pi-stability})
\item and $\star\Rrightarrow P$ implies $P=\star$ (by the definition of $\Rrightarrow$)
\item then $\left(x:N\right)\rightarrow M\cancel{\equiv}\star$
\end{itemize}
\end{itemize}
\begin{figure}
\[
\frac{m\Rrightarrow m'\quad n\Rrightarrow n'}{\left(\mathsf{fun}\,f\,x\Rightarrow m\right)n\Rrightarrow m'\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow m',x\coloneqq n'\right]}\,\rulename{\Rrightarrow-\mathsf{fun}-app-red}
\]
\[
\frac{m\Rrightarrow m'}{m::M\Rrightarrow m'}\,\rulename{\Rrightarrow-::-red}
\]
 
\[
\frac{\,}{x\Rrightarrow x}\,\rulename{\Rrightarrow-var}
\]
\[
\frac{m\Rrightarrow m'\quad M\Rrightarrow M'}{m::M\Rrightarrow m'::M'}\,\rulename{\Rrightarrow-::}
\]
 
\[
\frac{\,}{\star\Rrightarrow\star}\,\rulename{\Rrightarrow-}\star
\]
 
\[
\frac{M\Rrightarrow M'\quad N\Rrightarrow N'}{\left(x:M\right)\rightarrow N\Rrightarrow\left(x:M'\right)\rightarrow N'}\,\rulename{\Rrightarrow-\mathsf{fun}-ty}
\]
 
\[
\frac{m\Rrightarrow m'}{\mathsf{fun}\,f\,x\Rightarrow m\,\Rrightarrow\,\mathsf{fun}\,f\,x\Rightarrow m'}\,\rulename{\Rrightarrow-\mathsf{fun}}
\]
 
\[
\frac{m\Rrightarrow m'\quad n\Rrightarrow n'}{m\,n\Rrightarrow m'\,n'}\,\rulename{\Rrightarrow-\mathsf{fun}-app}
\]
 
\[
\frac{\,}{m\Rrightarrow_{\ast}m}\,\rulename{\Rrightarrow_{\ast}-refl}
\]
\[
\frac{m\Rrightarrow_{\ast}m'\quad m'\Rrightarrow m''}{m\Rrightarrow_{\ast}m''}\,\rulename{\Rrightarrow_{\ast}-trans}
\]
 
\caption{\SLang{} Parallel Reductions}
\label{fig:surface-reduction}
\end{figure}

The system of parallel reductions is defined in \Fref{surface-reduction}.\ccnote{I mentioned briefly in the intro that substitution would be taken informally, otherwise things become far too bureaucratic. Note that our Coq proof uses De Bruijn indices, while the implementation is "locally nameless".  I could say this presentation is "capture avoiding" but I don't think that really clarifies anything.}
Parallel reductions are defined to make confluence easy to prove, by allowing the simultaneous evaluation of any available reduction.
The only interesting rules are \rulename{\Rrightarrow-\mathsf{fun}-app-red} and \rulename{\Rrightarrow-::-red} since they directly perform reductions.
The \rulename{\Rrightarrow-\mathsf{fun}-app-red} rule recursively reduces a function given an argument.
The \rulename{\Rrightarrow-::-red} rule removes a type annotation, making type annotations definitionally irrelevant.
The other rules are structural and allow parallel reductions in any subterms.
Repeating parallel reductions zero or more times is written $\Rrightarrow_{\ast}$.
 
While this is a sufficient presentation of definitional equality, other variants of the relation are possible.
For instance, it is possible to extend the relation with contextual information, type information, explicit proofs of equality (as in Extensional Type Theory), and uncomputable relations (as in \cite{jia2010dependent}).
It is also common to assume the properties of $\equiv$ hold without proof.
 
Some lemmas need to quantify over simultaneous substitutions.
These simultaneous substitutions will be quantified with the variables $\sigma$, $\tau$.
For instance, if $\sigma(x) = \star$ and $\sigma(y) = 1_c$, then instead of writing $(x\ y)[x \coloneqq \star,y \coloneqq 1_c]\ =\ (\star\ 1_c)$ we would write $(x\ y)[\sigma]\ =\ (\star\ 1_c)$.
 
\todo{what properties are needed over substitutions?}
 
\subsection{Definitional Equality}
 
We now have enough information to prove the critical properties of definitional equality.

\todo[inline]{named proofs would be nice but it seems akward https://tex.stackexchange.com/questions/12913/customizing-theorem-name}
 
\subsubsection{Reflexivity Lemmas}
\begin{lem}
$\Rrightarrow$ is reflexive.

The following rule is admissible:
\[
\frac{\,}{m\Rrightarrow\,m}\,\rulename{\Rrightarrow-refl}
\]
\end{lem}
\begin{proof}
By induction on the syntax of $m$.
\end{proof}

\begin{fact} $\Rrightarrow_{\ast}$ is reflexive.
\end{fact} \todo{distracting? remove?}
 
\begin{lem}$\equiv$ is reflexive.

The following rule is admissible:
\[
\frac{\,}{m\equiv m}\,\rulename{\equiv-refl}
\]
\end{lem}
\begin{proof}
Since $\Rrightarrow_{\ast}$ is reflexive.
\end{proof}
 
\subsubsection{Closure Lemmas}
% \begin{lem}
% $\Rrightarrow$ is closed under substitutions.
 
% The following rule is admissible for every substitution $\sigma$
% \[
% \frac{m\Rrightarrow m'}{m\left[\sigma\right]\Rrightarrow m'\left[\sigma\right]}\,\rulename{\Rrightarrow-sub-\sigma}
% \]
% \end{lem}
 
 
% \todo{is this lemma needed or is it just to accommodate stupid binding stuff in coq?}
% \begin{proof}
% By induction on the $\Rrightarrow$ relation, using \rulename{\Rrightarrow-refl} in the \rulename{\Rrightarrow-var} case.
% \end{proof}
\begin{lem} $\Rrightarrow$ is closed under substitutions that parallel reduce.
 
Where $\sigma$, $\tau$ are a substitutions.
Where $\sigma\Rrightarrow\tau$ means for every $x$, $\sigma\left(x\right)\Rrightarrow\tau\left(x\right)$.
\todo{awk}
The following rule is admissible:
\[
\frac{m\Rrightarrow m'\quad\sigma\Rrightarrow\tau}{m\left[\sigma\right]\Rrightarrow m'\left[\tau\right]}\,\rulename{\Rrightarrow-sub}
\]
\end{lem}
\begin{proof}
By induction on the $\Rrightarrow$ relation, since the substituted term will reduce in the \rulename{\Rrightarrow-var} case.
\end{proof}
 
\begin{lem} $\Rrightarrow_{\ast}$ is closed under substitutions that parallel reduce.
\label{lem:sub-par-red}

\[
\frac{m\Rrightarrow_{\ast}m'\quad\sigma\Rrightarrow\tau}{m\left[\sigma\right]\Rrightarrow_{\ast}\,m'\left[\tau\right]}\,\rulename{\Rrightarrow_{\ast}-sub}
\]
is admissible.
\end{lem}
\begin{proof}
By induction on the $\Rrightarrow_{\ast}$ relation.
\end{proof}

\begin{lem} $\equiv$ is closed under substitutions that parallel reduce.

\[
\frac{m\equiv m'\quad\sigma\Rrightarrow\tau}{m\left[\sigma\right]\equiv m'\left[\tau\right]}\,\rulename{\equiv-sub}
\]
is admissible.
\end{lem}
 
\begin{cor} $\equiv$ is closed under substituted reduction.

\[
\frac{n\Rrightarrow_{\ast}n'}{m\left[x\coloneqq n\right]\equiv m\left[x\coloneqq n'\right]}
\]
\end{cor}
\begin{proof}
By repeated $\rulename{\Rrightarrow_{\ast}-sub}$ and $\equiv\rulename{-Def}$.
\end{proof}
 
\subsubsection{Transitivity}
 
To prove the transitivity of the $\equiv$ relation, we will first need to prove that \textbf{$\Rrightarrow_{\ast}$ }is \textbf{confluent}.
A relation $R$ is confluent\footnote{
  Also called \textbf{Church-Rosser}.
} when, for all $m$, $n$, $n'$, if $mRn$ and $\:mRn'$ then exists exists $n''$ such that $nRn''$ and $n'Rn''$.
If a relation is confluent, in a sense, specific reduction choices don't matter since you can alway rejoin at a future destination.
 
\begin{figure}
\subsubsection*{Triangle Property}

$\forall{\color{red}m},{\color{red}m'}.\:{\color{red}m\Rrightarrow m'}\:\mathrm{implies}\:{\color{red}m'}{\color{blue}\Rrightarrow \textbf{max}\left(m\right)}$

\begin{tikzcd}
\mathbin{\color{red}m} \tarrow[red]{r} \arrow[lightgray]{d} & \mathbin{\color{red}m'} \tarrow[blue]{ld} \\
\mathbin{\color{blue} \textbf{max}(m)}                  &             
\end{tikzcd}

\subsubsection*{Diamond Property}

$\forall{\color{red}m},{\color{red}m'},{\color{red}m''}.\:{\color{red}m\Rrightarrow m'}\:\wedge\:{\color{red}m\Rrightarrow m''}\: \mathrm{implies}\: {\color{red}m'}{\color{blue}\Rrightarrow \textbf{max}\left(m\right)} \:\wedge\: {\color{red}m''}{\color{blue}\Rrightarrow \textbf{max}\left(m\right)}$
\todo[inline]{in general this figure should be rethought, and images re-rendered. perhaps the table should be based on an arbitrary relation and the proofs should have the details filled in and specialized?}
\begin{tikzcd}
              & {\color{red}m} \tarrow[red]{rd} \tarrow[red]{ld} \arrow[lightgray]{dd} &                \\
{\color{red}m'} \tarrow[blue]{rd} &                                       & {\color{red}m''} \tarrow[blue]{ld} \\
              & {\color{blue} \textbf{max}(m)}                                &              
\end{tikzcd}

\vspace{0.1in}

\subsubsection*{Confluence}

$\forall{\color{red}m},{\color{red}n},{\color{red}n'}.\:{\color{red}m\Rrightarrow_{\ast}n}\:\wedge\:{\color{red}m\Rrightarrow_{\ast}n'}\ 
\mathrm{implies}\ 
\exists{\color{blue}n'''}.\:{\color{red}n}{\color{blue}\Rrightarrow_{\ast}{\color{blue}n'''}}\:\wedge\:{\color{red}n'}{\color{blue}\Rrightarrow_{\ast}{\color{blue}n'''}}$

\begin{tikzcd}
% TODO look into proper subscripting of arrow heads
  & {\color{red}m} \tarrows[red]{rd}[label={[pos=1,inner sep=0,outer sep=0]200:${}_{\ast}$}]{} 
      \tarrows[red]{ld}[label={[pos=1,inner sep=0,outer sep=0]340:${}_{\ast}$}]{} &              \\
{\color{red}n'}  \tarrows[blue]{rd}[label={[pos=1,inner sep=0,outer sep=0]200:${}_{\ast}$}]{} & 
  & {\color{red}n''} \tarrows[blue]{ld}[label={[pos=1,inner sep=0,outer sep=0]340:${}_{\ast}$}]{} \\
  & {\color{blue}{\color{blue}n'''}}                      &                             
\end{tikzcd}

\todo[inline]{absorb these diagrams into the proofs}

\caption{Rewriting Diagrams}
\label{fig:shape-diagrams}
\end{figure}
 
Since type equivalence is defined by parallel reductions we can show confluence following the proof in \cite{TAKAHASHI1995120}\footnote{
  Also well presented in \cite{KOKKE2020102440}.
}.
The approach is motivated by the diagrams in \Fref{shape-diagrams}.
 
First, we define a function $\textbf{max}$ in \Fref{surface-max-step}.\ccnote{keeping the order so that max stays motivated}
$\textbf{max}$ takes the maximum possible parallel step, such that if $m\Rrightarrow\,m'$ then $m'\Rrightarrow\,\textbf{max}\left(m\right)$. % and $m\Rrightarrow\,max\left(m\right)$.
 
\begin{figure}
\begin{tabular}{cccc}
$\textbf{max}($ & $x$ & $)=$ & $x$ \tabularnewline
$\textbf{max}($ & $m::M$ & $)=$ & $\textbf{max}\left(m\right)$ \tabularnewline
$\textbf{max}($ & $\star$ & $)=$ & $\star$ \tabularnewline
$\textbf{max}($ & $\left(x:M\right)\rightarrow N$ & $)=$ & $\left(x:\textbf{max}\left(M\right)\right)\rightarrow \textbf{max}\left(N\right)$ \tabularnewline
$\textbf{max}($ & $\mathsf{fun}\,f\,x\Rightarrow m$ & $)=$ & $\mathsf{fun}\,f\,x\Rightarrow \textbf{max}\left(m\right)$ \tabularnewline
$\textbf{max}($ & $\left(\mathsf{fun}\,f\,x\Rightarrow m\right)\,n$ & $)=$ & $\textbf{max}\left(m\right)\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow \textbf{max}\left(m\right),x\coloneqq \textbf{max}\left(n\right)\right]$ \tabularnewline
%  &   &   &  otherwise\tabularnewline
% \multicolumn{4}{c}{otherwise}\tabularnewline
&   &   &  \multicolumn{1}{l}{otherwise}\tabularnewline
$\textbf{max}($ & $m\,n$ & $)=$ & $\textbf{max}\left(m\right)\,\textbf{max}\left(n\right)$ \tabularnewline
\end{tabular}
\caption{The $\textbf{max}$ Function}
\label{fig:surface-max-step}
\end{figure}
 
\todo{for example}
 
\begin{lem} Triangle Property of $\Rrightarrow$.
 
If $m\Rrightarrow\,m'$ then $m'\Rrightarrow \textbf{max}\left(m\right)$ .
\end{lem}
\begin{proof}
By induction on the derivation $m\Rrightarrow\,m'$, with the only interesting cases are where a reduction is not taken:
\begin{casenv}
\item In the case of \rulename{\Rrightarrow-::}, $m'\Rrightarrow \textbf{max}\left(m\right)$, by \rulename{\Rrightarrow-::-red}.
\item In the case of \rulename{\Rrightarrow-\mathsf{fun}-app}, $m'\Rrightarrow \textbf{max}\left(m\right)$ by \rulename{\Rrightarrow-\mathsf{fun}-app-red}.\ccnote{All other cases follow directly by induction (the confustion my have come from the way I origionally noted the max function)}
\end{casenv}
\end{proof}

\begin{lem} Diamond Property of $\Rrightarrow$.
 
If $m\Rrightarrow\,m'$, $m\Rrightarrow\,m''$, implies $m'\Rrightarrow\,\textbf{max}\left(m\right)$, $m''\Rrightarrow\,\textbf{max}\left(m\right)$.
\end{lem}
\begin{proof}
By the triangle property.
 % Since $\textbf{max}\left(m\right)=\textbf{max}\left(m\right)$ .
\end{proof}

\begin{thm} Confluence of $\Rrightarrow_{\ast}$.
\label{thm:conf-par-red}
 
If $m\Rrightarrow_{\ast}\,n'$, $m\Rrightarrow_{\ast}\,n''$, then there exists $n'''$ such that $n'\Rrightarrow\,n'''$ ,$n''\Rrightarrow\,n'''$.
\end{thm}
\begin{proof}
By repeated application of the diamond property, ``tiling'' the interior region.\ccnote{i can'm still trying to find a cleaner way to write this with the word "induction"}
% % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZAZgBoAGAXVJADcBDAGwFcYkQQBfU9TXfQigAspAIzU6TVuy48QGbHgJEArKQBMEhizaIO3XooFEAbKWJapu8AHIbsw-2Up1YyzpkH5fJYOSiNd2k9B28jZ2RycyDrMHsvBSc-NSEYzzlE3yIRFTSQhJ9jFADUmm1g-QzCiNdcsqt0xyyUMhM82ztQzKKSQPqPfKrwvxELfoqu6r9XMckByqaeslK5ic4JGCgAc3giUAAzACcIAFskKJAcCCQAkEYsMGsoCGYAI0Y2GgALGHooJDAzEYjBoOHoWEY7Egj1CR1ON1B10QrjuDyeL3enxAPz+AKBIMu4MhemhbC8cLOyMRSDIqJhemeOBwmxA31+-xJBDJcgp52piBEdPRbw+rOx7LxwNBRKhXNhx0pgquSDUQvYzxFWJxHMBUsJENlMPJCpV-LM4txnJhNHu9JAjOZ-2N8MQtOViAA7Da0eqMaK2ZbdQSwQardyDibPfyABzeu0azFi7WS4MysPyl3m90ATjjwsTAZ1+OlofAcudlNzlyRogutvz-otRb1IeJZaNPMjserN1u9d9TJZhcN4ZAvMQtf5oj7PoZEEH-2H6YrSCVNZR-bnmqTEsQQZLbdJGcpt3dog3s-tfq1u-3+sP5c7LvPU9pm6v26Xd9bI+PSBRZ5vpeCaNsme7Fvev4rogqpnoK74gTegYQT+y5PieAE1vBwHXjuyEtmm7ajuOohujWqoIbhX4oYRR7QaIa43BROGfk2KYHlB6E3GRSBemqc4LnhHJEX+E6MYgVaUYJS4ifRsE1jO8bzo6QlQZQnBAA
% \begin{tikzcd}
%   &                                                       &                                                       & {} \arrow[rd, Rightarrow] \arrow[ld, Rightarrow] &                                                       &                                                       &                            \\
%   &                                                       & {} \arrow[ld, Rightarrow] \arrow[rd, Rightarrow]      &                                                  & {} \arrow[rd, Rightarrow] \arrow[ld, Rightarrow]      &                                                       &                            \\
%   & {} \arrow[ld, no head, dotted] \arrow[rd, Rightarrow] &                                                       & {} \arrow[rd, Rightarrow] \arrow[ld, Rightarrow] &                                                       & {} \arrow[rd, no head, dotted] \arrow[ld, Rightarrow] &                            \\
% n' \arrow[rd, Rightarrow] &                                                       & {} \arrow[rd, Rightarrow] \arrow[ld, no head, dotted] &                                                  & {} \arrow[ld, Rightarrow] \arrow[rd, no head, dotted] &                                                       & n'' \arrow[ld, Rightarrow] \\
%   & {} \arrow[rd, Rightarrow]                             &                                                       & {} \arrow[dd, no head, dotted]                   &                                                       & {} \arrow[ld, Rightarrow]                             &                            \\
%   &                                                       & {} \arrow[rd, no head, dotted]                        &                                                  & {} \arrow[ld, no head, dotted]                        &                                                       &                            \\
%   &                                                       &                                                       & n'''                                             &                                                       &                                                       &                           
% \end{tikzcd}
\end{proof}

It follows that

\begin{thm} $\equiv$ is transitive.
 
If $m\equiv m'$ and $m'\equiv m''$ then $m\equiv m''$
\end{thm}
\begin{proof}
Since if $m\equiv m'$ and $m'\equiv m''$ then by definition for some $n$, $n'$, $m\Rrightarrow_{\ast}n$, $m'\Rrightarrow_{\ast}n$ and $m'\Rrightarrow_{\ast}n'$, $m''\Rrightarrow_{\ast}n'$. If $m'\Rrightarrow_{\ast}n$ and $m'\Rrightarrow_{\ast}n'$.
Then by confluence there exists some $p$ such that $n\Rrightarrow_{\ast}p$ and $n'\Rrightarrow_{\ast}p$.
By transitivity $m\Rrightarrow_{\ast}p$ and $m''\Rrightarrow_{\ast}p$.
So by definition $m\equiv m''$.

% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAFsQBfU9TXfIRQAmclVqMWbdgHJuvEBmx4CRACxjq9Zq0QcZcnn2WCiARlJnx2qXsJHF-FUOQBmS9cm7whhUoGqIqTCnjpsaNziMFAA5vBEoABmAE4QnIhkIDgQSKIgAEYwYFBIrpkAFjB0JXYErA4paUiZ2UgWIJXVbJBg9QqN6e2tiHmdNeB18kmp6S05iO4gDFi9bFAQTPkMrNRjSGBMDAzUOHRYDN2TDTNtJ-OLy6t665vbILtVNQdHJ2cXtatrk1EEN5holitvC8tjsOp99odjlk-pdAf0biM7khwY8oRsYe84V1EN8kadzqi+tNgYthgBWai4tb4t4fYmk34UgFUkADbFYxAMiFPEDQ1lEr6Izn-CaAihcIA
\begin{tikzcd}
% m \deqs{rrrr}{bend left} \deqs{rr} \arrow[rd, Rightarrow] &                          & m' \arrow[rr, no head] \arrow[ld, Rightarrow] \arrow[rd, Rightarrow] &                           & m'' \arrow[ld, Rightarrow] \\
m \deqs{rr} \tarrows{rd}[label={[pos=1,inner sep=0,outer sep=0]200:${}_{\ast}$}]{}  &  & m' \deqs{rr} \tarrows{ld}[label={[pos=1,inner sep=0,outer sep=0]340:${}_{\ast}$}]{} \tarrows{rd}[label={[pos=1,inner sep=0,outer sep=0]200:${}_{\ast}$}]{}  &   & m''  \tarrows{ld}[label={[pos=1,inner sep=0,outer sep=0]340:${}_{\ast}$}]{} \\
                                                                                    & n \tarrows{rd}[label={[pos=1,inner sep=0,outer sep=0]200:${}_{\ast}$}]{}           &                                                                      & n'  \tarrows{ld}[label={[pos=1,inner sep=0,outer sep=0]340:${}_{\ast}$}]{} &                            \\
                                                                                    &                          & p                                                                    &                           &                           
\end{tikzcd}
\newline
\todo{clean up, diagram}
\end{proof}

\begin{fact} $\equiv$ is an equivalence relation.
\end{fact}
 
\subsubsection{Stability}
Next we confirm that type formers are never equated by definitional equality.
Specifically, $\left(x:N\right)\rightarrow M\cancel{\equiv}\star$.
If type formers are associated, the entire $\equiv$ relation may degenerate. % it will how we have defined it, it is convievable a more comlicated def eq relation could allow this in the presence of say inconsitent contexts
Since definitional equality is defined in terms of reduction, it is sufficient to show that $\left(x:N\right)\rightarrow M\Rrightarrow\left(x:N'\right)\rightarrow M'$.
We will prove slightly stronger lemmas about reduction that confirms this fact since it will be useful later.
\todo{why? where is it used}
 
\begin{lem} Stability of $\rightarrow$ over $\Rrightarrow_{\ast}$.
\label{lem:pi-stability}

$\forall N,M,P.\left(x:N\right)\rightarrow M\Rrightarrow_{\ast}P$ implies $\exists N',M'.P=\left(x:N'\right)\rightarrow M'\land N\Rrightarrow_{\ast}N'\land M\Rrightarrow_{\ast}M'$.
\end{lem}
\begin{proof}
By induction on $\Rrightarrow_{\ast}$:
\begin{casenv}
 \item $\rulename{\Rrightarrow_{\ast}-refl}$ follows directly.
 \item $\rulename{\Rrightarrow_{\ast}-trans}$ follows via the induction hypothesis and noting only the $\rulename{\Rrightarrow-\mathsf{fun}-ty}$ rule is possible as a step.
\end{casenv}
\end{proof}

Therefore, the we can derive an important fact about $\equiv$.

\begin{cor} Stability of $\rightarrow$ over $\equiv$.

The following rule is admissible:
\[
\frac{\left(x:N\right)\rightarrow M\equiv\left(x:N'\right)\rightarrow M'}{N\equiv N'\quad M\equiv M'}
\]
\end{cor}
\begin{proof}
By the definition of $\equiv$ and the lemma above.
\end{proof}
 
\subsection{Preservation}
 
A useful property of a type system is that reduction preserves type\footnote{
  Similar proofs for dependent type systems can be found in \cite[Chapter 3]{luo1994computation}, \cite[Section 3.1]{10.1007/3-540-45413-6_27}(including eta expansion in an implicit system), \cite[appendix]{sjoberg2012irrelevance}, and formalized in the the examples of Autosubst\cite{SchaeferEtAl:2015:Autosubst:-Reasoning}.
}.
\todo{push this further up?}
 
We need several more technical lemmas before we can prove that $\Rrightarrow_{\ast}$ is type preserving.
These lemmas will almost always be justified by induction on typing derivations.
% this allows the context to grow under the inductive hypothesis while still being well founded by the tree structure of the derivation.
 
\subsubsection{Structural Properties}
 
% unneeded: In many cases lemmas will produce derivations that are equal or smaller in height to one of the derivations used in their input, so that inductions can be performed on the output of the lemma while still being well founded.
\begin{thm} Context Weakening.
 
The following rule is admissible:
\[
\frac{\Gamma\tasys n:N}{\Gamma,\Gamma'\tasys n:N}
\]\ccnote{I am pervasivy asuming varaibles behave correctly over binding constructs, so I should probly note that up front}
\end{thm}
\begin{proof}
By induction on typing derivations.
\end{proof}

\begin{lem} Substitution preserves types.
 
The following rule is admissible: %\footnote{
%  This lemma is sufficient for our informal account of variable substitution and binding.
%  A fully formal account will be sensitive to the specific binding strategy, and we may need to prove this lemma as a corollary from simultaneous substitutions.
% }
\[
\frac{\Gamma\tasys n:N\quad\Gamma,x:N,\Gamma'\tasys m:M}{\Gamma,\Gamma'\left[x\coloneqq n\right]\tasys m\left[x\coloneqq n\right]:M\left[x\coloneqq n\right]}
\]
\end{lem}
\begin{proof}
By induction on typing derivations:
\begin{casenv}
 \item \rulename{ty-var} follows by weakening the substituted term.
 \item \rulename{ty-conv} follows from $\equiv\rulename{-Def}$ and that $\Rrightarrow_{\ast}$ is closed under substitution.
 \item All other cases follow directly or by induction.
\end{casenv}
\end{proof}

We extend the notion of definitional equality to contexts in \Fref{surface-Context-Equiv} so that we can ignore reductions in the context.
When contexts are convertible, typing judgments still hold.
\todo[inline]{why? This is needed to support reasoning under a binder.}
 
\begin{figure}
\[
\frac{\ }{\lozenge\equiv\lozenge}\,\rulename{\equiv-ctx-empty}
\]
 
\[
\frac{\Gamma\equiv\Gamma'\quad M\equiv M'}{\Gamma,x:M\equiv\Gamma',x:M'}\,\rulename{\equiv-ctx-ext}
\]
 
\caption{Definitionally Equal Contexts}
\label{fig:surface-Context-Equiv}
\end{figure}
 
\begin{lem}
% Context Preservation
Contexts that are equivalent preserve types.
 
The following rule is admissible:
\[
\frac{\Gamma\tasys n:N\quad\Gamma\equiv\Gamma'}{\Gamma'\tasys n:N}
\]
\end{lem}
\begin{proof}
By induction over typing derivations:
\begin{casenv}
 \item \rulename{ty-var} follows since $\equiv$ is symmetric.
% \item \rulename{ty-\mathsf{fun}-ty} and \rulename{ty-\mathsf{fun}} ...
 \item All other cases follow directly or by induction.
\end{casenv}
\end{proof}
 
\subsubsection{Inversion Lemmas}
In the preservation proof we will need to reason backwards about the typing judgments implied by a typing derivation of a term with specific syntax.
These are conventionally called inversion lemmas since they mirror the typing judgments.
But unlike typing derivations which take in typing derivations for subterms, inversion lemmas conclude typing derivations for subterms.
For this Chapter we will only need to prove an inversion lemma for functions.
 
In a dependently typed setting, inversion lemmas cannot be proven directly by induction.
The induction hypothesis must be extended over definitional equality.
 
\begin{lem} $\mathsf{fun}$-Inversion (generalized).
 
\[
\frac{\Gamma\tasys\mathsf{fun}\,f\,x\Rightarrow m\,:\,P\quad P\equiv\left(x:N\right)\rightarrow M}{\Gamma,f:\left(x:N\right)\rightarrow M,x:N\tasys m:M}
\]
 
is admissible.
\end{lem}
\begin{proof}
By induction on typing derivations:
 
\begin{casenv}
 \item \rulename{ty-\mathsf{fun}} follows by the stability of \rulename{ty-\mathsf{fun}} and preservation of contexts.
 \item \rulename{ty-conv} follows by transitivity of $\equiv$ and induction.
 \item All other cases are impossible!
\end{casenv}
\end{proof}

This allows us to conclude the more straightforward corollary:

\begin{cor} $\mathsf{fun}$-Inversion.
 
\[
\frac{\Gamma\tasys\mathsf{fun}\,f\,x\Rightarrow m\,:\,\left(x:N\right)\rightarrow M}{\Gamma,f:\left(x:N\right)\rightarrow M,x:N\tasys m:M}
\]
\end{cor}
\begin{proof}
By noting that $\left(x:N\right)\rightarrow M\equiv\left(x:N\right)\rightarrow M$, by reflexivity.
\end{proof}

\begin{thm} $\Rrightarrow$ Preserves types.
 
The following rule is admissible:
\[
\frac{\Gamma\tasys m:M\quad m\Rrightarrow m'}{\Gamma\tasys m':M}
\]
\end{thm}
\begin{proof}
By induction on the typing derivation $\Gamma\tasys m:M$, specializing on $m\Rrightarrow m'$:
\todo{formatting}
\begin{casenv}
 \item \rulename{ty-::} when \rulename{\Rrightarrow-::}, ($m=n:N$, $m'=n':N'$, $M=N$ for some $n$, $N$, $n'$, and $N'$) we must show $\Gamma\tasys n'::N':\,N$ % and $\Gamma\tasys N':\star$
  from $\Gamma\tasys n\,:\,N$, $\Gamma\tasys N\,:\,\star$, $n\Rrightarrow n'$, and $N\Rrightarrow N'$ .
  \newline
  \begin{tabular}{ll}
   $\Gamma\tasys N':\star$ & by induction\tabularnewline
   $\Gamma\tasys n'\,:\,N$ & by induction\tabularnewline
   $N\equiv N'$ & by $N\Rrightarrow N'$\tabularnewline
   $\Gamma\tasys n'\,:\,N'$ & by \rulename{ty-conv}\tabularnewline
   $\Gamma\tasys n'::N':\,N'$ & by \rulename{ty-::}\tabularnewline
   $N'\equiv N$ & by symmetry of $\equiv$\tabularnewline
   $\Gamma\tasys n'::N':\,N$ & by \rulename{ty-conv}\tabularnewline
 \end{tabular}
 \item \rulename{ty-\mathsf{fun}-ty} when \rulename{\Rrightarrow-\mathsf{fun}-ty} can be shown with preservation of contexts
 \item \rulename{ty-\mathsf{fun}-app} when \rulename{\Rrightarrow-\mathsf{fun}-app-red}, we must show
   \newline
   $\Gamma\tasys m'\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow m',x\coloneqq n'\right]:M\left[x\coloneqq n\right]$
   \newline
    from $\Gamma\tasys n\,:\,N$, $\Gamma\tasys\mathsf{fun}\,f\,x\Rightarrow m\,:\,\left(x:N\right)\rightarrow M$, $m\Rrightarrow m'$, and $n\Rrightarrow n'$.
 \newline
 \begin{tabular}{ll}
   $\mathsf{fun}\,f\,x\Rightarrow m\Rrightarrow\mathsf{fun}\,f\,x\Rightarrow m'$ & by \rulename{\Rrightarrow-\mathsf{fun}}\tabularnewline
   $\Gamma\tasys\mathsf{fun}\,f\,x\Rightarrow m'\,:\,\left(x:N\right)\rightarrow M$ & by induction\tabularnewline
   $\Gamma,f:\left(x:N\right)\rightarrow M,x:N\tasys m'$ & by fun-inversion\tabularnewline
   $\Gamma\tasys n'\,:\,N$ & by induction\tabularnewline
   \makecell[l]{$\Gamma\tasys m'\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow m',x\coloneqq n'\right]$\\$\ :M\left[x\coloneqq n'\right]$} & by substitution preservation \tabularnewline
   $M\left[x\coloneqq n\right] \equiv M\left[x\coloneqq n'\right]$ & by substitution by $\Rightarrow$\tabularnewline
   \makecell[l]{$\Gamma\tasys m'\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow m',x\coloneqq n'\right]$\\$\ :M\left[x\coloneqq n\right]$} & by \rulename{ty-conv}\tabularnewline
 \end{tabular}
 \item \rulename{ty-\mathsf{fun}-app} when \rulename{\Rrightarrow-\mathsf{fun}-app}, we must show
 \newline
 $\Gamma\tasys m'\,n':\,M\left[x\coloneqq n\right]$ 
 from $\Gamma\tasys n\,:\,N$, $\Gamma\tasys m\,:\,\left(x:N\right)\rightarrow M$, $m\Rrightarrow m'$, $n\Rrightarrow n'$.
 \newline
 \begin{tabular}{ll}
   $n\Rrightarrow n'$ & \tabularnewline
   $\Gamma\tasys m'\,:\,\left(x:N\right)\rightarrow M$ & by induction\tabularnewline
   $\Gamma\tasys n'\,:\,N$ & by induction\tabularnewline
   $\Gamma\tasys m'\,n':\,M\left[x\coloneqq n'\right]$ & \rulename{ty-\mathsf{fun}-app}\tabularnewline
   $M\left[x\coloneqq n\right] \equiv M\left[x\coloneqq n'\right]$ & by substitution by $\Rightarrow$\tabularnewline
   $\Gamma\tasys m'\,n':\,M\left[x\coloneqq n\right]$ & \rulename{ty-conv}\tabularnewline
 \end{tabular}
 \item All other cases follow directly or by induction
\end{casenv}
\end{proof}
 
\subsection{Progress}
 
The second key theorem to show in this style of proof is called progress.\todo{awk, it's name is the least interasting thing}
The progress theorem states: for a well typed term in an empty context, then a further step can be taken or computation is finished.\ccnote{fix after restructure}
For non-dependently typed programming languages, these steps are easy to characterize, but for dependent types there are issues.\todo{awk}
If we characterize computation with the $\Rrightarrow$ relation, the progress lemma holds in a meaningless way since we can always take a reflexive step.
Thus a less reflexive relation is needed.
Ideally the relation should also be deterministic and a sub relation of $\Rrightarrow_{*}$.
We can choose a \cbv{} relation since that % this meets all the properties required, and 
  is a popular execution strategy that reflects the prototype implementation.\ccnote{fix after restructure}
 
\begin{figure}
\begin{tabular}{lcl}
\multicolumn{3}{l}{values,}\tabularnewline
v & $\Coloneqq$ & $\star$\tabularnewline
 & $|$ & $\left(x:M\right)\rightarrow N$\tabularnewline
 & $|$ & $\mathsf{fun}\,f\,x\Rightarrow m$\tabularnewline
\end{tabular}\caption{\SLang{} Value Syntax}
\label{fig:surface-value-syntax}
\end{figure}
 
Values are characterized by the sub-grammar in \Fref{surface-value-syntax}.
As usual, functions with any body are values.
Additionally, the type universe ($\star$) is a value, and function types are values.
 
\begin{figure}
\[
\frac{\,}{\left(\mathsf{fun}\,f\,x\Rightarrow m\right)v\rightsquigarrow m\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow m,x\coloneqq v\right]}
\]
 
\[
\frac{m\rightsquigarrow m'}{m\,n\rightsquigarrow m'\,n}
\]
 
\[
\frac{n\rightsquigarrow n'}{v\,n\rightsquigarrow v\,n'}
\]
 
\[
\frac{m\rightsquigarrow m'}{m::M\rightsquigarrow m'::M}
\]
 
\[
\frac{\,}{v::M\rightsquigarrow v}
\]
 
\caption{\SLang{} \CbV{} Reductions}
\label{fig:surface-reduction-step}
\end{figure}
 
A \cbv{} relation is defined in \Fref{surface-reduction-step}.
The reductions are standard for a \cbv{} lambda calculus, except that type annotations are only removed from values.
 
\todo{explicitly define stuck}
\begin{fact} $\rightsquigarrow$ implies $\Rrightarrow$.
 
The following rule is admissible:
 
\[
\frac{m\rightsquigarrow m'}{m\Rrightarrow m'}
\]
\end{fact}
 
Thus $\rightsquigarrow$ also preserves types.
 
We will need a technical lemma that determines the syntax of a value in an empty context.
These lemmas are usually called canonical form lemmas.
Since the language of this chapter is so minimal, we only need to characterize the canonical form of functions.
 
\begin{lem} $\mathsf{fun}$-Canonical form (generalized).

If $\tasys v\,:\,P$ and $P\equiv\left(x:N\right)\rightarrow M$ then for some m $v=\mathsf{fun}\,f\,x\Rightarrow m$. \ccnote{don't want to quantifie over the bound varibles since that implies a non debroign interpertation}
\end{lem}
\begin{proof}
By induction on the typing derivation,
 
\begin{casenv}
\item \rulename{ty-\mathsf{fun}} follows immediately
\item \rulename{ty-conv} by the equivalence\ccnote{keeping this "equivalence" instead of "transitivity" becuase I think you also need to ues symmetry} of $\equiv$ and induction
\item \rulename{ty-\star}, \rulename{ty-\mathsf{fun}-ty} are impossible, by the stability of $\equiv$
\item other rules  are impossible, since they do not type values
\end{casenv}
\end{proof}

As a corollary,

\begin{cor} $\mathsf{fun}$-Canonical form.
 
If $\tasys v\,:\,\left(x:N\right)\rightarrow M$ then \textup{$v=\mathsf{fun}\,f\,x\Rightarrow m$.}
\end{cor}
 
\todo{note that by only considering values, we can avoid the problematic application case}
 
Finally we can prove the progress theorem.
\begin{thm} Progress.
 
If $\tasys m\,:\,M$ then $m$ is a value or there exists $m'$ such that $m\rightsquigarrow m'$
\end{thm}
\begin{proof}
As usual this follows form induction on the typing derivation
 
\begin{casenv}
 \item \rulename{ty-\star}, $\star$ is a value.
 \item \rulename{ty-var}, impossible in an empty context!
 \item \rulename{ty-conv}, by induction.
 \item \rulename{ty-::}, we have a typing derivation concluding $\tasys m::M\,:\,M$.
 By induction, $m$ is a value or there exists $m'$ such that $m\rightsquigarrow m'$:
 \begin{casenv}
   \item If $m$ is a value, then $m::M\rightsquigarrow m$.
   \item If $m\rightsquigarrow m'$,then $m::M\rightsquigarrow m'::M$.
 \end{casenv}
 \item \rulename{ty-\mathsf{fun}-ty}, $\left(x:M\right)\rightarrow N$ is a value.
 \item \rulename{ty-\mathsf{fun}}, $\mathsf{fun}\,f\,x\Rightarrow m$ is a value.
 \item \rulename{ty-\mathsf{fun}-app}, we have a typing derivation concluding $\tasys m\,n\ :\ M\left[x\coloneqq n\right]$ with the premises $\tasys m\,:\,\left(x:N\right)\rightarrow M$, $\Gamma\tasys n\,:\,N$.
 By induction, $m$ is a value or there exists $m'$ such that $m\rightsquigarrow m'$.
 By induction, $n$ is a value or there exists $n'$ such that $n\rightsquigarrow n'$.
 \begin{casenv}
   \item if $m\rightsquigarrow m'$, then $m\,n\rightsquigarrow m'\,n$
   \item if $m$ is a value, and $n\rightsquigarrow n'$,  then $m\,n\rightsquigarrow m\,n'$
   \item if $m$ is a value, and $n$ is a value, then $m=\mathsf{fun}\,f\,x\Rightarrow p$ by canonical forms of functions.
     The term steps $\left(\mathsf{fun}\,f\,x\Rightarrow p\right)n\rightsquigarrow p\left[f\coloneqq\mathsf{fun}\,f\,x\Rightarrow p,x\coloneqq n\right]$.
 \end{casenv}
\end{casenv}
 
\end{proof}
\todo{awk}
Progress via \cbv{} can be seen as a specific sub-strategy of $\Rrightarrow_*$.
An interpreter is always free to take any $\Rrightarrow_*$, but if it is unclear which $\Rrightarrow_*$ to take, either it is a value and no further steps are required, or can fall back on $\rightsquigarrow$ until the computation is a value.
% (or optimizing compiler, or JIT) 

\subsection{Type Soundness}
 
The language has type soundness: well typed terms will never ``get stuck'' in the \slang{}.

\begin{thm} Type Soundness.
 
If $\tasys m\,:\,M$ and $m\rightsquigarrow_\ast m'$ then $m'$ will not get stuck.\ccnote{come back to this after I add that section}
\end{thm}
\begin{proof}
This follows by iterating the progress and preservation lemmas.
\end{proof}

\todo{name thoerems, better case info}

\todo{be explicit about the disconnect between type computation via par, and term level cbv}
 
% \todo{other lemmas not needed for this proof, par max is par, inversions?}
 
 
% \subsection{Regularity}
% The rules in \Fref{surface-TAS} allow for invalid constructions in the context.
% For instance, $x:1_{c}\tasys...$ is allowed by the context grammar.
% Additionally, it is not required that both ends of a conversion are well typed.
% For instance, $\tasys\ \star\ :\ (\lambda - \Rightarrow \star)\,(\star\,\star)$ is typeable by conversion.
 
% \begin{figure}
% \[
% \frac{\Gamma\,\mathbf{ok}\quad x:M\in\Gamma}{\Gamma\tasysr{}x\,:\,M}\,\rulename{ty-var}
% \]
 
% \[
% \frac{\Gamma\tasysr{}m\,:\,M}{\Gamma\tasysr{}m::M\,:\,M}\,\rulename{ty-::}
% \]
 
% \[
% \frac{\Gamma\,\mathbf{ok}}{\Gamma\tasysr{}\star\,:\,\star}\,\rulename{ty-\star}
% \]
 
% \[
% \frac{\Gamma\tasysr{}M\,:\,\star\quad\Gamma,x:M\tasysr{}N\,:\,\star}{\Gamma\tasysr{}\left(x:M\right)\rightarrow N\,:\,\star}\,\rulename{ty-\mathsf{fun}-ty}
% \]
 
% \[
% \frac{\Gamma\tasysr{}m\,:\,\left(x:N\right)\rightarrow M\quad\Gamma\tasysr{}n\,:\,N}{\Gamma\tasysr{}m\,n\,:\,M\left[x\coloneqq n\right]}\,\rulename{ty-\mathsf{fun}-app}
% \]
 
% \[
% \frac{\Gamma,f:\left(x:N\right)\rightarrow M,x:N\tasysr{}m\,:\,M}{\Gamma\tasysr{}\mathsf{fun}\,f\,x\Rightarrow m\,:\,\left(x:N\right)\rightarrow M}\,\rulename{ty-\mathsf{fun}}
% \]
 
% \[
% \frac{\Gamma\tasysr{}m\,:\,M\quad\Gamma\tasysr{}M\equiv M'\,:\,\star}{\Gamma\tasysr{}m\,:\,M'}\,\rulename{ty-conv}
% \]
 
% \[
% \frac{\Gamma\tasysr{}m\,:\,M\quad\Gamma\tasysr{}m'\,:\,M\quad m\Rrightarrow m''\quad m'\Rrightarrow m''}{\Gamma\tasysr{}m\equiv m'\,:\,M}\,\rulename{def}
% \]
 
% \[
% \frac{\ }{\lozenge\,\mathbf{ok}}\,\rulename{emp-ok}
% \]
 
% \[
% \frac{\Gamma\tasysr{}M:\star\quad\Gamma\,\mathbf{ok}}{\Gamma,x:M\,\mathbf{ok}}\,\rulename{emp-ok}
% \]
% \caption{Type assignment system (regular)}
% \label{fig:surface-tas-reg}
% \end{figure}
 
% To make use of this more restricted system we need a lemma that will lift \ac{TAS} derivations into the regular system.
% % ctx ok then type is convertible to a well typed type
 
% \todo{first restrict the annotation rule to well typed terms}
 
% \begin{conjecture}
%   If $\Gamma\tasys{}m:M$, $\Gamma\,\mathbf{ok}$, $M\equiv M'$ and $\Gamma\tasysr{}M':\star$ then $\Gamma\tasysr{}m:M'$
% \end{conjecture}
% % \begin{proof}
 
% % \end{proof}
 
 
 
% Though these restrictions are not required for type soundness, it will be convenient to exclude these possibilities by adding additional restrictions to the \ac{TAS}.
% The updated system is presented in \Fref{surface-tas-reg}.
% The $\mathbf{ok}$ forces contexts to only contain well typed types.
% The new conversion rule restricts conversion to well typed types.
 
 
 
% \begin{thm}
%   Regularity

 %   If $\Gamma\tasysr{}m:M$ then $\Gamma\tasysr{}M:\star$ and $\Gamma\,\mathbf{ok}$
% \end{thm}
% \begin{proof}
%   by induction on typing derivations. The only interesting case is \rulename{ty-\mathsf{fun}-app}. 
% \end{proof}
 
 
% Given these restrictions we can conclude some convenient regularity properties.
% \begin{thm}
%   Regularity

 %   If $\Gamma\tasysr{}m:M$ then $\Gamma\tasysr{}M:\star$ and $\Gamma\,\mathbf{ok}$
% \end{thm}
% \begin{proof}
%   by induction on typing derivations
% \end{proof}
 
% \begin{conjecture}
% The regular system has progress and preservation it is type sound
% \end{conjecture}
 
% Additionally,
 
% It is possible to prove type soundness directly but it involves a more subtle mutual induction.
 
% Given this we will use the regular system from now on without subscript.
 
% % There is some question about how much typing information should be coupled to the judgment, forcing contexts to be well formed eliminates nonsense situations like $x:1_{c}\vdash...$ by construction, but requires more fork when forming judgments that can be distracting.
% % The proofs in this section can be done without forcing the context to be well formed, the additional constraints are omitted.
% % \todo[inline]{regularity!}
 
\subsection{Type Checking Is Impractical}
 
This type system is inherently non-local.
No type annotations are ever required to form a typing derivation.
That means that a type checking algorithm that attempted to type check every well typed \ac{TAS} term would need to guess the types of intermediate terms.
For instance, a large function might use its argument different ways in different locations, as in
 
\begin{align*}
\lambda f\Rightarrow & \,\\
... & f\,1_{c}\,true_{c}\\
... & f\,0_{c}\,1_{c}\\
... & 
\end{align*}
\ccnote{edited this to be clearer, but I want to highlight the impracticality that comes from the inherent non-localness of a TAS as distinct from the lack of a "most general" type}

What is the type of $f$? One possibility is $f:\left(n:\mathbb{N}\right)\rightarrow n\,\star\,\left(\lambda-\Rightarrow\mathbb{N}_{c}\right)\,\mathbb{B}_{c}\rightarrow...$ .
But there are many other possibilities.
Worse, if there is an error, it may be impossible to localize to a specific region of that expression.
To make a practical type checker the user will need to include some type annotations.