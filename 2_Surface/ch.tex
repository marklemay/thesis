\chapter{A Dependent Type System}
\label{chapter:Surface}
\thispagestyle{myheadings}

% \section{Introduction}

Despite the usability issues this thesis hopes to correct, dependent type systems are still one of the most promising technologies for correct programming.
Since proofs are programs, there is no additional syntax for programmers to learn.
The proof system is predictable from the perspective of a functional programmer. 
\todo{awk sentence}

The \textbf{surface type system}\todo{is there a better name then surface lang?} presented in this chapter provides a minimal dependent type system.
The rules of the type system are intended to be as simple as possible and compatible with other well studied intentional dependent type theories.
It has several (but not all) of the standard properties of dependent type theory.
As much as possible, the syntax uses standard modern notation\footnote{
  Several alternative syntaxes exist in the literature.
  In this document the typed polymorphic identity function is written, $\lambda-\,x\Rightarrow x\ :\,\left(X:\star\right)\rightarrow X\rightarrow X$.
  In \cite{10.1016/0890-5401(88)90005-3} it might be written $\left(\lambda X:\star\right)\left(\lambda x:X\right)x\ :\,\left[X:\star\right]\left[x:X\right]X$.
  In \cite{HoTTbook} it might be written $\lambda X.\lambda x.x\ :\,\underset{\left(X:\mathcal{U}\right)}{\prod}X\rightarrow X$.}\todo{Martin Loff/Hoff (TODO pr notation)}.

The surface type system will serve both as foundation for later chapters and a self contained technical introduction to dependent types.
Even when useing the full system described in later chapters, programmers will only need to think about the surface system.
By design, the machinery that deals with equality addressed in later chapters will be invisible to programers.
Everything presented in later chapters is designed to reinforce an understanding of the surface type system, and make it easier to use.

% overview, What
The surface language deviates from a standard dependent type theory to include features for programming at the expense of logical correctness.
Specifically the language allows general recursion, since general recursion is useful for programmers.
\Tit{} is also supported since it simplifies the system, and makes the meta-theory slightly easier.
Despite this, type soundness is achievable, and a practical type checking system is given.

Though similar systems have been studied over the last few decades this chapter aims to give a self contained presentation, along with examples.
The surface language has been a good platform to conduct research into full spectrum dependent type theory, and hopefully this exposition will be a helpful introduction for other researchers.

\section{Surface Language Syntax}

% What syntax
The syntax for the surface language is in \Fref{surface-pre-syntax}.
The syntax supports: variables, type annotations, a single type universe, dependent function types, recursive dependent functions, and function applications.
Type annotations are written with two colons to differentiate it from the formal typing judgments that will appear more frequently in this text.
In the implemented language a user of the programming language would use a single colon.

There is no distinction between types and terms in the syntax\footnote{
  terms and types are usually separated, except in the syntax of full-spectrum dependent type systems where separating them would require many redundant rules.
  }, both are referred to as expressions.
However, capital metavariables are used in positions that are intended as types, and lowercase metavariables are used when an expression is intended to be a term.
For instance, in annotation syntax where $m::M$ means $m$ can be a term and $M$ should be a type.
% Metavariables that intend to quantify equivalent terms will be noted with primes or subscripts, 
% Metavariables that type other metavairbles will often use the same letter

\todo{more about f being recursive?}
\todo{extrinsic}

\begin{figure}
% \begin{grammar}{x,y,z,f}{variable identifier}
% \end{grammar}
% \begin{grammar}{\Gamma\Coloneqq}{type context}
%   \mathbf{\lozenge}                        & empty context \\
%   \mathbf{Gamma,x:M}                       & extend context with x of type M \\
% \end{grammar}

\begin{tabular}{lcll}
\multicolumn{4}{l}{variable identifiers,}\tabularnewline
\multicolumn{4}{l}{$x,y,z,f$}\tabularnewline
\multicolumn{4}{l}{expressions,}\tabularnewline
$m,n,M,N$ & $\Coloneqq$ & $x$ & variable\tabularnewline
  & $|$ & $m::M$ & annotation\tabularnewline
  & $|$ & $\star$ & type universe\tabularnewline
  & $|$ & $\left(x:M\right)\rightarrow N$ & function type\tabularnewline
  & $|$ & $\mathsf{fun}\,f\,x\Rightarrow m$ & function\tabularnewline
  & $|$ & $m\,n$ & application\tabularnewline
\multicolumn{4}{l}{type contexts,}\tabularnewline
$\Gamma$ & $\Coloneqq$ & $\lozenge$ $|$ $\Gamma,x:M$ & \tabularnewline
\end{tabular}\caption{Surface Language Syntax}
\label{fig:surface-pre-syntax}
\end{figure}
  
Several standard abbreviations are listed in \Fref{surface-pre-syntax-abrev}.
\begin{figure}
\begin{tabular}{lclll}
$\left(x:M\right)\rightarrow N$ & written & $M\rightarrow N$ & when  & $x\notin fv\left(N\right)$\tabularnewline
$\mathsf{fun}\,f\,x\Rightarrow m$ & written & $\lambda x\Rightarrow m$ & when  & $f\notin fv\left(m\right)$\tabularnewline
$...\,x\Rightarrow\lambda y\Rightarrow m$ & written & $...\,x\,y\Rightarrow m$ &  & \tabularnewline
$x$ & written & $-$ & when  & $x\notin fv\left(m\right)$ when $x$ binds $m$\tabularnewline
\end{tabular}
  
where $fv$ is a function that returns the set of free variables in an expression
\caption{Surface Language Abbreviations}
\label{fig:surface-pre-syntax-abrev}
\end{figure}

\input{2_Surface/2_Examples}
\input{2_Surface/3_TAS}
\input{2_Surface/4_Bidir}

\section{Related work}

\subsection{Bad logics, ok programming languages?}

Unsound logical systems that work as programming languages go back to at least Church's lambda calculus which was originally intended to be part of a foundation for mathematics\footnote{``There may, indeed, be other applications of the system than its use as a logic.''{[}Church, 1932, p.349, A Set of Postulates for the Foundation of Logic{]}}.\todo{proper citation}
In the 1970s, Per Martin-L{\"o}f proposed a system with \tit{}\todo{cite it?} that was shown logically unsound by Girard (as described in the introduction in \cite{Martin-Lof-1972}).
In the 1980s, Cardelli explored the domain semantics of a system with general recursive dependent functions and \tit{}\cite{cardelli1986polymorphic}.
Independently, Viggo and Stoltenberg-Hansen\cite{PALMGREN1990135} explored the domain semantics of Martin-L{\"o}f's type theory with a fixed point operator.
\todo{Per Martin-L{\"o}f anticipated this work in unpublished lectures and an Abstract.}

The first progress and preservation style proof of type soundness for a language with general recursive dependent functions and \tit{} seem to come from the Trellys Project\cite{sjoberg2012irrelevance}.
At the time their language had several additional features not included in the surface language.
Additionally, the surface language uses a simpler notion of definitional equality resulting in a simpler proof of type soundness.
Later work in the Trellys Project\cite{casinghino2014combining,casinghino2014combiningthesis} used modalities to separate terminating and non-terminating fragments of the language, to allow both general recursion and logically sound reasoning.%, though the annotation burden seems high in retrospect .
In general, the surface language has been deeply informed by the Trellys project\cite{sjoberg2012irrelevance,casinghino2014combining,casinghino2014combiningthesis,sjoberg2015programming,sjoberg2015dependently} and the Zombie language\footnote{https://github.com/sweirich/trellys} it produced.

\todo{type in type as a well known shortcut, videos of Andraj, Conner MB saying it }
\todo{section on \bidir{} dependent type systems, citing http://www.cse.chalmers.se/\textasciitilde nad/publications/altenkirch-et-al-flops2010.pdf https://www.seas.upenn.edu/\textasciitilde sweirich/papers/congruence-extended.pdf posibly https://arxiv.org/pdf/1203.4716.pdf https://drops.dagstuhl.de/opus/volltexte/2021/13919/pdf/LIPIcs-ITP-2021-24.pdf}

\subsection{Implementations}

Several programming language implementations support features of the surface language without a proof of type soundness.
Pebble\cite{10.1007/3-540-13346-1_1} was a very early language with dependent types, though conversion did not associate alpha\todo{if saying alpha need to define it} equivalent types\footnote{according to \cite{Reinhold89typecheckingis}}.
Coquand implemented an early \bidir{} algorithm to type-check a language with \tit{}\cite{COQUAND1996167}.
Cayenne\cite{10.1145/289423.289451} is a Haskell-like language that combines dependent types with \tit{} and non-termination.
$\Pi$$\Sigma$\cite{10.1007/978-3-642-12251-4_5} is a language with \tit{} and several features for a dependently typed core calculus outlined here.
Like here $\Pi$$\Sigma$ advocates seperating terminaition concerns from type soundness concerns, though I am unaware if type soundness was ever established.
Agda supports general recursion and \tit{} with compiler flags.
Idris supports similar ``unsafe'' features.

\subsection{Other Dependent Type Systems}

There are many flavors of dependent type systems that are similar in spirit to the language presented here, but maintain logical soundness at the expense of computation.

The Calculus of Constructions (\ac{CC}, CoC)\cite{10.1016/0890-5401(88)90005-3} is one of the first minimal dependent type systems.
It contains shockingly few rules, but can express a wide variety of constructions via parametric encodings.
The system does not allow \tit{}, instead type\footnote{called \textbf{prop}, for proposition} lives in a larger universe $\star:\Square$, where $\Square$ is not considered a type.
Even though the Calculus of Constructions does not allow \tit{} it is still \textbf{impredicative} in the sense that function types can quantify over $\star$ while still being in $\star$.
For instance, the polymorphic identity $id:(X:\star)\rightarrow X\rightarrow X$ has type $\star$ so the polymorphic identity can be applied to itself, $id\,\left((X:\star)\rightarrow X\rightarrow X\right)\,id$.
From the perspective of the surface language this impredictivity is modest, but still causes issues in the presence of classical logical assumptions. \todo{Cite}
Many of the examples from this chapter are adapted from examples that were first worked out for the Calculus of Constructions.

Several other systems were developed that directly extended or modified the Calculus of Constructions.
The Extended Calculus of Constructions (\ac{ECC})\cite{luo1990extended,luo1994computation}, extends the Calculus of Constructions with a predicative hierarchy of universes and dependent pair types.
The Implicit Calculus of Constructions (\ac{ICC})\cite{10.1007/3-540-45413-6_27,10.1007/978-3-540-78499-9_26} presents an extrinsic typing system\footnote{
  Sometimes called \textbf{Curry-style}, in contrast to intrinsic systems which are sometimes called \textbf{Church-style}.
  }, unlike the Type Assignment System presented in this chapter, the Implicit Calculus of Constructions allows implicit qualification over terms in addition to explicit quantification over terms (also a hierarchy of universes, and a universe of ``sets'').
Other extensions to the Calculus of Constructions that are primarily concerned with data will be surveyed in Chapter 4.

The lambda cube\todo{cite!} is a system for relating 8 interesting typed lambda caluli to each other.
Presuming terms should always depend on terms, there are 3 additional dimensions of dependency: term depending on types, types dependent on types, and types depending on terms.
The simply typed lambda calculus has only term dependency.
System F additionally allows Types to depend on types.
The Calculus of Constructions has all forms of dependency\footnote{Recommended reading Chapter 14 \cite{sorensen2006lectures}}.

Pure Type Systems (\ac{PTS})\footnote{previously called \textbf{Generalized Type Systems}} generalizes the lambda cube to allow any number of type universes with any forms of dependency.
Notably this includes the system with one type universe where \tit{}.
Universe hierarchies can also be embedded in a \ac{PTS}.
The system described in this chapter is almost a \ac{PTS}, except that it contains unrestricted recursion and the method of type annotation is different.
All pure type systems such as System F and the Calculus of Constructions have corresponding terms in the Surface Language, by renaming their type universes into the surface language type universe.

\todo{citations for PTS: (Terlouw, 1989; Berardi, 1988; Barendregt, 1991, 1992; Jutting, McKinna, and Pollack, 1994; McKinna and Pollack, 1993; Pollack, 1994).
According to TAPL}

As previously mentioned Martin L{\"o}f Type Theory (\ac{MTLL})\cite{Martin-Lof-1972} is one of the oldest frameworks for dependent type systems.
MLTT is designed to be open, so that new constructs can be added with the appropriate introduction, elimination, computation, and typing rules.
The base system comes with a predicative hierarchy of universes, and at least dependently typed functions and a propositional equality type.
The system has two flavors characterized by its handling of definitional equality.
If types are only identified by convertibility (as the system described in this chapter) it is called Intentional Type Theory (\ac{ITT}).
If the system allows proofs of equality to associate types, it is called Extensional Type Theory (\ac{ETT}).
Since \ac{MTLL} is open ended, the Calculus of Constructions can be added to it as a subsystem\cite{aspinall2004dependent,hofmann1997extensional}.

\todo{go back to Russle?}
\todo{solving universe constraints?}
\todo{cite the autosubst proof}



% \bidir{}
% [109] Benjamin C. Pierce and David N. Turner. Local type inference. ACM Transactions on Programming Languages and Systems, 22(1):1–44, January 2000.

% cbn
%  Vilhelm Sj¨oberg and Aaron Stump. Equality, quasi-implicit products, and large
% eliminations. In ITRS 2010: Proceedings of the 5th workshop on Intersection
% Types and Related Systems, 2010. doi: 10.4204/EPTCS.45.7.


% atosubst