module elab where

open import presyntax
open import bidir

import precast as c
import cast as c


open import Data.Nat
open import Data.Fin hiding (_+_)
-- open import Data.Vec   hiding (lookup ; [_])
open import Data.Sum  hiding (map)
open import Data.Product hiding (map)
open import Relation.Nullary -- using (¬_)
open import Data.Empty
open import Relation.Binary.PropositionalEquality hiding ([_])


data _|-_ELAB_:->:_ {n : ℕ} (Γ : c.Ctx {n}) : PreSyntax {n} -> c.PreSyntax {n}  -> c.PreSyntax {n} -> Set
data _|-_ELAB_:<-:_ {n : ℕ} (Γ : c.Ctx {n}) : PreSyntax {n} -> c.PreSyntax {n}  -> c.PreSyntax {n} -> Set


postulate
  _c~>p*_ :  {n : ℕ} -> c.PreSyntax {n} -> c.PreSyntax {n} -> Set
  _c[_] :  {n : ℕ} -> c.PreSyntax {suc n} -> c.PreSyntax {n} -> c.PreSyntax {n}


{-
  o : {n : ℕ} {a aTy ty : PreSyntax {n}} {Γ : Ctx} -> Γ |- a :->: aTy -> {Ty : Γ |- ty :<-: pTyU}
    -> Ext Γ Ty |- po a :<-: po aTy
    
{-
  o-== : {n : ℕ} {a a' aTy ty : PreSyntax {n}} {Γ : Ctx} -> Γ |- a == a' :: aTy -> {Ty : Γ |- ty :: pTyU}
    -> Ext Γ Ty |- po a == po a' :: po aTy
-}

-}

data _|-_ELAB_:->:_ {n} Γ  where
  Var : (v : Fin n) -> {ty : _} -> c.In Γ v ty
    -> Γ |- (pVar v) ELAB (c.pVar v) :->: ty
  TyU : Γ |- pTyU ELAB (c.pTyU) :->: c.pTyU
  Ann : {m M : _} {a A : c.PreSyntax }
    -> Γ |- M ELAB A :<-: c.pTyU
    -> Γ |- m ELAB a :<-: A
    -> Γ |- (pAnn m M) ELAB a :->: A
    
  Pi : {M : _} {N : _} {A : _} {B : _}
    -> Γ |- M ELAB A :<-: c.pTyU
    -> c.Ext Γ A |- N ELAB B :<-: c.pTyU
    -> Γ |- (pPi M N) ELAB (c.pPi A B) :->: c.pTyU
    
  App : {m n : _} {b a : _} {C A : _} {B : _}
    -> Γ |- m ELAB b :->: C
    -> C c~>p* c.pPi A B
    -> Γ |- n ELAB a :<-: A
    -> Γ |- (pApp m n) ELAB (c.pApp b a) :->: (B c[ a ])
    
data _|-_ELAB_:<-:_ {n} Γ  where

  Fun : {m : _} {b : _} {A : _} {B : _} -- {C A : _} {B : _}
    -> c.Ext (c.Ext Γ A)  (c.o (c.pPi A B)) |- m ELAB b :<-: (c.o B)
    -> Γ |- (pFun m) ELAB (c.pFun b) :<-: (c.pPi A B)

  Conv : {m : _} {a : _} {A : _} {B : _}
  -- extra conditions on b...?
    -> Γ |-  m ELAB a :<-: A
    -> Γ |-  m ELAB (c.pCast a A B) :<-: B


data _|-ELAB_ : {n : ℕ} (Γ : Ctx {n}) -> c.Ctx {n} -> Set where
  emp-ELAB : Emp |-ELAB c.Emp
  ext-ELAB : {n : ℕ} {Γ : Ctx {n}} {H : c.Ctx {n}} {M : _} {A : _}
    -> Γ |-ELAB H
    -> H |- M ELAB A :<-: c.pTyU 
    
    -> {!!} |-ELAB {!!}


{-
props:
erasure
well-cast
-}
well-cast-> : {n : ℕ} {Γ : Ctx {n}} {H : _}  {m : _} {a A : _}
  -> (H |- m ELAB a :->: A)
  ->  c._|-_::_ H a A
well-cast-> = {!!}


{-
bidirection elabs

well-cast-> : {n : ℕ} {Γ : Ctx {n}} {m M : PreSyntax {n}}
  -> Γ |- m :->: M 
  -> Σ (c.Ctx {n}) λ H → Σ (c.PreSyntax {n}) λ a → Σ (c.PreSyntax {n}) (λ A → Γ |-ELAB H × (H |- m ELAB a :->: A)) --  × (H |- M ELAB A :<-: c.pTyU)

well-cast<- : {n : ℕ} {Γ : Ctx {n}} {m M : PreSyntax {n}}
  -> Γ |- m :<-: M
--  -> Γ |- M :<-: pTyU
  -> Σ (c.Ctx {n}) λ H → Σ (c.PreSyntax {n}) λ a → Σ (c.PreSyntax {n}) (λ A → Γ |-ELAB H × (H |- m ELAB a :<-: A)) --  × (H |- M ELAB A :<-: c.pTyU)
well-cast<- (Fun argTy bodTy bod) --  MTy
  with well-cast<- bod  --| well-cast<- argTy | well-cast<- bodTy | 
... | fst , fst₁ , fst₂ , fst₃ , bodElab = {!!} , ({!!} , ({!!} , ({!!} , (Fun {!!}))))
well-cast<- (Conv x x₁ mTy) -- MTy
  = {!!}

well-cast-> = {!!}
-}
