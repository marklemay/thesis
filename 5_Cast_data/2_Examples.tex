\section{Examples}
\todo{support the new notation}
 
Consider some of the following examples of how surface language terms might elaborate.
 
\subsection{Head}
 
If the user case matches the head of $x$ where $x$ has type $\mathtt{Vec}\,A\,(\mathtt{S}n)$ in the surface language,
 
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x <_:Vec Bool (S n) => Bool> {
| Cons _ a _ _ => a
}
\end{lstlisting}
 
What can go wrong in the presence of casts?
\begin{itemize}
\item
A faulty cast assumption may have made $x$ appear to be a Vector even when it is not.
For instance, $\mathtt{True}::\mathtt{Vec}\,\mathtt{Bool}\,3$.
\item
The vector may be empty but cast to look like it is inhabited.
For instance, $\mathtt{Nil}\,\mathtt{Bool}\,::\mathtt{Vec}\,\mathtt{Bool}\,5$.
\item
The vector may have a type that is not $\mathtt{Bool}$.
For instance, $\mathtt{Cons}\,\mathtt{Nat}\,3\,...\,...::\mathtt{Vec}\,\mathtt{Bool}\,5$.
\end{itemize}
 
To handle these issues elaboration can use unification to generate the following cast langngae term,
 
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x {
| (Cons A a y _) :: p => a::(TCon_0(p))
| (Nil A) :: p => !TCon_1(p)
}
\end{lstlisting}
 
The elaborated case expression covers all possible constructors for the data type constructor $\mathtt{Vec}$, including patterns that did appear in the surface term.
 
In the first branch $A:\star$, $a:A$, $y:\mathtt{Nat}$, while $p$ is a path variable that contains evidence that the type of $\mathtt{Cons\,A\,a\,y\,-}$ is $\mathtt{Vec\,Bool\,(S\,n)}$.
We might say, $p:\mathtt{Vec}\ A\ (\mathtt{S}\,y)\approx\mathtt{Vec}\,\mathtt{Bool}\,(\mathtt{S}\,n)$.
$TCon_{0}\,p$ extracts the 0th argument from the type constructor $p:\mathtt{Vec}\ \underline{A}\ (\mathtt{S}\,y)\approx\mathtt{Vec}\,\underline{\mathtt{Bool}}\,(\mathtt{S}\,n)$ resulting in the type $TCon_{0}p\ :\ A\approx\mathtt{Bool}$\todo{
  expand on this notation}.
The body of the branch casts $a$ along $TCon_{0}\,p$ to $\mathtt{Bool}$.
Casts will need to be generalized from \ch{3} to support this behavior.
 
In the the second branch, the pattern match gives $A:\star$, $p:\mathtt{Vec}\ A\ \mathtt{Z}\approx\mathtt{Vec}\,\mathtt{Bool}\,(\mathtt{S}\,y)$.
The body of the branch encodes the contradiction observed by noting $\mathtt{Z}\neq\mathtt{S}\,y$.\todo{because...}
 
Since there is no assertion made in either branch, no warnings will be generated for this elaborated case term.
Any failure that arises will be redirected to the scrutinee, which must have made a blameable assumption.
 
Again consider the ways $x$ could go wrong,
\begin{itemize}
\item
If the user tries to eliminate $\mathtt{True}::\mathtt{Vec}\,\mathtt{Bool}\,3$, the type constructor is not matched so the faulty assumption can be blamed automatically.
\item
If the scrutinee is an empty vector, we will fall into the $\mathtt{Nil}$ branch, which will reflect the underlying faulty assumption, via the explicit blame syntax.
\item
If the vector is inhabited by an incorrect type, such as $\mathtt{Cons}\,\mathtt{Nat}\,3\,...\,...::\mathtt{Vec}\,\mathtt{Bool}\,5$, the case will return $3::\mathtt{Bool}$ with a cast that rests on the faulty assumption of $\mathtt{Vec}\,\mathtt{Nat}\,5=\mathtt{Vec}\,\mathtt{Bool}\,\,5$.
When exactly this blame will surface depends on the evaluation and checking strategies.
In the implemented language \cbv{} and check-by-value are used at runtime and the blame will surface immediately.
Using a \whnf{} strategy, the blame will be embedded in the resulting term and discovered whenever that term is eliminated.
\end{itemize}
 
\subsection{Sum}
 
Consider the more involved example that sums the 2 numbers in a vector of length 2,
 
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x <_:Vec Nat 2 => Nat> {
| Cons _ i _ (Cons _ j _ _) => i+j
}
\end{lstlisting}
 
The elaboration procedure will produce
 
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x {
| (Cons Nat' i n' (Cons Nat'' j n'' rest):: p1):: p2 =>
 i::(TCon_0(p2)) + j::(TCon_0(p1) U TCon_0(p2))
| (Nil Nat') :: p =>
 !TCon_1(p)
| (Cons Nat' i n' (Nil Nat''):: p1):: p2 =>
 !(TCon_1(p1) U DCon_0(TCon_1(p2)))
}
\end{lstlisting}
 
\begin{itemize}
\item
In the first branch we have the variables in scope, $p1:\mathtt{Vec}\ Nat''\ (\mathtt{S}\ n'')\approx\mathtt{Vec}\ Nat'\ n'$, $p2:\mathtt{Vec}\ Nat''\ (\mathtt{S}\ n')\approx\mathtt{Vec}\ \mathtt{Nat}\ 2$, $i:Nat'$, $j:Nat''$.
\begin{itemize}
\item
This means we have $TCon_0(p2):Nat'\approx\mathtt{Nat}$, $TCon_0(p1):Nat''\approx Nat'$ and can combine the evidence to show $TCon_0(p1) \cup TCon_0(p2):Nat''\approx\mathtt{Nat}$.
\item
We know from unification what the type and value of every term is supposed to be, so casts can be injected using evidence from the pattern.
\end{itemize}
\item
In the 2nd branch we have, $p:\mathtt{Vec}\ Nat''\ 0\approx\mathtt{Vec}\ Nat'\ 2$.
\begin{itemize}
\item
Which is contradictory, by $TCon_1(p):0\approx2$.
\end{itemize}
\item
\todo{explanation is a little wrong, need to congruence this under a the S constructor}
In the 3rd branch, $p1:\mathtt{Vec}\ Nat''\ 0\approx\mathtt{Vec}\ Nat'\ n'$, $p2:\mathtt{Vec}\ Nat'\ (\mathtt{S}\ n')\approx\mathtt{Vec}\ \mathtt{Nat}\ 2$.
\begin{itemize}
\item
Which is unsatisfiable by $TCon_1(p1) \cup DCon_0(TCon_1(p2)):0\approx1$.
We don't need to know which sub path is problematic beforehand, only that the combination causes trouble.
If this branch is reached, we can observe a problem in either branch or both.
\end{itemize}
\end{itemize}
 
\subsection{Variables Not In Branch}
\todo{this example is a little bad, better with something that needs path evidence like ID}
There are more complicated possibilities that need to be addressed.
For instance, variables may not be used in the body of a branch.
Consider this partial pattern match where $\mathtt{rept: (x: Nat) -> Vec Bool x}$,
 
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x <x: Nat => Vec Bool x> {
| 2 => rept 2
}
\end{lstlisting}
 
will elaborate to
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x  {
| (S (S (Z :: _) :: _) :: _) => rept 2
? (Z :: _)
? (S (Z :: _) :: _)
? (S (S (S _ :: _) :: _))
}
\end{lstlisting}
 
Substitution can confirm that the explicit branch has exactly the type of the motive and does not need a cast\footnote{
  While it is possible that blame was embedded in the term, our definitional equality allows it to be ignored}.
Additionally the elaborator will form a covering of implicit patterns that handle any possible constructor.
Since the unifier cannot find a contradiction for any of these cases, the user will be warned of possible runtime errors.
 
\subsection{Assignment at the type level}
 
Another more complicated possibility is this surface expression that takes in a propositional proof that $2=2$ and uses the named witness to generate a vector of length 2.
This will typecheck in the surface language.
 
\todo[inline]{Note that an arbitrary choice was was made $InTC_{1}(p)$ $InTC_{2}(p)$}
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x <_:Id Nat 2 2 => Vec Bool 2> {
| refl _ a => rep a Bool True
}
\end{lstlisting}
 
This will elaborate to
 
\begin{lstlisting}[basicstyle={\ttfamily\small}]
case x {
| (refl Nat' a)::p =>
 (rep (a :: (TCon_0(p)))) 
   :: ((A : *) -> A -> Vec Nat (TCon_0(p) U TCon_1(p)))
}
\end{lstlisting}
 
Where $Nat':\star$, $a:Nat'$, and $p:\mathtt{Id}\ Nat'\ a\ a\approx\mathtt{Id}\ \mathtt{Nat}\ 2\ 2$.
Since we have $p:\mathtt{Id}\ Nat'\ a\ a\approx\mathtt{Id}\ \mathtt{Nat}\ 2\ 2$, we can derive $TCon_0(p):\ Nat'\ \approx\ \mathtt{Nat}$.
Which can be used in $a::(TCon_0(p))$ to cast $a$ from $Nat'$ to $\mathtt{Nat}$.
But then we need evidence that $(A:\star)\rightarrow A\rightarrow\mathtt{Vec}\,\mathtt{Nat}\,(a :: (TCon_0(p)))\approx(A:\star)\rightarrow A\rightarrow\mathtt{Vec}\,\mathtt{Nat}\,2$ to avoid a sperous assertion\todo{
  give an example of an assertion to remind people it is possible
}.
\todo[inline]{avoiding these sperous casts is important for the conjectured gradual correctness, well typed surface language terms should not generate warnings}
First we need to embed our into the subterm of interest, $(A:\star)\rightarrow A\rightarrow\mathtt{Vec}\,\mathtt{Nat}\,\underline{(a :: (TCon_0(p)))}\approx(A:\star)\rightarrow A\rightarrow\mathtt{Vec}\,\mathtt{Nat}\,\underline{2}$.
We will construct our equality evidence specifically so that it can be embedded into terms.
% The $Cong$ syntax explicitly embeds a path into a larger expression, here $Cong_{x=> (A : *) -> A -> \mathtt{Vec} \mathtt{Nat} x} ...$ selects the relevant part of the type.
 
We will only insist that terms are equated up to a definitional equality that disregards casts so instead of needing to show $a :: (TCon_0(p))\ \approx\ 2$, we only have to show $a\ \approx\ 2$.
Which we have in $TCon_1(p)\ :\ a\ \approx\ 2$.
 
\todo[inline]{Example: translate out to motive}

\subsection{Transitivity}

\begin{figure}
  \begin{lstlisting}[basicstyle=\ttfamily\small]
  -- surface language term
  trans : (A : *) -> (x : A) -> (y : A) -> (z : A)
        -> (xy : Id A x y) -> (yz : Id A y z) -> Id A x z
  trans A x y z xy yz =
  case xy, yz < _ => _ => Id A x z > {
    | (refl A' a') => (refl A'' a'') => (refl A' a')
  } ;
  
  -- elaborated cast language term
  trans : (A : *) -> (x : A) -> (y : A) -> (z : A)
        -> (xy : Id A x y) -> (yz : Id A y z) -> Id A x z
  case xy, yz {
    | (refl A' a')::v => (refl A'' a'')::w => 
      (refl A' a'):: (Id Aeq aeq aeq)
  } ;
\end{lstlisting}

\caption{Transitivity Example}
\label{fig:cast-trans}
\end{figure}

\todo[inline]{may need to expand scruts if we are using flex vars}

For another example consider the surface language function that validates the transitivity of the \Id{} type, and its cast language elaboration in \Fref{cast-trans}.
% For the surface language term the constraints ($\text{Id A' a' a'}=\text{Id A x y}$,$\text{Id A'' a'' a''}\approx\text{Id A y z}$) will be solved and the branch type checks under the substitutions implied by those equalities ($A=A'=A''$, $a'=x=y=a''=z$).
In the elaborated cast term the variables are not directly equated, instead assertion variables are added to scope to build evidence for these equalities ($v:\text{Id A' a' a'}\approx\text{Id A x y}$, $w:\text{Id A' a' a'}\approx\text{Id A x y}$).
Elaboration based unification will generate terms that correspond to the equalities discovered by normal unification 
  ($Aeq=\left(TCon_{0}\ v\right)\cup^{\star}\left(TCon_{0}\ w\right)\sqsupseteq A,A',A''$;
  and $aeq=\left(TCon_{1}\ v\right)\cup^{\star}\left(TCon_{2}\ v\right)\cup^{\star}\left(TCon_{1}\ w\right)\cup^{\star}\left(TCon_{2}\ w\right)\sqsupseteq a',x,y,a'',z$).
These assertions are embedded into the constructor allowing $\text{Id A' a' a'}=\text{Id A x z}$.
Again, the $\mathtt{trans}$ function itself is blameless, any blame surfaces from the use of the term must come from a blamable input.


\subsection{Peeking}
\todo{move to the end?}

% Finally case expressions will be blamed if an incompatible constructor appears.
% For instance, if head is called with $\True{} ::(\Bool{} \ \sim_{\ell}^{\star} \Vect{} \ \Nat{}\ 1)$ then $\ell$ will be blamed immediately, since $\True{} $ does not match the correct type of the constructor $Cons$.
% Since the type constructor is known, it is possible to check the coverage of the patterns.
% If every constructor is accounted for, only blameable data remains.
% Quantifying over casts allows blame to be redirected, so if the program gets stuck in a pattern branch it can blame the malformed input.
% This extension seems to preserve cast soundness.

\begin{figure}
\begin{lstlisting}[basicstyle=\ttfamily\small]
peek : Id Nat 0 1 -> Nat
peek x =
case x <_: Id Nat 0 1 => Nat> {
  | (refl _ x :: w) => x :: (TCon0 w)
}

-- under weak head evaluation
peek (refl 4 :: Id Nat 0 1) = 4
\end{lstlisting}
\caption{Cast Pattern Matching}
\label{fig:cast-peek}
\end{figure}

The cast language will enforce a minimal amount of checking, that could potentially lead to unexpected behavior.
For instance, the peek function defined in \Fref{cast-peek}, will ignore several discrepancies in the index of the \Id{} type, if run in \whnf{}.
As  in \ch{3}, our formalism uses a minimal amount of checking to maintain cast soundness, though more eager checking is implemented in the prototype.