#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xcolor}
\usepackage{tikz-cd}
\tikzcdset{%
    triple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure' 
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    quadruple line/.code={\tikzset{%
        double equal sign distance, % replace by double distance = 'measure'
        double=\pgfkeysvalueof{/tikz/commutative diagrams/background color}}},
    Rrightarrow/.code={\tikzcdset{triple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}},
    RRightarrow/.code={\tikzcdset{quadruple line}\pgfsetarrows{tikzcd implies cap-tikzcd implies}}
}    
\newcommand*{\tarrow}[2][]{\arrow[Rrightarrow, #1]{#2}\arrow[dash, shorten >= 0.5pt, #1]{#2}}
\newcommand*{\qarrow}[2][]{\arrow[RRightarrow, #1]{#2}\arrow[equal, double distance = 0.25pt, shorten >= 1.28pt, #1]{#2}}
\end_preamble
\use_default_options true
\begin_modules
todonotes
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Chapter 5 (draft): Data and Pattern Matching in the Cast Language
\end_layout

\begin_layout Author
Mark Lemay
\end_layout

\begin_layout Standard
The following revises the previous attempt.
 To differentiate it from the prior 
\begin_inset Quotes eld
\end_inset

path
\begin_inset Quotes erd
\end_inset

 style formalization, the new multi-endpoint constructs are called 
\begin_inset Quotes eld
\end_inset

lumps
\begin_inset Quotes erd
\end_inset

.
 This name is expected to change.
 Further cleanup is expected, but otherwise the mistakes should all be small.
\end_layout

\begin_layout Section
outline
\end_layout

\begin_layout Itemize
fudge definitional equality
\end_layout

\begin_layout Itemize
connected finite sets instead of paths
\end_layout

\begin_layout Standard
questions,
\end_layout

\begin_layout Itemize
add 
\begin_inset Formula $\cup$
\end_inset

 to syntax?
\end_layout

\begin_layout Itemize
unify cast and lump?
\end_layout

\begin_layout Itemize
seems like the formalization could be reduced
\end_layout

\begin_layout Itemize
Some Lumps could be replaced with expressions
\end_layout

\begin_layout Section
Formalism
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
inline document
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="40" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path var,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pattern,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $patc$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(d\overline{patc}::x_{p}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast expressions,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a,b$
\end_inset

,
\begin_inset Formula $A,B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $L$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::L$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left(x:A\right)\rightarrow B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fun}\,f\,x\Rightarrow b$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b\,a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'_{\ell}}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{L}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
force blame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App_{a}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inEx_{\overline{patc}}[\overline{a}]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
in-exhaustive pattern match
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lumps
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $L,l$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \star\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ \overline{a},\overline{b\sim c},\overline{x_{p}}\right\} _{L}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Arg\ L$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Bod_{a}\ L$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $TCon_{i}\ L$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $DCon_{i}\ L$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
contexts,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\varGamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x:A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}:A\approx B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma,\mathsf{data}\,D\,:\,\Delta\rightarrow\star\,\left\{ \overline{|\,d\,:\,\varTheta\rightarrow D\overline{a}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data definition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Gamma,\mathsf{data}\,D\,:\,\Delta\rightarrow\star$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
abstract data
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Judgment Forms
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\varGamma\vdash a:A
\]

\end_inset


\begin_inset Formula 
\[
\varGamma\vdash a\sqsupseteq a':A'
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\varGamma\vdash L\ \mathbf{ok}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\varGamma\vdash L\ \mathbf{connected}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\varGamma\vdash a\equiv a':A
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
I suspect that 
\begin_inset Formula $\varGamma\vdash a:A$
\end_inset

 and 
\begin_inset Formula $\varGamma\vdash a\sqsupseteq a':A'$
\end_inset

 could be merged into a single judgment, with 
\begin_inset Formula $\varGamma\vdash a:A$
\end_inset

 being shorthand for 
\begin_inset Formula $\varGamma\vdash a\sqsupseteq a:A$
\end_inset

 or 
\begin_inset Formula $\varGamma\vdash a\sqsupseteq b:A$
\end_inset

 .
 But will keep them separate for now.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Definitional equality
\end_layout

\begin_layout Standard
Assume a congruent equivalence that 
\end_layout

\begin_layout Itemize
respects evaluation.
 
\begin_inset Formula $\varGamma\vdash a\rightsquigarrow a':A$
\end_inset

 implies 
\begin_inset Formula $\varGamma\vdash a\equiv a':A$
\end_inset

 
\end_layout

\begin_layout Itemize
associates trivial casts with uncast terms.
 
\begin_inset Formula $\varGamma\vdash a:A$
\end_inset

 implies 
\begin_inset Formula $\varGamma\vdash a\equiv a::\left\{ A_{\left\{ \star\right\} }\right\} \ :A$
\end_inset

 
\end_layout

\begin_layout Itemize
associates casts at the same endpoints.
 
\begin_inset Formula $\varGamma\vdash a\equiv a':A$
\end_inset

 , 
\begin_inset Formula $\varGamma\vdash a::L\ :B$
\end_inset

, 
\begin_inset Formula $\varGamma\vdash a::L'\ :B$
\end_inset

 implies 
\begin_inset Formula $\varGamma\vdash a::L\ \equiv\ a'::L'\ :\ B$
\end_inset

 
\end_layout

\begin_layout Section
Lump substitution
\end_layout

\begin_layout Standard
structurally recursive, except at variables
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ ...,x_{p},...\right\} _{L'}\left[x_{p}\coloneqq L\right]=L\cup\left\{ ...\left[x_{p}\coloneqq L\right],...\right\} _{\left(\mathbf{ty}\,L\right)\cup L'}$
\end_inset


\end_layout

\begin_layout Standard
also injects the type lumps
\end_layout

\begin_layout Section
Lumping Rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\varGamma\vdash\left\{ \star\right\} \ \mathbf{ok}}
\]

\end_inset


\end_layout

\begin_layout Standard
better symbol
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash L\ \mathbf{connected}\\
\mathbf{ty}\ L=L'\\
\varGamma\vdash L'\ \mathbf{ok}\\
\forall a\sim b\in L,\quad\varGamma\vdash a:A\quad\varGamma\vdash b:B\quad\varGamma\vdash L'\sqsupseteq A\quad\varGamma\vdash L'\sqsupseteq B\\
\forall a\in L,\quad\varGamma\vdash a\sqsupseteq a':A\quad\varGamma\vdash L'\sqsupseteq A\\
\forall x_{p}\in L,\quad x_{p}:a\approx b\in\varGamma\quad\varGamma\vdash a:A\quad\varGamma\vdash L'\sqsupseteq A\quad\varGamma\vdash b:B\quad\varGamma\vdash L'\sqsupseteq B
\end{array}}{\varGamma\vdash L_{L'}\ \mathbf{ok}}
\]

\end_inset


\end_layout

\begin_layout Standard
every endpoint it connected and every type is connected.
 
\end_layout

\begin_layout Section
Connected
\end_layout

\begin_layout Standard
singletons are connected
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\varGamma\vdash\left\{ a_{\left\{ ...\right\} }\right\} \ \mathbf{connected}}
\]

\end_inset


\end_layout

\begin_layout Standard
further connections can be built up by connecting endpoints
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a\ \mathbf{connected}\\
\varGamma\vdash a\sqsupseteq a':A\\
\varGamma\vdash L\sqsupseteq a':A\\
\varGamma\vdash L\ \mathbf{connected}
\end{array}}{\varGamma\vdash\left\{ a\right\} \cup L\ \mathbf{connected}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash L\sqsupseteq a:A\\
\varGamma\vdash L\ \mathbf{connected}
\end{array}}{\varGamma\vdash\left\{ a\sim b\right\} \cup L\ \mathbf{connected}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash L\sqsupseteq b:B\\
\varGamma\vdash L\ \mathbf{connected}
\end{array}}{\varGamma\vdash\left\{ a\sim b\right\} \cup L\ \mathbf{connected}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
x_{p}:a\approx b\in\varGamma\\
\varGamma\vdash L\sqsupseteq a:A\\
\varGamma\vdash L\ \mathbf{connected}
\end{array}}{\varGamma\vdash x_{p}\cup L\ \mathbf{connected}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
x_{p}:a\approx b\in\varGamma\\
\varGamma\vdash L\sqsupseteq b:B\\
\varGamma\vdash L\ \mathbf{connected}
\end{array}}{\varGamma\vdash x_{p}\cup L\ \mathbf{connected}}
\]

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 1\sim2,S\left\{ 0\sim5\right\} _{\left\{ \mathbb{N}\right\} },6\sim7\right\} _{\left\{ \mathbb{N}\right\} }\ \mathbf{ok}$
\end_inset


\end_layout

\begin_layout Example
since 
\begin_inset Formula $S\left\{ 0\sim5_{\left\{ \mathbb{N}\right\} }\right\} \sqsupseteq1$
\end_inset

,
\begin_inset Formula $6$
\end_inset


\end_layout

\begin_layout Example
every endpoint is connected up to 
\series bold
normalization
\series default
 and 
\series bold
casts
\end_layout

\begin_layout Example
every type of every endpoint is connected
\end_layout

\begin_layout Standard
Will need to be a little flexible with connections
\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ True\sim1::\left\{ \mathbb{N}\sim\mathbb{B}\right\} ,1::\left\{ \mathbb{N}\sim\mathbb{B}\right\} \sim False_{\left\{ \mathbb{B}\right\} }\right\} \ \mathbf{ok}$
\end_inset


\end_layout

\begin_layout Section
Typing Rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{x:A\ \in\varGamma}{\varGamma\vdash x:A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a:A\\
\varGamma\vdash L\ \mathbf{ok}\\
\varGamma\vdash L\sqsupseteq A:\star\\
\varGamma\vdash L\sqsupseteq B:\star
\end{array}}{\varGamma\vdash a::L\ :B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\varGamma\vdash\star:\star}
\]

\end_inset


\end_layout

\begin_layout Subsection
functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash A:\star\quad\varGamma,x:A\vdash B:\star}{\varGamma\vdash\prod x:A.B\ :\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash b\,:\,\prod x:A\rightarrow B\quad\Gamma\vdash a\,:\,A}{\Gamma\vdash b\,a\,:\,B\left[x\coloneqq a\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma,f:\prod x:A\rightarrow B,x:A\vdash b\,:\,B}{\Gamma\vdash\mathsf{fun}\,f\,x\Rightarrow b\,:\,\left(x:A\right)\rightarrow B}
\]

\end_inset


\end_layout

\begin_layout Subsection
data
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\,:\,\Delta\rightarrow\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{d\,:\,\varTheta\rightarrow D\overline{a}\in\Gamma}{\Gamma\vdash d\,:\,\varTheta\rightarrow D\overline{a}}
\]

\end_inset


\end_layout

\begin_layout Subsection
conversion
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\vdash a\,:\,A\quad\Gamma\vdash A\equiv A':\,\star}{\Gamma\vdash a\,:\,A'}\,\textrm{ty-conv}
\]

\end_inset


\end_layout

\begin_layout Section
Endpoint Rules
\end_layout

\begin_layout Subsection
incorrect lump endpoints
\end_layout

\begin_layout Standard
we want to select the endpoints of a lump
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a\in L\\
\varGamma\vdash a:A
\end{array}}{\varGamma\vdash L\sqsupseteq a:A}
\]

\end_inset


\end_layout

\begin_layout Standard
but each term my contain sub terms
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a\in L\\
\varGamma\vdash a\sqsupseteq a':A
\end{array}}{\varGamma\vdash L\sqsupseteq a':A}
\]

\end_inset


\end_layout

\begin_layout Standard
and we need that each one is fudged with it's own cast
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a\in L\\
L=\left\{ ..._{L'}\right\} \\
\varGamma\vdash a\sqsupseteq a':A\\
\varGamma\vdash L'\sqsupseteq B:\star
\end{array}}{\varGamma\vdash L\sqsupseteq a'::L'\ :\ B}
\]

\end_inset


\end_layout

\begin_layout Subsection
lump endpoints
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a\in L\\
L=\left\{ ...\right\} _{L'}\\
\varGamma\vdash a\sqsupseteq a':A\\
\varGamma\vdash L'\sqsupseteq B:\star
\end{array}}{\varGamma\vdash L\sqsupseteq a'::L'\ :\ B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a\sim b\in L\\
\varGamma\vdash a:A
\end{array}}{\varGamma\vdash L\sqsupseteq a:A}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash a\sim b\in L\\
\varGamma\vdash b:B
\end{array}}{\varGamma\vdash L\sqsupseteq b:B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash x_{p}\in L\\
\varGamma\vdash x_{p}:a\approx b\\
\varGamma\vdash a:A
\end{array}}{\varGamma\vdash L\sqsupseteq a:A}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash x_{p}\in L\\
\varGamma\vdash x_{p}:a\approx b\\
\varGamma\vdash b:B
\end{array}}{\varGamma\vdash L\sqsupseteq b:B}
\]

\end_inset


\end_layout

\begin_layout Subsection
operators on lumps 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash l\sqsupseteq\prod x:A.B:\star}{\varGamma\vdash Arg\,l\sqsupseteq A}
\]

\end_inset


\end_layout

\begin_layout Standard
since a lump may associate any number of terms, the arg operator will only
 operate over endpoints that are dependent function types
\end_layout

\begin_layout Example
\begin_inset Formula $Arg\left\{ \prod x:\mathbb{N}.Vec\,x\sim\mathbb{B}\rightarrow\mathbb{B},7\sim\mathbb{B}\rightarrow\mathbb{B}_{\left\{ \star\sim\mathbb{N}\right\} }\right\} \sqsupseteq\mathbb{B}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Arg\left\{ \prod x:\mathbb{N}.Vec\,x\sim\mathbb{B}\rightarrow\mathbb{B},7\sim\mathbb{B}\rightarrow\mathbb{B}_{\left\{ \star\sim\mathbb{N}\right\} }\right\} \sqsupseteq\mathbb{\mathbb{N}}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Arg\left\{ \prod x:\mathbb{N}.Vec\,x\sim\mathbb{B}\rightarrow\mathbb{B},7\sim\mathbb{B}\rightarrow\mathbb{B}_{\left\{ \star\sim\mathbb{N}\right\} }\right\} \cancel{\sqsupseteq}Arg7$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash l\sqsupseteq\prod x:A.B:\star\\
\varGamma\vdash a\sqsupseteq a':A
\end{array}}{\varGamma\vdash Bod\left[a\right]\,l\sqsupseteq B\left[a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
will accept every endpoint 
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
double check this
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
App!!!!!!!!!!!!!!!
\end_layout

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $L=\left\{ \prod x:\mathbb{N}.Vec\,x\sim\mathbb{B}\rightarrow\mathbb{B},7\sim\mathbb{B}\rightarrow\mathbb{B}_{\left\{ \star\sim\mathbb{N}\right\} }\right\} $
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Bod\left[1\right]L\sqsupseteq Vec\,1$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Bod\left[\left\{ 1\sim2\right\} \right]L\sqsupseteq Vec\,1,Vec\,2$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Bod\left[\left\{ 1\sim True_{\mathbb{B}\sim\mathbb{N}}\right\} \right]L\sqsupseteq Vec\,1,\mathbb{B}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Bod\left[1::Arg\,L\right]L\sqsupseteq Vec\,1,Vec\,\left(1::Arg\,L\right),\mathbb{B}$
\end_inset

 since definitional equality associates casts with the same endpoints and
 endpoints are only associated up to definitional equality
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash l\sqsupseteq D\overline{a}\end{array}}{\varGamma\vdash TCon_{i}\,l\sqsupseteq a_{i}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash l\sqsupseteq d\overline{a}\end{array}}{\varGamma\vdash DCon_{i}\,l\sqsupseteq a_{i}}
\]

\end_inset


\end_layout

\begin_layout Subsection
other endpoints
\end_layout

\begin_layout Standard
we would like the endpoint relation to otherwise be reflexive
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{x:A\in\varGamma}{\varGamma\vdash x\sqsupseteq x:A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\varGamma\vdash\star\sqsupseteq\star:\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
however this means 
\begin_inset Formula $\left\{ 1\sim2\right\} \sqsupseteq\left\{ 1\sim2\right\} :\mathbb{N}$
\end_inset

.
 which can lead to types with unclear meanings, like 
\begin_inset Formula $Vec\ \left\{ 1\sim2\right\} $
\end_inset

.
 If this wierdness is not needed, remove it
\end_layout

\end_inset


\end_layout

\begin_layout Standard
along with 2 rules of conversion
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash a\sqsupseteq a':A\quad\varGamma\vdash a'\equiv a'':A}{\varGamma\vdash a\sqsupseteq a'':A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash a\sqsupseteq a':A\quad\varGamma\vdash A\equiv A':\star}{\varGamma\vdash a\sqsupseteq a':A'}
\]

\end_inset


\end_layout

\begin_layout Standard
other rules mimic their typing judgments
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash a\sqsupseteq a':A'\quad\varGamma\vdash L\sqsupseteq A'\quad\varGamma\vdash L\sqsupseteq B}{\varGamma\vdash a::L\sqsupseteq a'::L\ :\ B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash A\sqsupseteq A':\star\quad\varGamma,x:A'\vdash B\sqsupseteq B':\star}{\varGamma\vdash\prod x:A.B\ \sqsupseteq\ \prod x:A'.B'\ :\ \star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma,f:\left(x:A\right)\rightarrow B,x:A\vdash b\sqsupseteq b':B'}{\varGamma\vdash\mathsf{fun}\,f\,x\Rightarrow b'\,:\,\left(x:A\right)\rightarrow B'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash b\ \sqsupseteq\ b':\left(x:A'\right)\rightarrow B'\quad\varGamma\vdash a\sqsupseteq\ a':A'}{\varGamma\vdash b\,a\ \sqsupseteq\ b'\,a'\ :\ B'\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \sqsupseteq\ 7:\mathbb{N}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \sqsupseteq\ True:\mathbb{B}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \sqsupseteq\ True::\left\{ \mathbb{N}\sim\mathbb{B}\right\} :\mathbb{N}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \sqsupseteq\ 7::\left\{ \mathbb{N}\sim\mathbb{B}\right\} :\mathbb{B}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \sqsupseteq\ 7::\left\{ \mathbb{N}\sim Tuesday,Tuesday\sim\mathbb{B}\right\} :\mathbb{B}$
\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ rep\sim not_{\left\{ \left(x:\mathbb{N}\right)\rightarrow Vec\,x\sim\mathbb{B\rightarrow B}\right\} }\right\} \left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \sqsupseteq\ rep\,7:Vec\,7$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ rep\sim not_{\left\{ \left(x:\mathbb{N}\right)\rightarrow Vec\,x\sim\mathbb{B\rightarrow B}\right\} }\right\} \left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \sqsupseteq\ not\,True:\mathbb{B}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ rep\sim not_{\left\{ \left(x:\mathbb{N}\right)\rightarrow Vec\,x\sim\mathbb{B\rightarrow B}\right\} }\right\} \left\{ 7\sim True_{\left\{ \mathbb{N}\sim\mathbb{B}\right\} }\right\} \cancel{\sqsupseteq}\ not\,7:\mathbb{B}$
\end_inset


\end_layout

\begin_layout Standard
The typing restriction protects type boundaries.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash d\sqsupseteq a':A\quad\varGamma\vdash a'\equiv a'':A}{\varGamma\vdash a\sqsupseteq a'':A}
\]

\end_inset


\end_layout

\begin_layout Subsection
data 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{D:...\in\varGamma}{\varGamma\vdash D\sqsupseteq D:\Delta\rightarrow\star}
\]

\end_inset


\begin_inset Formula 
\[
\frac{d:...\in\varGamma}{\varGamma\vdash d\sqsupseteq d:\Delta\rightarrow d...}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'_{\ell}}}\right\} $
\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash L\sqsupseteq a:A\\
\varGamma\vdash L\sqsupseteq b:B\\
hd\,a\neq hd\,b\\
\varGamma\vdash C:\star
\end{array}}{\varGamma\vdash!_{L}\sqsupseteq!_{L}:C}
\]

\end_inset


\end_layout

\begin_layout Section
CBV
\end_layout

\begin_layout Standard
evaluation will preserve the types of well typed terms, the endpoints, and
 the OKness of lumps
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\star\sim\star\ \rightsquigarrow\ \star}
\]

\end_inset


\end_layout

\begin_layout Standard
Revise this so the syntax is more 
\begin_inset Quotes eld
\end_inset

formal
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Casts can be bumped out of the way....
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left\{ ...,a::L,..._{L'}\right\} \ \rightsquigarrow\ \left\{ ...,a,..._{L'\cup L}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left\{ ...,a::L\sim b,..._{L'}\right\} \ \rightsquigarrow\ \left\{ ...,a\sim b,..._{L'\cup L}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left\{ ...,a\sim b::L,..._{L'}\right\} \ \rightsquigarrow\ \left\{ ...,a\sim b,..._{L'\cup L}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left\{ ...,L,..._{L'}\right\} \ \rightsquigarrow\ L\cup\left\{ ..._{L}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
casts accumulate
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(a::L\right)::L'\ \rightsquigarrow\ a::\left(L\cup L'\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
lump operations evaluate as expected
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{Arg\left\{ \prod x:A.B\sim_{\ell,o}\prod x:A'.B',...,\prod x:A''.B'',...,x_{p},..\right\} _{L}\ \rightsquigarrow\ \left\{ A\sim_{\ell,o.Arg}A',...,A'',...,Arg\,\left\{ x_{p}\right\} _{L},...\right\} _{\left\{ \star\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Injecting the lump variable into a {} seems a little hacky.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
types only need to be connected up to lump vars, since they will complete
 the type puzzle when they are substituted
\end_layout

\end_inset


\begin_inset Formula 
\[
\frac{L=\left\{ \prod x:A.B\sim_{\ell,o}\prod x:A'.B',...,\prod x:A''.B'',...,x_{p},...\right\} _{L'}}{Bod\left[a\right]L\ \rightsquigarrow\ \left\{ B\left[a::Arg\,L\right]\sim_{\ell,o.Bod\left[a\right]}B'\left[a::Arg\,L\right],...,B''\left[a::Arg\,L\right],...,Bod\left[a::Arg\,L\right]\,\left\{ x_{p}\right\} _{L'},...\right\} _{\left\{ \star\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{L=\left\{ D_{\Delta}\overline{a}\sim_{\ell,o}D_{\Delta}\overline{a'},...,D_{\Delta}\overline{a''},...,x_{p},..._{L'}\right\} }{TCon_{i}\ L\rightsquigarrow\ \left\{ a_{i}\sim_{\ell,o.TCon_{i}}a'_{i},...,a''_{i},...,TCon_{i}\,\left\{ x_{p}\ _{L'}\right\} ,..._{\left\{ \Delta\overline{TCon_{j}\ L},j<i\right\} }\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
will need to recalculate the type of the index, based on the telescope and
 prior indixcies
\end_layout

\end_inset


\end_layout

\begin_layout Standard
data constructors commute out
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left\{ D_{\Delta}\overline{a}\sim_{\ell,o}D_{\Delta}\overline{a'},...,D_{\Delta}\overline{a''},..._{L}\right\} \ \rightsquigarrow\ D_{\Delta}\overline{\left\{ a_{i}\sim_{\ell,o}a'_{i},...,a''_{i},...,x_{p},..._{!!!'}\right\} }::L}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left\{ d_{\Delta}\overline{a}\sim_{\ell,o}d_{\Delta}\overline{a'},...,d_{\Delta}\overline{a''},..._{L}\right\} \ \rightsquigarrow\ d_{\Delta}\overline{\left\{ a_{i}\sim_{\ell,o}a'_{i},...,a''_{i},...,x_{p},..._{!!!'}\right\} }::L}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
this rule is not exactly correct, since the underling term doesn't exactly
 type currently
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
eliminations happen around casts
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(\left(\mathsf{fun}\,f\,x\Rightarrow b\right)::L\right)a\ \rightsquigarrow\ b\left[\mathsf{fun}\,f\,x\Rightarrow b,a::Arg\,L\right]::Bod\left[a\right]\,L}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\begin{array}{c}
\left\{ \left(\mathsf{fun}\,f\,x\Rightarrow b\right)\sim_{\ell,o}\left(\mathsf{fun}\,f\,x\Rightarrow b'\right),...,\left(\mathsf{fun}\,f\,x\Rightarrow b'\right),..._{\left\{ L\right\} }\right\} a\\
\rightsquigarrow\\
\left\{ \left(\mathsf{fun}\,f\,x\Rightarrow b\right)\left(a::Arg\,L\right)\sim_{\ell,o.app\left[a::Arg\,L\right]}\left(\mathsf{fun}\,f\,x\Rightarrow b'\right)\left(a::Arg\,L\right),...,\left(\mathsf{fun}\,f\,x\Rightarrow b''\right)\left(a::Arg\,L\right),..._{\left\{ Bod\left[a\right]L\right\} }\right\} 
\end{array}}
\]

\end_inset


\end_layout

\begin_layout Standard
no path variable are allowed, every element must be a function
\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ \left(\lambda x.x\right)\sim_{\ell,o}\left(\lambda x.x+3\right),\left(\lambda x.x+\left\{ 3\sim x\right\} \right)\right\} 2$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\rightsquigarrow\left\{ \left(\lambda x.x\right)2\sim_{\ell,o.app\left[2\right]}\left(\lambda x.x+3\right)2,\left(\lambda x.x+\left\{ 3\sim x\right\} \right)2\right\} $
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\rightsquigarrow\left\{ 2\sim_{\ell,o}5,2+\left\{ 3\sim5\right\} \right\} $
\end_inset


\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ \left(\lambda x.\left\{ 3\sim x\right\} \right)\right\} 2$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\rightsquigarrow\left\{ \left\{ 3\sim2\right\} \right\} \rightsquigarrow\left\{ 3\sim2\right\} $
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $True::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }:\mathbb{B}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $True::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }:\mathbb{N}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $True::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }\sqsupseteq True:\mathbb{B}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $True::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }\sqsupseteq True::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }:\mathbb{N}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $True::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }\sqsupseteq True::\left\{ \mathbb{N}\sim ofjosdfij,ofjosdfij\sim\mathbb{B}\right\} _{\left\{ ...\right\} }:\mathbb{N}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 1\sim3\right\} _{\left\{ \star\right\} }::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }\sqsupseteq1:\mathbb{N}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $\left\{ 1\sim3\right\} _{\left\{ \star\right\} }::\left\{ \mathbb{N}\sim\mathbb{B}\right\} _{\left\{ \star\right\} }\sqsupseteq1:\mathbb{N}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(\left(\mathsf{fun}\,f\,x\Rightarrow b\right)::L\right)a\ \rightsquigarrow\ b\left[f\Coloneqq\mathsf{fun}\,f\,x\Rightarrow b,x\Coloneqq a::Arg\,L\right]::Bod\left[x\Coloneqq a\right]\,L}
\]

\end_inset


\end_layout

\begin_layout Subsection
standard rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(\mathsf{fun}\,f\,x\Rightarrow b\right)a\ \rightsquigarrow\ b\left[\mathsf{fun}\,f\,x\Rightarrow b,a\right]}
\]

\end_inset


\end_layout

\begin_layout Section
Values
\end_layout

\begin_layout Standard
first atomic values, values that are not lumps.
 They prevent 
\begin_inset Formula $\left\{ \left\{ \left\{ \star\right\} \right\} \right\} \ Val$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\star\ AVal}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{\prod x:A.B\ AVal}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(\mathsf{fun}\,f\,x\Rightarrow b\right)\ AVal}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{a}\ Val}{D\overline{a}\ AVal}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
there is some flexibility weather indices should be treated in a CBV way
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{a}\ Val}{d\overline{a}\ AVal}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
there is some flexibility weather indices should be treated in a CBV way
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\ AVal}{a\ Val}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{L\ Val}{\left(\mathsf{fun}\,f\,x\Rightarrow b\right)::L\ Val}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\forall a\in L,\ a\,AVal\\
\forall b\sim b'\in L,\ b\,AVal\ b'\,AVal
\end{array}}{L\ Val}
\]

\end_inset


\end_layout

\begin_layout Section
Blame
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\sim_{\ell,o}b\in L\quad\mathbf{head}\,a\neq\mathbf{head}\,b}{Blame\ \ell,o\ L}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\sim_{\ell,o}b\in L\quad Blame\ \ell,o\,a}{Blame\ \ell,o\ L}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{a\sim_{\ell,o}b\in L\quad Blame\ \ell,o\,b}{Blame\ \ell,o\ L}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
L=\left\{ ..._{L'}\right\} \\
Blame\ \ell,o\ L'
\end{array}}{Blame\ \ell,o\ L}
\]

\end_inset


\begin_inset Formula 
\[
\frac{Blame\ \ell,o\ L}{Blame\ \ell,o\ a::L}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Blame\ \ell,o\ a_{i}}{Blame\ \ell,o\ D\overline{a}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Blame\ \ell,o\ a_{i}}{Blame\ \ell,o\ d\overline{a}}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Section
Properties
\end_layout

\begin_layout Standard
Lump substituiton accross types must be handled carefully
\end_layout

\begin_layout Section
Progress
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Section
Preservation
\end_layout

\begin_layout Part
Old stuff - Ignore
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="35" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path var,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion index,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kin$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k=left$
\end_inset

 | 
\begin_inset Formula $k=right$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion maps,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kmap$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kin,}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
casts under assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kmap,p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path exp.,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p,p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Cong_{k\Rightarrow a}^{\overline{q}:\varGamma\approx\varGamma',p:A\approx B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
congruence
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{o,\ell,a:A,b:B}^{\overline{q}:\varGamma\approx\varGamma',p:A\approx B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concrete assumption
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concatenated paths
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reverse a path
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extract the 
\begin_inset Formula $i$
\end_inset

type argument from a data type constructor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extract the 
\begin_inset Formula $i$
\end_inset

type argument from a data constructor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast pattern,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $patc$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $\left(d\,\overline{patc}\right)::x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast expression,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\prod x:p_{B}^{A}.C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'_{\ell}}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{kcast}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
force blame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ a\sim_{k,p}b\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assert same
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inEx_{\overline{patc}}[\overline{a}]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
in-exhaustive pattern match
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Judgment forms
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="8">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\varGamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdash$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $:$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a:A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\approx_{\overline{q}:\varGamma'}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b:B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pathing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\varGamma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdash$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $:$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a:A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\approx_{\varGamma'}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b:B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pathing?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\varGamma^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdash_{k}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $:$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a:A$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\approx$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b:B$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pathing
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
operations
\end_layout

\begin_layout Section
subst
\end_layout

\begin_layout Standard
!!!!
\end_layout

\begin_layout Section
extended typing rules
\end_layout

\begin_layout Standard
structural rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash p:a:A\approx_{-:\varGamma'}b:B}{\overline{q}\begin{array}{c}
\varGamma\\
\varGamma'
\end{array}\vdash_{k}\left\{ a\sim_{k,p}b\right\} :a:A\approx b:B}??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{x:p_{B}^{A}\in\varGamma}{\varGamma\vdash_{k}x\::x:A\approx x:B}??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma,x:p_{B}^{A}\vdash_{k}C:\qquad C^{L}:\star\approx C^{R}:\star}{\varGamma\vdash_{k}\prod x:p_{B}^{A}.C\::\prod x:A.C^{L}:\star\approx\prod x:B.C^{R}:\star}??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash_{k}b\ :\ b^{L}:\prod x:A^{L}.C^{L}\approx b^{R}:\prod x:A^{R}.C^{R}\\
\varGamma\vdash_{k}a\ :\ a^{L}:A^{L}\approx a^{R}:A^{R}
\end{array}}{\varGamma\vdash_{k}b\ a\::\ b^{L}\ a^{L}:C^{L}\left[a^{L}\right]\approx b^{R}\ a^{R}:C^{R}\left[a^{R}\right]}??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma,x:refl_{A}^{A}\vdash_{k}b\ :\ b^{L}:B^{L}\approx b^{R}:B^{R}}{\varGamma\vdash_{k}\lambda x.b\::\ b^{L}\ \prod x:A.C^{L}\approx b^{R}:\prod x:A.C^{R}}...??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash_{k}a\ :\ a^{L}:A^{L}\approx a^{R}:A^{R}\\
\varGamma\uparrow\vdash p:A^{L}:-\approx_{-:\varGamma\uparrow}B^{L}:...\\
\varGamma\downarrow\vdash p:A^{R}:-\approx_{-:\varGamma\downarrow}B^{R}:...
\end{array}}{\varGamma\vdash_{k}a::\begin{array}{c}
k=L,p\\
k=R,q
\end{array}\ :\ a^{L}::p:B^{L}\approx a^{R}::q:B^{R}}...??
\]

\end_inset


\end_layout

\begin_layout Standard
assert...
\end_layout

\begin_layout Standard
data...
\end_layout

\begin_layout Standard
conv...
\end_layout

\begin_layout Section
pathing rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{q}\begin{array}{c}
\varGamma\\
\varGamma'
\end{array}\vdash_{k}a\ :\ a^{L}:A^{L}\approx a^{R}:A^{R}}{\varGamma\vdash Cong_{k\Rightarrow a}^{\overline{q}:\varGamma\approx\varGamma',?:A\approx B}:a^{L}:A^{L}\approx_{\overline{q}:\varGamma'}a^{R}:A^{R}}??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
\varGamma\vdash p\ :\ a:A\approx_{?:\varGamma'}b:B\\
\varGamma'\vdash q\ :\ b:B'\approx_{?:\varGamma''}c:C\\
\varGamma'\vdash r\ :\ B:\star\approx_{?:\varGamma'}B':\star
\end{array}}{\varGamma\vdash p;_{r}q\ :\ a:A\approx_{?:\varGamma'}c:C}??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{x_{p}:a:A\approx_{?:\varGamma'}b:B\in\varGamma}{\varGamma\vdash x_{p}:a:A\approx_{?:\varGamma'}b:B}??
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\varGamma\vdash p:a:A\approx_{?:\varGamma'}b:B}{\varGamma'\vdash p^{-1}:b:B\approx_{?^{-1}:\varGamma}a:A}??
\]

\end_inset


\end_layout

\begin_layout Standard
assert...
\end_layout

\begin_layout Standard
data...
\end_layout

\begin_layout Standard
conv...
\end_layout

\begin_layout Part
Old OLD Formalisms
\end_layout

\begin_layout Section
Cast Language Pattern Matching
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="35" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path var,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion index,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kin$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k=left$
\end_inset

 | 
\begin_inset Formula $k=right$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion maps,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kmap$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kin,}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
casts under assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kmap,p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path exp.,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p,p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path variable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{p\ k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concrete assumption
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concatenated paths
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $cong_{x\Rightarrow a}p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
congruence
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reverse a path
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extract the 
\begin_inset Formula $i$
\end_inset

type argument from a data type constructor 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extract the 
\begin_inset Formula $i$
\end_inset

type argument from a data constructor 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $ty\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
derive a path between types
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast pattern,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $patc$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $\left(d\,\overline{patc}\right)::x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast expression,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'_{\ell}}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{kcast}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
force blame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ a\sim_{k,o,\ell}b\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assert same
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inEx_{\overline{patc}}[\overline{a}]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
in-exhaustive pattern match
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
extend H ctxs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Data
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several of the constructs familiar form the last chapter are extended.
 Patterns are extended with path variable.
 In addition to the expected branches the 
\begin_inset Formula $\mathsf{case}$
\end_inset

 construct now explicitly contains a collection of unmatched patterns that
 will allow for a static warning, and if reached, a runtime error.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(the empty path)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $refl$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kmap,p;kmap',q;...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::\begin{array}{cc}
kmap, & p\\
kmap', & q\\
... & ...
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::\begin{array}{cc}
kmap,k=left, & p\\
kmap,k=right, & p\\
kmap',k=left, & q\\
kmap,k=right, & q\\
... & ...
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::\begin{array}{cc}
kmap, & p\\
kmap', & q\\
... & ...
\end{array}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset

 is irrelevant
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the telescope is clear from context
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d_{\Delta}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
when 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the telescope is clear from context
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{refl\ k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
written
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{\ k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Abbreviations
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-pre-syntax-abrev"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this thesis we have taken an extremely extensional perspective, terms
 are only different if an observation recognizes a difference.
 For instance, functions 
\begin_inset Formula $\lambda x\Rightarrow x+1=\lambda x\Rightarrow1+x$
\end_inset

 should be equatable without proof, even though they are usually definitionally
 distinct.
 Therefore we will only blame inequality across functions if two functions
 that were asserted to be equal return different observations for 
\begin_inset Quotes eld
\end_inset

the same
\begin_inset Quotes erd
\end_inset

 input.
 Tracking that two functions should be equal becomes complicated, the system
 must be sensible under context, functions can take other higher order inputs,
 and function terms can be copied freely.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Example back to pattern matching?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The cleanest way I could find to encode a dynamic check for function equality,
 was with a new term level construct, 
\begin_inset Formula $\left\{ a\sim_{k,o,\ell}b\right\} $
\end_inset

 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
it would also be possible to extend the system with meta variables, though
 this seems harder to formalize
\end_layout

\end_inset

.
 This assertion that two terms are the same is written as 
\begin_inset Formula $\left\{ a\sim_{k,o,\ell}b\right\} $
\end_inset

 and will evaluate 
\begin_inset Formula $a$
\end_inset

and 
\begin_inset Formula $b$
\end_inset

 in parallel until both 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 evaluate to a head constructor.
 If the head constructor is different the term will get stuck with the informati
on for blame.
 If the constructor is the same it will commute out of the term.
 For instance, 
\begin_inset Formula $\left\{ \lambda x\Rightarrow x+1\sim_{k,o,\ell}\lambda x\Rightarrow1+x\right\} \rightsquigarrow_{*}\lambda x\Rightarrow\left\{ x+1\sim_{k,o.App[x],\ell}1+x\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
Since this same construct seems the best way to handle functions, we will
 use it for all runtime equality assertions.
 For instance, 
\begin_inset Formula $\left\{ \left(\lambda x\Rightarrow S\,x\right)Z\sim_{k,o,\ell}2+2\right\} \rightsquigarrow_{*}\left\{ S\,Z\sim_{k,o,\ell}S\,\left(1+2\right)\right\} \rightsquigarrow_{*}S\,\left\{ Z\sim_{k,o.DCon_{0},\ell}1+2\right\} \rightsquigarrow_{*}S\,\left\{ Z\sim_{k,o.DCon_{0},\ell}S\,2\right\} $
\end_inset

.
 We compute past the first 
\begin_inset Formula $S$
\end_inset

 constructor and blame the predecessor for not being equal.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Move later?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To control the use of this construct, assumptions will be bound into 
\begin_inset Formula $Assert$
\end_inset

 paths.
 For instance, 
\begin_inset Formula $Assert_{\ k\Rightarrow1+\left\{ 2\sim_{k,o,\ell}3\right\} }$
\end_inset

 will represent a user defined assertion that 
\begin_inset Formula $3\approx4$
\end_inset

.
 Binding the 
\begin_inset Formula $\{\sim\}$
\end_inset

 to a specific assert forces the 
\begin_inset Formula $\{\sim\}$
\end_inset

 to only appear in paths, they cannot appear unbound in the empty context.
 Additionally the binding allows the assumptions to be precisely tracked
 when paths contain terms that contain paths that contain terms.
 For technical reasons, 
\begin_inset Formula $Assert$
\end_inset

s also hold evidence that the types of the 
\begin_inset Formula $2$
\end_inset

 endpoints match, For instance in 
\begin_inset Formula $Assert_{p\ k\Rightarrow\left\{ true\sim_{k,o,\ell}3\right\} }$
\end_inset

 , 
\begin_inset Formula $p:\mathbb{B}\approx\mathbb{N}$
\end_inset

 .
 While separating user assumptions into casts, Asserts, and 
\begin_inset Formula $\{\sim\}$
\end_inset

, is more complicated then in Chapter 3, we have a clearer interpretation
 of assertions that only hold other assertions, here the binding assumption
 is simply not used, 
\begin_inset Formula $Assert_{p\ -\Rightarrow C}$
\end_inset

 .
\end_layout

\begin_layout Standard
Unfortunately this dynamic assertion complicates other aspects of the system.
 Specifically, 
\end_layout

\begin_layout Itemize
How do same assertions interact with casts? For instance, 
\begin_inset Formula $\left\{ 1::Bool\sim_{k,o,\ell}2::Bool\right\} $
\end_inset

.
 
\end_layout

\begin_layout Itemize
How do sameness assertions cast check? This is difficult, because there
 is no requirement that a user asserted equality is of the same type.
 For instance what type should the term 
\begin_inset Formula $\left\{ 1\sim_{k,o,\ell}True\right\} $
\end_inset

 have?
\end_layout

\begin_layout Standard
Since there will only ever be a finite number of assumptions, we can give
 each assumption a unique index 
\begin_inset Formula $k$
\end_inset

 and consider all computations and judgments point-wise for every different
 combinations of 
\begin_inset Formula $k$
\end_inset

s.
 We will extend the notion of cast so different casts are possible for every
 assignment of 
\begin_inset Formula $k$
\end_inset

s in scope.
 So 
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ 1::Bool\sim_{k,o,\ell}2::Bool\right\} \rightsquigarrow_{*}\left\{ 1\sim_{k,o,\ell}2::Bool\right\} ::k=left,Bool\rightsquigarrow_{*}\left\{ 1\sim_{k,o,\ell}2\right\} ::\begin{array}{c}
k=right,Bool\\
k=left,Bool
\end{array}=\left\{ 1\sim_{k,o,\ell}2\right\} ::Bool$
\end_inset

 
\end_layout

\begin_layout Standard
where we allow syntactic sugar to summarize the cast when they are the same
 over all branches (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:surface-pre-syntax-abrev"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
We will also index typing judgments by the choice of 
\begin_inset Formula $k$
\end_inset

 in scope so that, 
\begin_inset Formula $k=left\vdash\left\{ 1\sim_{k,o,\ell}True\right\} :Nat$
\end_inset

 and 
\begin_inset Formula $k=right\vdash\left\{ 1\sim_{k,o,\ell}True\right\} :Bool$
\end_inset

.
\end_layout

\begin_layout Standard
Now we must consider how patterns would evaluate under assumptions.
 The original inspiration was to allow abstraction over casts as represented
 by a path, but now casts contain a bundle of paths each indexed by assumptions,
 that may or may not have the same start and endpoint.
 Luckily, we can maintain the operational behavior by allowing uniform substitut
ion into path variables.
\end_layout

\begin_layout Standard
For simplicity of the formalization, we will require that 
\begin_inset Formula $kmap$
\end_inset

s always uniquely map every 
\begin_inset Formula $k$
\end_inset

 index in scope.
 We will also assume that 
\begin_inset Formula $kcast$
\end_inset

 handles all possible mappings of 
\begin_inset Formula $k$
\end_inset

s in scope.
\end_layout

\begin_layout Standard
Substitution is outlined in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data-sub"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The function 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\lfloor -\right\rfloor _{k=-}$
\end_inset

 filters a term along 
\begin_inset Formula $k$
\end_inset

 taking it out of scope.
 For instance
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\lfloor \left\{ 7\sim_{k,o,\ell}True\right\} \right\rfloor _{k=left}=7$
\end_inset

 and
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\lfloor 3::\begin{array}{ccc}
k=left & j=left & Bool\\
k=left & j=right & Nat\\
k=right & j=left & String\\
k=right & j=right & Unit
\end{array}\right\rfloor _{k=right}=3::\begin{array}{cc}
j=left & String\\
j=right & Unit
\end{array}$
\end_inset

.
 The function 
\begin_inset Formula $\left\lceil -\right\rceil ^{k}$
\end_inset

 puts an assumption 
\begin_inset Formula $k$
\end_inset

 into scope extending it in every cast.
 For instance, 
\begin_inset Formula $\left\lceil 3::\begin{array}{cc}
j=left & String\\
j=right & Unit
\end{array}\right\rceil ^{k}=3::\begin{array}{ccc}
j=left & k=left & String\\
j=left & k=right & String\\
j=right & k=left & Unit\\
j=right & k=right & Unit
\end{array}$
\end_inset

 and 
\begin_inset Formula $\left\lceil !_{x_{p}}\right\rceil ^{k}=!_{\begin{array}{cc}
k=left & x_{p}\\
k=right & x_{p}
\end{array}}$
\end_inset

.
 The subscript 
\begin_inset Formula $kcast_{kmap}$
\end_inset

 selects the appropriate assumption from the 
\begin_inset Formula $kcast$
\end_inset

.
 For instance 
\begin_inset Formula $\begin{array}{ccc}
k=left & j=left & x_{p}\\
k=left & j=right & refl\\
k=right & j=left & y_{p}\\
k=right & j=right & x_{p}
\end{array}_{k=right,j=left}=y_{p}$
\end_inset

 .
 Since we every choice in scope is handled, this result always exists.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{b,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}c}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{b\left[x\coloneqq a\right],}\,\left\{ \overline{|\,\overline{patc\Rightarrow}c\left[x\coloneqq a\right]}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{kcast}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{kcast\left[x\coloneqq a\right]}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b::kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $b\left[x\coloneqq a\right]::kcast\left[x\coloneqq a\right]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ b\sim_{k,o,\ell}c\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ b\left[x\coloneqq\left\lfloor a\right\rfloor _{k=left}\right]\sim_{k,o\left[x\coloneqq a\right],\ell}c\left[x\coloneqq\left\lfloor a\right\rfloor _{k=right}\right]\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{p\ k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{p\left[x\coloneqq a\right]\ k\Rightarrow C\left[x\coloneqq\left\lceil a\right\rceil ^{k}\right]}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{p\circ}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{p\left[x\coloneqq a\right]\circ}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $cong_{y\Rightarrow b}p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $cong_{y\Rightarrow b\left[x\coloneqq a\right]}p\left[x\coloneqq a\right]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\left[x\coloneqq a\right]^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,\left(p\left[x\coloneqq a\right]\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,\left(p\left[x\coloneqq a\right]\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $ty\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $ty\,\left(p\left[x\coloneqq a\right]\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kmap,p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x\coloneqq a\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kmap,p\left[x\coloneqq\left\lfloor a\right\rfloor _{kmap}\right];}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x_{p}\coloneqq p\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}c}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x_{p}\coloneqq kcast\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a\left[x_{p}\coloneqq kcast\right],}\,\left\{ \overline{|\,\overline{patc\Rightarrow}c\left[x_{p}\coloneqq kcast\right]}\overline{|\,\overline{patc'}_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{kcast}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x_{p}\coloneqq kcast\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{kcast\left[x_{p}\coloneqq kcast\right]}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kcast'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x_{p}\coloneqq kcast\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a\left[x_{p}\coloneqq kcast\right]::kcast'\left[x_{p}\coloneqq kcast\right]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ b\sim_{k,o,\ell}c\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left[x_{p}\coloneqq kcast\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ b\left[x\coloneqq\left\lfloor kcast\right\rfloor _{k=left}\right]\sim_{k,o\left[x\coloneqq a\right],\ell}c\left[x\coloneqq\left\lfloor kcast\right\rfloor _{k=right}\right]\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kmap,p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\left[x_{p}\coloneqq kcast\right]=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{kmap,p\left[x_{p}\coloneqq kcast_{kmap}\right];}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Review this
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Data Sub
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-sub"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Cast Value, Blame, and Reductions
\end_layout

\begin_layout Standard
We need to extend the notion of value, Blame and call-by-value reduction
 from Chapter 3.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{a\:\mathbf{whnf}\quad b\:\mathbf{whnf}\quad\mathbf{head}\,a\neq\mathbf{head}\,b}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\left\{ a\sim_{k,o,\ell}b\right\} }
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\,\mathbf{Match}\,\overline{patc'}_{j}}{\textbf{Blame}\:\ensuremath{\ell}\,inEx_{\overline{patc'}_{j}}[\overline{a}]\,\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'\Rightarrow}!_{\ell_{j}}}\right\} }
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
fix syntax?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\ \mathbf{!Match}\ \ensuremath{\ell}\,o\,\overline{|\overline{patc'}_{j}}}{\textbf{Blame}\:\ensuremath{\ell}\,o\,\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}-}\right\} }
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{!_{kcast}\quad\textbf{Blame}\:\ensuremath{\ell}\,o\ kcast}{\textbf{Blame}\:\ensuremath{\ell}\,o\,!_{kcast}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Selection of Cast Language Blame
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-Blame"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\textbf{Blame}$
\end_inset

 relation from Chapter 3 are simplified via the sameness assertion
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data-Blame"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
There are two new sources of blame from the 
\begin_inset Formula $\mathsf{case}$
\end_inset

 construct.
 The cast language records every 
\begin_inset Quotes eld
\end_inset

unhandled
\begin_inset Quotes erd
\end_inset

 branch and if a scrutinee hits one of those branches the case will be blamed
 for in-exhaustiveness 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This runtime error is conventional in ML style languages, and is even how
 Agda handles incomplete matches.
\end_layout

\end_inset

.
 If a scrutinee list primitively contradicts the pattern coverage via the
 
\begin_inset Formula $\mathbf{!Match}$
\end_inset

 judgment blame will be extracted from the scrutinee.
 Since our type system will ensure complete coverage (based only on constructors
) if a scrutinee escapes the complete pattern match in an empty context,
 it must be that there was a blamable cast to the head constructor.
 
\end_layout

\begin_layout Standard
As expected, the new syntax to explicitly trigger blame, 
\begin_inset Formula $!$
\end_inset

, will trigger blame when reached.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Say more about how blame behaves over terms and paths?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have elided most of the structural rules that extract blame from terms,
 paths, and casts.
 We have left the structural rule for explicit blame for emphasis.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
just put them in
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
REDO THIS
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\textbf{Blame}\:\ensuremath{\ell}\,o\ p}{\left(d'\ \overline{patc}\right)::p\ \mathbf{!Match}\ \ensuremath{\ell}\,o\,\left(d\ \overline{patc}\right)::p}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
This figure is not very helpful?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Blame
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-NoMatch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\star\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\left(x:A\right)\rightarrow B\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{kcast\ \mathbf{Val}\quad\forall Assert_{k\Rightarrow\left(x:A\right)\rightarrow B}\in kcast}{\left(fun\,f\,x\Rightarrow a\right)::kcast\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
clean up notation above
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\ \mathbf{Val}}{D\,\overline{a}\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\ \mathbf{Val}\quad kcast\ \mathbf{Val}\quad\exists D.\forall Assert_{k\Rightarrow D\overline{b}}\in kcast}{\left(d\,\overline{a}\right)::kcast\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
clean up notation above
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}\quad C\ \mathbf{Val}\quad C\neq\star}{Assert_{p\ k\Rightarrow C}\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}\quad q\ \mathbf{Val}}{p;q\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{refl\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}}{kmap,p\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\forall kmap,p\in kcast,\ kmap,p\,\mathbf{Val}}{kcast\ \mathbf{Val}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Selection of Cast Language Values
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-vals"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The value forms of the language must also be extended, values are presented
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data-vals"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 As before type level values must have all type level casts reduced, term
 level values are allowed casts as long as they are plausible and in 
\series bold
whnf
\series default
 .
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
path reductions
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{Assert_{-\Rightarrow\star}\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{cong_{x\Rightarrow a}\left(Assert_{p\ k\Rightarrow c}\right)\rightsquigarrow Assert_{k\Rightarrow a\left[x\coloneqq castl(c,ty\ p)\right]}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Assert is refl since cong is const over paths
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
given suitable condition on the kcast
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{cong_{x\Rightarrow a}refl\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{cong_{x\Rightarrow a}\left(p;q\right)\rightsquigarrow\left(cong_{x\Rightarrow a\left[x\coloneqq cast(x,leftty\ q)\right]}p\right);\left(cong_{x\Rightarrow a}q\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
this is a mess since now every path needs its endpoints!
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{\left(Assert_{k\Rightarrow C}\right)^{-1}\rightsquigarrow Assert_{k\Rightarrow\mathbf{Swap}_{k}C}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\quad}{refl^{-1}\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\quad}{\left(q\circ p\right)^{-1}\rightsquigarrow p^{-1}\circ q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(p\circ Assert_{k\Rightarrow D\overline{a}}\right)\rightsquigarrow inTC_{i}\left(p\right)\circ Assert_{k\Rightarrow a_{i}}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(p\circ Assert_{k\Rightarrow\left(d\overline{a}\right)::kcast}\right)\rightsquigarrow inC_{i}\left(p\right)\circ Assert_{k\Rightarrow a_{i}}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
given suitable condition on the kcast
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
structural rules
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{C\rightsquigarrow C'}{Assert_{k\Rightarrow C}\rightsquigarrow Assert_{k\Rightarrow C'}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'}{p\circ q\rightsquigarrow p\circ q'}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{p\circ q\rightsquigarrow p'\circ q}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
assumption reductions
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{\begin{array}{c}
kcast\\
\overline{kin,}p;\\
kcast'
\end{array}\rightsquigarrow\begin{array}{c}
kcast\\
\overline{kin,}p';\\
kcast'
\end{array}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{a\rightsquigarrow a'}{a::kcast\rightsquigarrow a'::kcast}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{kcast\rightsquigarrow kcast'}{a::kcast\rightsquigarrow a::kcast'}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
term reductions
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{!_{p}\rightsquigarrow!_{p'}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\left\{ a::\begin{array}{l}
kcast\\
\overline{kin,}p\circ Assert_{k\Rightarrow C};\\
kcast'
\end{array}\sim_{k,o,\ell}b\right\} \rightsquigarrow\left\{ a::\begin{array}{c}
kcast\\
\overline{kin,}p;\\
kcast'
\end{array}\sim_{k,o,\ell}b\right\} ::\overline{kin,}k=left\,Assert_{k\Rightarrow C};}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
could remove more then just assertions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\left\{ \star\sim_{k,o,\ell}\star\right\} \rightsquigarrow\star}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\left\{ \left(x:A\right)\rightarrow B\sim_{k,o,\ell}\left(x:A'\right)\rightarrow B'\right\} \rightsquigarrow\left(x:\left\{ A\sim_{k,o.arg,\ell}A'\right\} \right)\rightarrow\left\{ B\sim_{k,o.bod\left[x\right],\ell}B'\right\} }
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\left\{ \mathsf{fun}\,f\,x\Rightarrow b\sim_{k,o,\ell}\mathsf{fun}\,f\,x\Rightarrow b'\right\} \rightsquigarrow\mathsf{fun}\,f\,x\Rightarrow\left\{ b\sim_{k,o.app\left[x\right],\ell}b'\right\} }
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\left\{ d\overline{a}\sim_{k,o,\ell}d\overline{a'}\right\} \rightsquigarrow d\overline{\left\{ a_{i}\sim_{k,o.DCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{\left\{ D\overline{a}\sim_{k,o,\ell}D\overline{a'}\right\} \rightsquigarrow D\overline{\left\{ a_{i}\sim_{k,o.TCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{a::refl\rightsquigarrow a}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
by shorthand
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{\left(a::kcast\right)::kcast'\rightsquigarrow a::\left(kcast\circ kcast'\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
by shorthand
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\ }{\left(a::\begin{array}{c}
kcast\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
kcast'
\end{array}\right)b\rightsquigarrow\left(\left(a::\begin{array}{c}
kcast\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
kcast'
\end{array}\right)\left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right)::kin,Assert_{k\Rightarrow B\left[x\coloneqq\left\lfloor \left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right\rfloor _{k=kin}\right]};}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
double check
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\ \mathbf{Match}\ \overline{patc}_{i}}{\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b_{i}}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} \rightsquigarrow b_{i}\left[patc_{i}\coloneqq\overline{a}\right]}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Summery of Cast Language Reductions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-red"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This extension to the syntax induces many more reduction rules.
 We include a summery of selected reduction rules in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data-red"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We do not show the value restrictions to avoid clutter
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
there are also multiple ways to lay them out.
 For instance we could evaluate paths left to right or right to left.
\end_layout

\end_inset

.
 The important properties of reduction are 
\end_layout

\begin_layout Itemize
Paths reduce into a stack of zero or more 
\begin_inset Formula $Assert_{k\Rightarrow A}$
\end_inset

s
\end_layout

\begin_layout Itemize
Sameness assertions emit observably consistent constructors, and record
 the needed observations
\end_layout

\begin_layout Itemize
Sameness assertions will get stuck on inconsistent constructors
\end_layout

\begin_layout Itemize
Casts can commute out of sameness assertions with proper index tracking
\end_layout

\begin_layout Itemize
function application can commute around 
\begin_inset Formula $kcasts$
\end_inset

 , similar to Chapter 3, but will keep 
\begin_inset Formula $k$
\end_inset

 assumptions properly indexed
\end_layout

\begin_layout Standard
Matching is defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data-match"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Note that uncast terms are equivalent to refl cast terms.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
swap, pattern on the left?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
record substitutions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{a\ \mathbf{Match}\ x}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\ \mathbf{Match}\ \overline{patc}}{d\,\overline{a}\ \mathbf{Match}\ \left(d\,\overline{patc}\right)::x_{p}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\ \mathbf{Match}\ \overline{patc}}{\left(d\,\overline{a}\right)::kcast\ \mathbf{Match}\ \left(d\,\overline{patc}\right)::x_{p}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\overline{a}\ \mathbf{Match}\ \overline{patc}}{\left(d\,\overline{a}\right)::kcast\ \mathbf{Match}\ \left(d\,\overline{patc}\right)::x_{p}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{.\ \mathbf{Match}\ .}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{b\ \mathbf{Match}\ patc'\quad\overline{a}\ \mathbf{Match}\ \overline{patc}}{b\overline{a}\ \mathbf{Match}\ patc'\overline{patc}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
substitution abbreviation
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
-\left[\left(d\,\overline{patc}\right)::x_{p}\coloneqq d\,\overline{a}\right]=-\left[\overline{patc}\coloneqq\overline{a}\right]\left[x_{p}\coloneqq refl\right]
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
-\left[\left(d\,\overline{patc}\right)::x_{p}\coloneqq\left(d\,\overline{a}\right)::kcast\right]=-\left[\overline{patc}\coloneqq\overline{a}\right]\left[x_{p}\coloneqq kcast\right]
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language Matching and sub
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-match"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
double check paths are fully applied when needed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Cast language extension defined in this chapter is fairly complex.
 Though all the meta-theory of this section is plausible, we have not fully
 formalized it, and there is a potential that some subtle errors exist.
 To be as clear as possible about the uncertainty around the meta-theory
 proposed in this chapter, I will list what would normally be considered
 theorems and lemmas as conjectures.
 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
weird place to make this note.
 add it to the front or back matter?
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
There is a suitable definitional equality 
\begin_inset Formula $\equiv$
\end_inset

 , overloaded to all syntactic constructs, such that
\end_layout

\begin_layout Conjecture
\begin_inset Formula $\equiv$
\end_inset

 is an equivalence
\end_layout

\begin_layout Conjecture
\begin_inset Formula $a\rightsquigarrow_{*}b$
\end_inset

 and 
\begin_inset Formula $a'\rightsquigarrow_{*}b$
\end_inset

 implies 
\begin_inset Formula $a\equiv a'$
\end_inset


\end_layout

\begin_layout Conjecture
\begin_inset Formula $p\rightsquigarrow_{*}q$
\end_inset

 and 
\begin_inset Formula $p'\rightsquigarrow_{*}q$
\end_inset

 implies 
\begin_inset Formula $p\equiv p'$
\end_inset


\end_layout

\begin_layout Conjecture
\begin_inset Formula $kcast\rightsquigarrow_{*}kcast''$
\end_inset

 and 
\begin_inset Formula $kcast'\rightsquigarrow_{*}kcast''$
\end_inset

 implies 
\begin_inset Formula $kcast\equiv kcast''$
\end_inset


\end_layout

\begin_layout Conjecture
if 
\begin_inset Formula $\mathbf{Head\ }a\neq\mathbf{Head}\ b$
\end_inset

 then 
\begin_inset Formula $a\cancel{\equiv}b$
\end_inset

 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
settle on a capitalization for head
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
if 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $kmap$
\end_inset

 and 
\begin_inset Formula $kmap'$
\end_inset

 have consistent assignments then
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $kmap\equiv kmap'$
\end_inset


\end_layout

\begin_layout Conjecture
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
supports subtitutivity
\end_layout

\end_inset


\end_layout

\begin_layout Section
Cast System and Pathing
\end_layout

\begin_layout Standard
The cast system needs to maintain the consistency of well cast terms and
 also well typed paths.
 But unlike in Chapter 3 each judgment indexed by choices of 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard
The typing and pathing judgments are listed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cast-data-ty"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Pathing judgments record the endpoint of paths with the 
\begin_inset Formula $\thickapprox$
\end_inset

 symbol.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{x_{p}:A\thickapprox A'\in H}{HK\vdash x_{p}:A\thickapprox A'}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK,k=left\vdash a:A\quad HK,k=right\vdash a:A'}{HK\vdash Assert_{k\Rightarrow a}:\left\lfloor a\right\rfloor _{k=left}\thickapprox\left\lfloor a\right\rfloor _{k=right}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
does A=A'?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:A\thickapprox B\quad HK\vdash q:B\thickapprox C}{HK\vdash p\circ q:A\thickapprox C}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:b\thickapprox b\quad H,K\vdash b:B\quad H,K\vdash b':B\quad H,x:B,K\vdash A}{HK\vdash cong_{x\Rightarrow a}p:a\left[x\coloneqq b\right]\thickapprox a\left[x\coloneqq b'\right]}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:A\thickapprox B}{HK\vdash p^{-1}:B\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:\left(D\,\overline{a}\right)::kcast\ \thickapprox\ \left(D\,\overline{b}\right)::kcast'}{HK\vdash inTC_{i}\,p:a_{i}\thickapprox b_{i}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
and fully applied!
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash p:\left(d\,\overline{a}\right)::kcast\ \thickapprox\ \left(d\,\overline{b}\right)::kcast'}{HK\vdash inC_{i}\,p:a_{i}\thickapprox b_{i}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
and fully applied!
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
possibly force a matching type? but then it is unclear what type the conclusion
 should have
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{a'\equiv a\quad b'\equiv b\quad HK\vdash p:a\thickapprox b}{HK\vdash p:a'\thickapprox b'}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
will need to adjust this if moves to a typed conversion rule
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{k=left\in K\quad HK\vdash a:A}{HK\vdash\left\{ a\sim_{k,o,\ell}b\right\} :A}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{k=right\in K\quad HK\vdash b:B}{HK\vdash\left\{ a\sim_{k,o,\ell}b\right\} :B}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{HK\vdash a:A\quad HK\vdash kcast_{K}:A\thickapprox B}{HK\vdash a::kcast\ :B}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
HK\vdash\overline{a}:\Delta\\
H,\Delta,K\vdash B:\star\\
\forall\:i\,\left(HK\vdash\overline{pat}_{i}:\Delta\quad H,\left(\overline{pat}_{i}:\Delta\right)K\vdash b_{i}:B\right)\\
\forall\:j\,\left(HK\vdash\overline{pat}_{j}:\Delta\right)\\
HK\vdash\overline{\overline{patc}}\,\overline{\overline{patc'}}:\Delta\ \mathbf{complete}
\end{array}}{\begin{array}{c}
HK\vdash\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc_{i}\Rightarrow}b_{i}}\overline{|\,\overline{patc'_{j}\Rightarrow}!_{\ell}}\right\} \\
:M\left[\Delta\coloneqq\overline{a}\right]
\end{array}}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
pattern expansion and pattern on context may need further exposition
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\begin{array}{c}
HK\vdash C:\star\\
HK\vdash kcast_{K}:a\thickapprox a'\\
HK\vdash a:A\quad HK\vdash a':A\\
\mathbf{Head}(a)\neq\mathbf{Head}(a')
\end{array}}{HK\vdash!_{kcast}\ :C}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
REMOVE TYPE RESTRICTION? the extra type restrictions is intended to force
 blame to the type level when needed, though this will not (cannot?) be
 invariant over reduction of paths in general
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Language typing and pathing rules
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-data-ty"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
technically speaking, telescopes should generalize to the different syntactic
 classes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now conjecture the core lemmas that could be used to prove cast soundness
\end_layout

\begin_layout Conjecture
substitution of cast terms preserves cast
\end_layout

\begin_layout Conjecture
equivalently the following rule is admissible
\end_layout

\begin_layout Conjecture
\begin_inset Formula 
\[
\frac{HK\vdash a:A\quad x:A\in H\quad HK\vdash b:B}{H\left[x\coloneqq a\right]K\vdash b\left[x\coloneqq a\right]:B\left[x\coloneqq a\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
substitution of typed path preserves type
\end_layout

\begin_layout Conjecture
equivalently the following rule is admissible
\end_layout

\begin_layout Conjecture
\begin_inset Formula 
\[
\frac{HK\vdash p:a\thickapprox a'\quad x_{p}:a\thickapprox a'\in H\quad HK\vdash b:B}{H\left[x_{p}\coloneqq p\right]K\vdash b\left[x_{p}\coloneqq p\right]:B\left[x_{p}\coloneqq p\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
substitution of 
\begin_inset Formula $kcasts$
\end_inset

 preserve cast
\end_layout

\begin_layout Conjecture
equivalently the following rule is admissible
\end_layout

\begin_layout Conjecture
\begin_inset Formula 
\[
\frac{HK\vdash kcast_{K}:a\thickapprox a'\quad x_{p}:a\thickapprox a'\in H\quad HK\vdash b:B}{H\left[x_{p}\coloneqq kcast_{K}\right]K\vdash b\left[x_{p}\coloneqq kcast\right]:B\left[x_{p}\coloneqq kcast\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
substitution of cast terms preserves path endpoints
\end_layout

\begin_layout Conjecture
equivalently the following rule is admissible
\end_layout

\begin_layout Conjecture
\begin_inset Formula 
\[
\frac{HK\vdash a:A\quad x:A\in H\quad HK\vdash p:b\thickapprox b'}{H\left[x\coloneqq a\right]K\vdash p\left[x\coloneqq a\right]:b\left[x\coloneqq a\right]\thickapprox b'\left[x\coloneqq a\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
substitution of typed paths preserves path endpoints
\end_layout

\begin_layout Conjecture
equivalently the following rule is admissible
\end_layout

\begin_layout Conjecture
\begin_inset Formula 
\[
\frac{HK\vdash p:a\thickapprox a'\quad x_{p}:a\thickapprox a'\in H\quad HK\vdash q:b\thickapprox b'}{H\left[x_{p}\coloneqq p\right]K\vdash q\left[x_{p}\coloneqq p\right]:b\left[x_{p}\coloneqq p\right]\thickapprox b'\left[x_{p}\coloneqq p\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
substitution of 
\begin_inset Formula $kcasts$
\end_inset

 preserve cast
\end_layout

\begin_layout Conjecture
equivalently the following rule is admissible
\end_layout

\begin_layout Conjecture
\begin_inset Formula 
\[
\frac{HK\vdash kcast_{K}:a\thickapprox a'\quad x_{p}:a\thickapprox a'\in H\quad HK\vdash b:B}{H\left[x_{p}\coloneqq kcast_{K}\right]K\vdash q\left[x_{p}\coloneqq kcast_{K}\right]:b\left[x_{p}\coloneqq kcast\right]\thickapprox b'\left[x_{p}\coloneqq kcast\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally we will conjecture the cast soundness.
\end_layout

\begin_layout Conjecture
The cast system preserves types and path endpoints over normalization
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
a well typed path in an empty context is a value, takes a step, or produces
 blame
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ...
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
A well typed term in an empty context is a value, takes a step, or produces
 blame
\end_layout

\begin_layout Section
Elaborating Eliminations
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% elaboration unification
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

To make the overall system behave as expected we do not want to expose users
 to equality patterns, or force them to manually do the path bookkeeping.
 To work around this we extend a standard unification algorithm to cast
 patterns with instrumentation to remember paths that were required for
 the solution.
 Then if pattern matching is satisfiable, compile additional casts into
 the branch based on its assignments.
 Unlisted patterns can be checked to confirm they are unsatisfiable.
 If the pattern is unsatisfiable then elaboration can use the proof of unsatisfi
ability to construct explicit blame.
 If an unlisted pattern cannot be proven 
\begin_inset Quotes eld
\end_inset

unreachable
\begin_inset Quotes erd
\end_inset

 then we could warn the user, and like most functional programming languages,
 blame the incomplete match if that pattern ever occurs.
\end_layout

\begin_layout Subsection
Preliminaries
\end_layout

\begin_layout Standard
As mentioned in the introduction we will need to add and remove justified
 casts from the endpoints of arguments.
 For instance, we will need to be able to generate 
\begin_inset Formula $3\thickapprox x::Nat$
\end_inset

 from 
\begin_inset Formula $3\thickapprox x$
\end_inset

, 
\begin_inset Formula $x:X$
\end_inset

, and 
\begin_inset Formula $X\thickapprox Nat$
\end_inset

.
 Fortunately the language is already expressive enough to embed these operations
 using an 
\begin_inset Formula $Assert$
\end_inset

 that does not bind a 
\begin_inset Formula $same$
\end_inset

 assertion.
 
\end_layout

\begin_layout Standard
We will specify the shorthand 
\begin_inset Formula $CastR_{a}p=Assert_{k\Rightarrow a::k=right,p}:a\thickapprox a::p$
\end_inset

, similarly we can define 
\begin_inset Formula $CastL$
\end_inset

.
\end_layout

\begin_layout Standard
We can use use a similar construction to remove casts from an endpoint.
 Given a path 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $p:a::q\thickapprox b$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 , we can define the macro 
\begin_inset Formula $UnCastR_{a}p=Assert_{k\Rightarrow a::k=right,q}\circ p\ :\ a\thickapprox b$
\end_inset

, similarly for 
\begin_inset Formula $UnCastL$
\end_inset

.
\end_layout

\begin_layout Standard
The surface language needs to be enriched with additional location metadata
 at each position where the two bidirectional typing modalities would cause
 a check in the surface language.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $m...$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{n_{\ell},}\,\left\{ \overline{|\,\overline{pat\Rightarrow}m_{\ell'}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 without motive
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{n_{\ell},}\,\left\langle \overline{x\Rightarrow}M_{\ell'}\right\rangle \left\{ \overline{|\,\overline{pat\Rightarrow}m_{\ell''}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
 with motive
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The implementation allows additional annotations along the motive, while
 this works within the bidirectional framework.
 The syntax is not presented here since the theory is already quite complicated.
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
move note somewhere else
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Elaboration
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

can
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

could
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

"
\end_layout

\end_inset

, weasel words until implementation is finalized
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The biggest extension to the elaboration procedure in Chapter 3 is the path
 relevant unification and the insertion of casts to simulate surface language
 pattern matching.
 The unification and casting processes both work without 
\begin_inset Formula $k$
\end_inset

 assumptions in scope, simplifying the possible terms that may appear.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{\,}{U\left(\emptyset,\emptyset\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E,u\right)\quad a\equiv a'}{U\left(\left\{ p:a\thickapprox a'\right\} \cup E,u\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E\left[x\coloneqq a\right],u\left[x\coloneqq a\right]\right)}{U\left(\left\{ p:x\thickapprox a\right\} \cup E,u\cup\left\{ p:x\thickapprox a\right\} \right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
actually a little incorrect, needs to use conq to concat the paths
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(E\left[x\coloneqq a\right],u\left[x\coloneqq a\right]\right)}{U\left(\left\{ p:a\thickapprox x\right\} \cup E,u\cup\left\{ p^{-1}:x\thickapprox a\right\} \right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\left\{ p:a\thickapprox a'\right\} \cup E,u\right)\quad a\equiv d\overline{b}\quad a'\equiv d\overline{b'}}{U\left(\left\{ Con_{i}p:b_{i}\thickapprox b'_{i}\right\} _{i}\cup E,u\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
fully applied
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\left\{ p:a\thickapprox a'\right\} \cup E,u\right)\quad a\equiv D\overline{b}\quad a'\equiv D\overline{b'}}{U\left(\left\{ TCon_{i}p:b_{i}\thickapprox b'_{i}\right\} _{i}\cup E,u\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
fully applied
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\left\{ p:a::q\thickapprox a'\right\} \cup E,u\right)}{U\left(\left\{ uncastLp:a\thickapprox a\right\} _{i}\cup E,u\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
\frac{U\left(\left\{ p:a\thickapprox a'::q\right\} \cup E,u\right)}{U\left(\left\{ uncastRp:a\thickapprox a'\right\} \cup E,u\right)}
\]

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
fully applied
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
break cycle, make sure x is assignable
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
double check constraint order
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
correct vars in 4a
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Surface Language Unification
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:surface-data-unification"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The elaboration procedure uses the extended unification procedure to determine
 the implied type and assignment of each variable.
 In the match body casts are made so that variables behave as if they have
 the types and assignments consistent with the surface language.
 The original casting mechanism is still active, so it is possible that
 after all the casting types still don't line up.
 In this case primitive casts are still made at their given location.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
add explicit rules for elaboration?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The elaboration algorithm is extremely careful to only add casts, this means
 erasure is preserved and evaluation will be consistent with the surface
 language.
\end_layout

\begin_layout Standard
Further the remaining properties from Chapter 3 probably still hold
\end_layout

\begin_layout Conjecture
Every term well typed in the bidirectional surface language elaborates 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ..
\end_layout

\end_inset


\end_layout

\begin_layout Conjecture
Blame never points to something that checked in the bidirectional system
 
\end_layout

\begin_layout Section
Discussion and Future Work
\end_layout

\begin_layout Subsection
Blame is not tight
\end_layout

\begin_layout Standard
Though the meta theory in this section is plausible, there are some awkward
 allowed behaviors.
 Blame may not be able to zero in as precisely as it seems is possible,
 when an assumption interacts with itself.
 For instance take the term under assumption 
\begin_inset Formula $k$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ \lambda x\Rightarrow x\sim_{k,o,\ell}\lambda x\Rightarrow x\right\} \left\{ 1\sim_{k,o,\ell}2\right\} \rightsquigarrow_{*}\left(\lambda x\Rightarrow\left\{ x\sim_{k,o.app[x],\ell}x\right\} \right)\left\{ 1\sim_{k,o,\ell}2\right\} \rightsquigarrow_{*}\left\{ 2\sim_{k,o.app[\left\{ 1\sim_{k,o,\ell}2\right\} ],\ell}0\right\} $
\end_inset

 which will mistakenly give blame to the function when it is more reasonable
 to blame the argument.
 This situations is more complicated if we want to avoid blame when the
 two sides are mutually consistent 
\begin_inset Formula $\left\{ \lambda x\Rightarrow x\sim_{k,o,\ell}\lambda x\Rightarrow Not\ x\right\} \left\{ true\sim_{k,o,\ell}false\right\} \rightsquigarrow_{*}\left(\lambda x\Rightarrow\left\{ x\sim_{k,o.app[x],\ell}Not\ x\right\} \right)\left\{ true\sim_{k,o,\ell}false\right\} \rightsquigarrow_{*}\left\{ true\sim_{k,o.app[\left\{ true\sim_{k,o,\ell}false\right\} ],\ell}true\right\} $
\end_inset

.
\end_layout

\begin_layout Subsection
Types invariance along paths
\end_layout

\begin_layout Standard
It turns out that the system defined in Chapter 3 had the advantage of only
 dealing with equalities in the type universe.
 Extending to equalities over arbitrary type has vastly increased the complexity
 of the system.
 To make the system work paths are untyped, which seems inelegant.
 There is nothing currently preventing blame across type.
 For instance,
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ 1\sim_{k,o,\ell}false\right\} $
\end_inset

 will generate blame 
\begin_inset Formula $1\neq false$
\end_inset

.
 While blame of 
\begin_inset Formula $Nat\neq Bool$
\end_inset

 will certainly result in a better error message.
 Several attempts were made to encode the type into the type assumption,
 but the resulting systems quickly became too complicated to work with.
 Some vestigial typing constraints are still in the system (such as on the
 explicit blame) to encourage this cleaner blame.
 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
remove or revise
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Elaboration is non-deterministic with regard to blame
\end_layout

\begin_layout Standard
Consider the case
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <_:Id Nat 2 2 => S 2> {
\end_layout

\begin_layout Plain Layout

| refl _ a => s a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
that can elaborate to
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <_:Id Nat 2 2 => S 2> {
\end_layout

\begin_layout Plain Layout

| (refl A a)::p => (s (a::TCon0(p)) :: Cong uncastL(TCon1(p)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $p:Id\,A\,a\,a\thickapprox Id\,Nat\,2\,2$
\end_inset

, where 
\begin_inset Formula $TCon_{1}p$
\end_inset

 selects the first position 
\begin_inset Formula $p:Id\,A\,\underline{a}\,a\thickapprox Id\,Nat\,\underline{2}\,2$
\end_inset

.
 But this could also have elaborated to 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <_:Id Nat 2 2 => S 2> {
\end_layout

\begin_layout Plain Layout

| (refl A a)::p => (s (a::TCon0(p)) :: Cong uncastL(TCon2(p)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
relying on 
\begin_inset Formula $p:Id\,A\,a\,\underline{a}\thickapprox Id\,Nat\,2\,\underline{2}$
\end_inset

.
 This can make a difference if the scrutinee is 
\end_layout

\begin_layout Standard
\begin_inset Formula $refl\ Nat\,2::Id\,Nat\,3\,2::Id\,Nat\,2\,2$
\end_inset


\end_layout

\begin_layout Standard
in one case blame will be triggered, in the other it will not.
 In this case it is possible to mix the blame from both positions, though
 this does not seem to extend in general since the consequences of inequality
 are undecidable in general and we intend to allow running programs if they
 can maintain their intended types.
\end_layout

\begin_layout Subsection
Extending to Call-by-Value
\end_layout

\begin_layout Standard
As in Chapter 3, the system presented here does the minimal amount of checking
 to maintain type safety.
 This can lead to unexpected results, for instance consider the surface
 term 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case (refl Nat 7 :: Id Nat 2 2) <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| refl _ a => a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will elaborate into 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case (refl Nat 7 :: Id Nat 2 2) <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| (refl A a)::p => a::TCon0(p)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which will evaluate to 
\begin_inset Formula $7::\mathtt{Nat}$
\end_inset

 without generating blame.
 And indeed we only ever asserted that the result was of type 
\begin_inset Formula $\mathtt{Nat}$
\end_inset

.
\end_layout

\begin_layout Standard
In the implementation, some of this behavior is avoided by requiring type
 arguments in a cast be run call-by-value.
 This restriction will blame 
\begin_inset Formula $7\neq2$
\end_inset

 before the cast is even evaluated.
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
expand
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Efficiency
\end_layout

\begin_layout Standard
The system defined here is brutally inefficient.
 
\end_layout

\begin_layout Standard
In theory the system has an arbitrary slow down.
 As in Chapter 3, a cast that relies on non-terminating code can itself
 cause additional non-termination as paths are resolved.
\end_layout

\begin_layout Standard
As written there are many redundant computations, and trying every combination
 of assumptions is very inefficient.
 Currently the implementation is quite slow, though there are several ways
 to speed things up.
 Caching redundant computation would help.
 Having a smarter embedding of 
\begin_inset Formula $k$
\end_inset

 assignments would remove redundant work directly.
 To some extent 
\begin_inset Formula $Cong$
\end_inset

 and 
\begin_inset Formula $Assert$
\end_inset

 can be made multi-arity to allow fewer jumps.
 But most helpful of all would be simplifying away unneeded casts.
 More advanced options include using proof search to find casts that will
 never cause an error.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
paremetricity
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
relation to fun-ext
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
warnings
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Relation to UIP
\end_layout

\begin_layout Standard
Pattern matching as outlined in the last Chapter (which follows from 
\begin_inset CommandInset citation
LatexCommand cite
key "coquand1992pattern"
literal "false"

\end_inset

) implies the 
\series bold
uniqueness of identity proofs
\series default
 (UIP)
\begin_inset Foot
status open

\begin_layout Plain Layout
Also called 
\series bold
axiom k
\end_layout

\end_inset

.
 UIP states that every proof of identity is equal to refl (and thus unique),
 and is not provable in many type theories.
 In univalent type theories UIP is directly contradicted by the 
\begin_inset Quotes eld
\end_inset

non-trivial
\begin_inset Quotes erd
\end_inset

 equalities, required to equate isomorphisms and Id.
 UIP is derivable in the surface language by following pattern match 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <pr : Id A a a => Id (Id A a a) pr (refl A a) > {
\end_layout

\begin_layout Plain Layout

| refl A a => refl (Id A a a) (refl A a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This type checks since unification will assign 
\begin_inset Formula $pr\coloneqq refl\,A\,a$
\end_inset

 and under that assumption 
\begin_inset Formula $refl\ (Id\ A\ a\ a)\ (refl\ A\ a):Id\ (Id\ A\ a\ a)\ (refl\ A\ a)\ (refl\ A\ a)$
\end_inset

.
 Like univalent type theories, the cast language has its own nontrivial
 equalities, so it might seem that the cast language would also contradict
 UIP .
 But it is perfectly compatible, and will elaborate.
 One interpretation is that though there are multiple 
\begin_inset Quotes eld
\end_inset

proofs
\begin_inset Quotes erd
\end_inset

 of identity, we don't care which one is used.
 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
interpretation + take aways?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Future work
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
Make equalities visible in the surface syntax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The system here has some simple inspiration that could be extended into
 pattern matching syntax more generally.
 It seems useful to be able to read equational information out of patterns,
 especially in settings with rich treatment of equality.
 Matching equalities directly could be a semi-useful feature in Agda, or
 in univalent type theories such as CTT.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
This work was previously presented as an extended abstract at the TyDE workshop
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
cite
\end_layout

\end_inset

, the version there reflected a less plausible meta-theory based on earlier
 implementation experiments.
\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
CTT data is related?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/Users/stephaniesavir/thesis/bibliography/dtest"
options "alpha"

\end_inset


\end_layout

\begin_layout Part
TODO
\end_layout

\begin_layout Standard
check by value
\end_layout

\begin_layout List of TODOs

\end_layout

\begin_layout Section
notes
\end_layout

\begin_layout Standard
there are several simpler systems that can be worked through: eliminator
 style patterns, cast patterns, but to bring it all together we need congruence
 over functions.
\end_layout

\begin_layout Standard
adding paths and path variables means that constructs can still fail at
 runtime, but they can blame the actually problematic components
\end_layout

\begin_layout Standard
validating the K axiom, not that equalities are unique, merely that we don't
 care which one of the unique equalities is used.
\end_layout

\begin_layout Section
unused
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

-- standard data in normal form, 3
\end_layout

\begin_layout Plain Layout

S (S (S 0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- cast data in normal form
\end_layout

\begin_layout Plain Layout

S (S (S 0) :: Nat ) :: Nat :: Nat :: Nat
\end_layout

\begin_layout Plain Layout

S (S (S 0) :: Nat ) :: Bool :: Nat
\end_layout

\begin_layout Plain Layout

True :: Nat
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- cast pattern matching
\end_layout

\begin_layout Plain Layout

case x <_ => Bool> {
\end_layout

\begin_layout Plain Layout

| (Z :: _) => True
\end_layout

\begin_layout Plain Layout

| (S (Z :: _) :: _) => True
\end_layout

\begin_layout Plain Layout

| (S (S :: _) :: _) => False
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- extract specific blame,
\end_layout

\begin_layout Plain Layout

-- c is a path from Bool~Nat
\end_layout

\begin_layout Plain Layout

case x <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| (S ((true::c)::_) :: _) =>
\end_layout

\begin_layout Plain Layout

 add (false :: c) 2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- can reconstitute any term,
\end_layout

\begin_layout Plain Layout

-- not always possible with unification
\end_layout

\begin_layout Plain Layout

-- based pattern matching
\end_layout

\begin_layout Plain Layout

case x <_:Nat => Nat> {
\end_layout

\begin_layout Plain Layout

| (Z :: c) => Z :: c
\end_layout

\begin_layout Plain Layout

| (S x :: c) => S x :: c
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-- direct blame
\end_layout

\begin_layout Plain Layout

case x <_ => Nat> {
\end_layout

\begin_layout Plain Layout

| (S (true::c) :: _) => Bool =/=c Nat
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peek x =
\end_layout

\begin_layout Plain Layout

case x <_: Id Nat 0 1 => Nat> {
\end_layout

\begin_layout Plain Layout

  | (refl x :: _) => x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

peek (refl 4 :: Id Nat 0 1) = 4
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
to stylize consistently, should use math font, or like a nice image
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
break into smaller more relevant examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cast Pattern Matching
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:cast-pattern-matching"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily\small}"
inline false
status open

\begin_layout Plain Layout

case x <pr : Id A a a => Id (Id A a a) pr (refl A a) > {
\end_layout

\begin_layout Plain Layout

| (refl A' a') :: p => 
\end_layout

\begin_layout Plain Layout

refl (((Id A')::(A -> A -> *)) (a'::A) (a'::A) ) :: (pr' : (Id A a a) ->
 Id (Id A a a) pr' pr')
\end_layout

\begin_layout Plain Layout

(refl A')::((a : A) -> Id A a a) (a'::A)) :: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $p:Id\,A'\,a'\,a'\thickapprox Id\,A\,a\,a$
\end_inset

, ...
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{HK\,\mathbf{ok}}{HK\vdash\lozenge:.}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H,x:A;K\vdash\Delta\quad H;K\vdash A:\star\quad H;K\vdash patc:\Delta}{HK\vdash x,patc\::\:\left(x:A\right)\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
d\,:\,\varTheta\rightarrow D\overline{b}\in H\\
HK\vdash\overline{patc'}:\varTheta\\
H,\left(\overline{patc'}:\varTheta\right),x_{p}:D\overline{b}\thickapprox D\overline{a},K\vdash patc:\Delta\left[x\coloneqq d\,\overline{patc'}::_{x_{p}}\right]
\end{array}}{HK\vdash d\,\overline{patc'}::_{x_{p}},patc\::\:\left(x:D\overline{a}\right),\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{HK\vdash A:\star}{HK\vdash x:A}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma,x:M\vdash\Delta\quad\Gamma\vdash m:M\quad\Gamma\vdash\overline{n}\left[x\coloneqq m\right]:\Delta\left[x\coloneqq m\right]}{\Gamma\vdash m,\overline{n}\,:\,x:M,\Delta}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad\mathsf{data}\,D\,\Delta\in\Gamma}{\Gamma\vdash D\,:\,\Delta\rightarrow*}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Gamma\,\mathbf{ok}\quad d\,:\,\varTheta\rightarrow D\overline{m}\in\Gamma}{\Gamma\vdash d\,:\,\varTheta\rightarrow D\overline{m}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{HK\vdash x:A}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash A:\star}{H\vdash refl:A\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash B:\star\quad H,x:B\vdash C:\star\quad H\vdash b:B\quad H\vdash b':B\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv A'}{H\vdash A_{\ell.x\Rightarrow C}A':A\thickapprox A'}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT, would then need to resolve endpoint def equality
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash a':A\quad H,x:A\vdash C:\star}{H\vdash assert_{\ell.(a=a':A).x\Rightarrow C}:C\left[x\coloneqq a\right]\thickapprox C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash p:A\thickapprox B\quad H\vdash p':B\thickapprox C}{H\vdash p\,p':A\thickapprox C}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash p:A\thickapprox B}{H\vdash rev\,p:B\thickapprox A}
\]

\end_inset


\end_layout

\begin_layout Standard
typing rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash C:\star\quad H\vdash p:A\thickapprox B\quad AandBDisagree}{H\vdash A\neq_{p}B:C}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H,x:B\vdash C:\star\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv B}{H\vdash a::_{A,\ell.x\Rightarrow C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H\vdash a':A\quad H,x:A\vdash C:\star\quad H\vdash a:c\left[x\coloneqq a\right]}{H\vdash c::_{\ell\left(a=a':A\right).x\Rightarrow C}\quad:C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT remove concrete casts and merely use a symbolic cast instead?
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash a:A\quad H,x:B\vdash C:\star\quad C\left[x\coloneqq b\right]\equiv A\quad C\left[x\coloneqq b'\right]\equiv B\quad p:b\thickapprox b'}{H\vdash a::_{A,p.x\Rightarrow C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
ALT
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash c:C\left[x\coloneqq a\right]\quad H,x:A\vdash C:\star\quad H\vdash p:a\thickapprox a'}{H\vdash c::_{p.x\Rightarrow C}\quad:C\left[x\coloneqq a'\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\begin{array}{c}
H\vdash\overline{a}:\Delta\\
H,\Delta\vdash B:\star\\
\forall\:i\,\left(H\vdash Gen\left(\overline{patc}_{i}:\Delta,\Theta\right)\quad\Gamma,\Theta\vdash m:M\left[\Delta\coloneqq\overline{patc}_{i}\right]\right)\\
H\vdash\overline{\overline{patc}}:\Delta\ \mathbf{complete}
\end{array}}{\begin{array}{c}
\mathsf{case}\,\overline{a,}\,\left\langle \overline{\Delta\Rightarrow}B\right\rangle \left\{ \overline{|\,\overline{patc\Rightarrow}b}\right\} \\
:M\left[\Delta\coloneqq\overline{n}\right]
\end{array}}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
Gen is defined as 
\begin_inset Formula 
\[
\frac{\,}{H\vdash Gen\left(.:.,.\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\sim H\vdash A:\star\sim}{H\vdash Gen\left(x:(x:A),\;x:A\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\sim H\vdash A:\star\sim}{H\vdash Gen\left(x:A,\;x:A\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{d\,:\,\varTheta\rightarrow D\overline{a}\in H\quad H\vdash Gen\left(\overline{pat_{c}}:\varTheta,\Delta\right)}{H\vdash Gen\left(d\overline{pat_{c}}::_{x_{p}}:D\overline{b},\;\Delta,x_{p}:D\overline{a}\thickapprox D\overline{b}\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{H\vdash Gen\left(pat_{c}:A,\Theta\right)\quad H,\Theta\vdash Gen\left(\overline{pat_{c}}:\Delta\left[x\coloneqq pat_{c}\right],\Theta'\right)}{H\vdash Gen\left(pat_{c}\overline{pat_{c}}:\left(x:A,\Delta\right),\Theta\Theta'\right)}\,...
\]

\end_inset


\end_layout

\begin_layout Standard
other rules similar to the surface lang
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
old style red rules
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{rev\,\left(p\,p'\right)\rightsquigarrow\left(rev\,p'\right)\left(rev\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inTC_{i}\,\left(p\,p'\right)\rightsquigarrow\left(inTC_{i}\,p'\right)\left(inTC_{i}\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(p\,p'\right)\rightsquigarrow\left(inC_{i}\,p'\right)\left(inC_{i}\,p\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inTC_{i}\,refl\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,refl\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\overline{a}_{i}=a'\;\overline{c}_{i}=c'\;\overline{b}_{i}=b'}{inTC_{i}\,\left(D\,\overline{a}_{\ell.D\,\overline{c}}D\,\overline{b}\right)\rightsquigarrow a'_{\ell.c'}b'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(\left(a::A\right)_{\ell.c}b\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(a_{\ell.c}\left(b::B\right)\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{inC_{i}\,\left(a_{\ell.\left(c::C\right)}b\right)\rightsquigarrow inC_{i}\,\left(a_{\ell.c}b\right)}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\overline{a}_{i}=a'\;\overline{c}_{i}=c'\;\overline{b}_{i}=b'}{inTC_{i}\,\left(d\,\overline{a}_{\ell.d\,\overline{c}}d\,\overline{b}\right)\rightsquigarrow a'_{\ell.c'}b'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a::_{A,p\,refl,x.C}B\rightsquigarrow a::_{A,p,x.C}B}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\begin{array}{c}
a::_{A,p\,A'_{\ell.C''}B',x.C}B\rightsquigarrow\\
a::_{A,p,x.C}C\left[x\coloneqq A'\right]::_{\ell.C\left[x\coloneqq C''\right]}C\left[x\coloneqq B'\right]
\end{array}c}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
c?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left(a::_{A,p,x.C}C\right)\sim_{\ell o}b\rightsquigarrow a\sim_{\ell o}b}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a\sim_{\ell o}\left(b::_{B,p,x.C}C\right)\rightsquigarrow a\sim_{\ell o}b}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="33" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path var,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion index,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assertion assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kin$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k=left$
\end_inset

 | 
\begin_inset Formula $k=right$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
casts under assumption,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{\overline{kin,}p;}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
path exp.,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p,p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Assert_{k\Rightarrow C}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concrete cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $refl$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\begin_inset Formula $p'$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inTC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $inC_{i}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastL_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $uncastR_{kcast}\,p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast pattern,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $patc$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $d\,\overline{patc}::_{x_{p}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast expression,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset

...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc\Rightarrow}b}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data elim.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $!_{p}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
force blame
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a::kcast$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cast
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ a\sim_{k,o,\ell}b\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assert same
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
observations,
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Coloneqq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.App[a]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
application
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.TCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $o.DCon[i]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data cons.
 arg.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{C\rightsquigarrow C'}{Assert_{k\Rightarrow C}\rightsquigarrow Assert_{k\Rightarrow C'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{refl\,p\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{p\,refl\rightsquigarrow p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\quad}{\left(q\,p\right)^{-1}\rightsquigarrow p^{-1}\,q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'\quad p}{q\,p\rightsquigarrow q'\,p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\ \mathbf{Val}\quad p\rightsquigarrow p'}{q\,p\rightsquigarrow q\,p'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(Assert_{k\Rightarrow C}\right)^{-1}\rightsquigarrow Assert_{k\Rightarrow\mathbf{Swap}_{k}C}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(Assert_{k\Rightarrow D\overline{A}}\right)\rightsquigarrow Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(Assert_{k\Rightarrow d\overline{A}}\right)\rightsquigarrow Assert_{k\Rightarrow A_{i}}}
\]

\end_inset


\end_layout

\begin_layout Standard
TODO review this
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{remove\,k=left\,casts\quad a\:\mathbf{whnf}}{uncastL\,\left(Assert_{k\Rightarrow a::\overline{\overline{kin,}p;}}\right)\rightsquigarrow Assert_{k\Rightarrow a::\overline{\overline{kin',}p';}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex TODO Note (inline)
status open

\begin_layout Plain Layout
probly need to modify substution
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{refl^{-1}\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{inTC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\begin_inset Formula 
\[
\frac{\ }{inC_{i}\left(refl\right)\rightsquigarrow refl}
\]

\end_inset


\end_layout

\begin_layout Standard
TODO review this
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{uncastL\,\left(refl\right)\rightsquigarrow?}
\]

\end_inset


\end_layout

\begin_layout Standard
term redcutions
\begin_inset Formula 
\[
\frac{p\rightsquigarrow p'}{!_{p}\rightsquigarrow!_{p'}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ a::\overline{\overline{kin,}p;}\overline{kin,}q\,Assert_{k\Rightarrow C};\overline{\overline{kin',}p';}\sim_{k,o,\ell}b\right\} \rightsquigarrow\left\{ a::\overline{\overline{kin,}p;}\overline{kin,}q;\overline{\overline{kin',}p';}\sim_{k,o,\ell}b\right\} ::\overline{kin,}k=left\,Assert_{k\Rightarrow C};}
\]

\end_inset


\end_layout

\begin_layout Standard
symetric around 
\begin_inset Formula $\sim$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \star\sim_{k,o,\ell}\star\right\} \rightsquigarrow\star}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \left(x:A\right)\rightarrow B\sim_{k,o,\ell}\left(x:A'\right)\rightarrow B'\right\} \rightsquigarrow\left(x:\left\{ A\sim_{k,o.arg,\ell}A'\right\} \right)\rightarrow\left\{ B\sim_{k,o.bod\left[x\right],\ell}B'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ \mathsf{fun}\,f\,x\Rightarrow b\sim_{k,o,\ell}\mathsf{fun}\,f\,x\Rightarrow b'\right\} \rightsquigarrow\mathsf{fun}\,f\,x\Rightarrow\left\{ b\sim_{k,o.app\left[x\right],\ell}b'\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ d\overline{a}\sim_{k,o,\ell}d\overline{a'}\right\} \rightsquigarrow d\overline{\left\{ a_{i}\sim_{k,o.o.DCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{\left\{ D\overline{a}\sim_{k,o,\ell}D\overline{a'}\right\} \rightsquigarrow D\overline{\left\{ a_{i}\sim_{k,o.o.TCon[i],\ell}a'_{i}\right\} }}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\,}{a::\overline{\overline{kin,};}\rightsquigarrow a}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{pointwise\ concatination}{\left(a::\overline{\overline{kin,p};}\right)::\overline{\overline{kin',p'};}\rightsquigarrow...}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\ }{\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)b\rightsquigarrow\left(\left(a::\begin{array}{c}
...\\
kin,q\ Assert_{k\Rightarrow\left(x:A\right)\rightarrow B};\\
...
\end{array}\right)\left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right)::kin,Assert_{k\Rightarrow B\left[x\coloneqq\left\lfloor \left(b::kin,Assert_{k\Rightarrow\mathbf{Swap}_{k}A};\right)\right\rfloor _{k=kin}\right]};}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{Match\,\overline{a}\,patc_{i}}{\mathsf{case}\,\overline{a,}\,\left\{ \overline{|\,\overline{patc_{i}\Rightarrow}b_{i}}\overline{|\,\overline{patc'\Rightarrow}!_{\ell}}\right\} \rightsquigarrow b_{i}\left[patc_{i}\coloneqq\overline{a}\right]}
\]

\end_inset


\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}}{q\circ refl\circ p\rightsquigarrow q\circ p}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{p\ \mathbf{Val}\quad q\ \mathbf{Val}}{\left(q\circ p\right)^{-1}\rightsquigarrow p^{-1}\circ q^{-1}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\rightsquigarrow q'}{p\circ q\rightsquigarrow p\circ q'}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{q\ \mathbf{Val}\quad p\rightsquigarrow p'}{p\circ q\rightsquigarrow p'\circ q}
\]

\end_inset


\end_layout

\end_body
\end_document
