\chapter{Data in the Cast Langugae}
\label{chapter:CastData}
\thispagestyle{myheadings}

% Cast pattern matching is easy!
%Surprisingly, the cast system can be extended with a pattern matching construct without unification.
In Chapter 3 we used the TAS system and the bidirectional system to guid delaying equality to runtime.
The TAS corresponds to the cast system, and the bidirectional system corresponds to elaboration.
Specificly, the bidriectional approach localizes the equality checks.
In this chapter we will extend these systems for data and patternmatching.
This will turm out to be much more complicated then the system in chapter 3, since the only equality checks happened at types of the type universe.
In this chapter we will need to equate terms directly, and those terms will not necissarily have the same type.

\todo{Revise, pattern matching is a bidirectional thing}
\todo{formate case consistently}
If we hope to target the properties of Chapter 3 we need the cast language to be \textbf{cast sound}. 
Elaboration should satisfy the additional correctness\todo{``gradual correctness''?} properties relative to a type assignment system and bidirectional system.
In this case we will target the conjectured TAS from Chapter 4, with a first order unification style pattern matching. 

Despite this, there is an intresting interpertation of data and pattern matching when extended to the cast system.

Consider the normal forms of data terms.
While in standard type theory a normal form of data, in an empty context, must have the data constructor in head position (justifying the pattern syntax).
In the cast language, the normal form of data, in an empty context, will have a stack of zero or more casts applied to an expression with a data constructor in head position.
Casts are wrapped around constructors during the elaboration procedure, and will accumulate during evaluation.
If the cast language is extended with a path variable that can represent the stack of equalities, then that stack can be matched and used in the body of the branch.
Since the type constructor is known, it is possible to check the coverage of the patterns against it's constructors.
If every constructor is accounted for, only blameable data remains.
Quantifying over casts allows blame to be redirected, so if the program gets stuck in a pattern branch it can blame the original faulty assumption.

To account for unreachable patterns, we can record the proof of inequality that makes the unification unsatisfiable with explicit syntax, that will expose blame.
It is perfectly possible for a case expression to reduce into such an ``unreachable'' branch if a scrutinee with obsevably incorrect observations is inspected.
If this happens blame will be reflected back onto a specific problematic cast of the input.\todo{define path}

When we internalize the notion of path we need to support path operations that correspond to each of operations used by the unification of the bidirectional type system.
Specifically we need to index into the arguments of data constructors, and data type constructors.
We will also need to be able to reverse paths and concatenate paths since the unification algorithm implicitly uses these properties of equality.
Finally we need to be a able to remove and append casts from and to the endpoints of paths.

During elaboration, after a pattern is unified, we will inject the proofs of equality into the branch terms so that they cast check.
This will require that our notion of paths support congruence.

\input{5_Cast_data/2_Examples}
\input{5_Cast_data/old}
% \input{3_Cast/4_Elab}
% \input{3_Cast/5_Warnings}
% \input{3_Cast/6_Related}
